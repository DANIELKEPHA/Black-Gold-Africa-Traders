
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Catalog
 * 
 */
export type Catalog = $Result.DefaultSelection<Prisma.$CatalogPayload>
/**
 * Model SellingPrice
 * 
 */
export type SellingPrice = $Result.DefaultSelection<Prisma.$SellingPricePayload>
/**
 * Model OutLots
 * 
 */
export type OutLots = $Result.DefaultSelection<Prisma.$OutLotsPayload>
/**
 * Model Stocks
 * 
 */
export type Stocks = $Result.DefaultSelection<Prisma.$StocksPayload>
/**
 * Model StockAssignment
 * 
 */
export type StockAssignment = $Result.DefaultSelection<Prisma.$StockAssignmentPayload>
/**
 * Model Shipment
 * 
 */
export type Shipment = $Result.DefaultSelection<Prisma.$ShipmentPayload>
/**
 * Model ShipmentItem
 * 
 */
export type ShipmentItem = $Result.DefaultSelection<Prisma.$ShipmentItemPayload>
/**
 * Model StockHistory
 * 
 */
export type StockHistory = $Result.DefaultSelection<Prisma.$StockHistoryPayload>
/**
 * Model ShipmentHistory
 * 
 */
export type ShipmentHistory = $Result.DefaultSelection<Prisma.$ShipmentHistoryPayload>
/**
 * Model AdminNotification
 * 
 */
export type AdminNotification = $Result.DefaultSelection<Prisma.$AdminNotificationPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TeaGrade: {
  PD: 'PD',
  PD2: 'PD2',
  DUST: 'DUST',
  DUST1: 'DUST1',
  DUST2: 'DUST2',
  PF: 'PF',
  PF1: 'PF1',
  BP: 'BP',
  BP1: 'BP1',
  FNGS1: 'FNGS1',
  BOP: 'BOP',
  BOPF: 'BOPF',
  FNGS: 'FNGS',
  FNGS2: 'FNGS2',
  BMF: 'BMF',
  BMFD: 'BMFD',
  PF2: 'PF2',
  BMF1: 'BMF1'
};

export type TeaGrade = (typeof TeaGrade)[keyof typeof TeaGrade]


export const Broker: {
  AMBR: 'AMBR',
  ANJL: 'ANJL',
  ATBL: 'ATBL',
  ATLS: 'ATLS',
  BICL: 'BICL',
  BTBL: 'BTBL',
  CENT: 'CENT',
  COMK: 'COMK',
  CTBL: 'CTBL',
  PRME: 'PRME',
  PTBL: 'PTBL',
  TBEA: 'TBEA',
  UNTB: 'UNTB',
  VENS: 'VENS',
  TTBL: 'TTBL'
};

export type Broker = (typeof Broker)[keyof typeof Broker]


export const TeaCategory: {
  M1: 'M1',
  M2: 'M2',
  M3: 'M3',
  S1: 'S1'
};

export type TeaCategory = (typeof TeaCategory)[keyof typeof TeaCategory]


export const ShipmentStatus: {
  Pending: 'Pending',
  Approved: 'Approved',
  Shipped: 'Shipped',
  Delivered: 'Delivered',
  Cancelled: 'Cancelled'
};

export type ShipmentStatus = (typeof ShipmentStatus)[keyof typeof ShipmentStatus]


export const Vessel: {
  first: 'first',
  second: 'second',
  third: 'third',
  fourth: 'fourth'
};

export type Vessel = (typeof Vessel)[keyof typeof Vessel]


export const PackagingInstructions: {
  oneJutetwoPolly: 'oneJutetwoPolly',
  oneJuteOnePolly: 'oneJuteOnePolly'
};

export type PackagingInstructions = (typeof PackagingInstructions)[keyof typeof PackagingInstructions]

}

export type TeaGrade = $Enums.TeaGrade

export const TeaGrade: typeof $Enums.TeaGrade

export type Broker = $Enums.Broker

export const Broker: typeof $Enums.Broker

export type TeaCategory = $Enums.TeaCategory

export const TeaCategory: typeof $Enums.TeaCategory

export type ShipmentStatus = $Enums.ShipmentStatus

export const ShipmentStatus: typeof $Enums.ShipmentStatus

export type Vessel = $Enums.Vessel

export const Vessel: typeof $Enums.Vessel

export type PackagingInstructions = $Enums.PackagingInstructions

export const PackagingInstructions: typeof $Enums.PackagingInstructions

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.catalog`: Exposes CRUD operations for the **Catalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Catalogs
    * const catalogs = await prisma.catalog.findMany()
    * ```
    */
  get catalog(): Prisma.CatalogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellingPrice`: Exposes CRUD operations for the **SellingPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellingPrices
    * const sellingPrices = await prisma.sellingPrice.findMany()
    * ```
    */
  get sellingPrice(): Prisma.SellingPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outLots`: Exposes CRUD operations for the **OutLots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutLots
    * const outLots = await prisma.outLots.findMany()
    * ```
    */
  get outLots(): Prisma.OutLotsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stocks`: Exposes CRUD operations for the **Stocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stocks.findMany()
    * ```
    */
  get stocks(): Prisma.StocksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockAssignment`: Exposes CRUD operations for the **StockAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockAssignments
    * const stockAssignments = await prisma.stockAssignment.findMany()
    * ```
    */
  get stockAssignment(): Prisma.StockAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shipment`: Exposes CRUD operations for the **Shipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shipments
    * const shipments = await prisma.shipment.findMany()
    * ```
    */
  get shipment(): Prisma.ShipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shipmentItem`: Exposes CRUD operations for the **ShipmentItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShipmentItems
    * const shipmentItems = await prisma.shipmentItem.findMany()
    * ```
    */
  get shipmentItem(): Prisma.ShipmentItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockHistory`: Exposes CRUD operations for the **StockHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockHistories
    * const stockHistories = await prisma.stockHistory.findMany()
    * ```
    */
  get stockHistory(): Prisma.StockHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shipmentHistory`: Exposes CRUD operations for the **ShipmentHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShipmentHistories
    * const shipmentHistories = await prisma.shipmentHistory.findMany()
    * ```
    */
  get shipmentHistory(): Prisma.ShipmentHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminNotification`: Exposes CRUD operations for the **AdminNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminNotifications
    * const adminNotifications = await prisma.adminNotification.findMany()
    * ```
    */
  get adminNotification(): Prisma.AdminNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    User: 'User',
    Catalog: 'Catalog',
    SellingPrice: 'SellingPrice',
    OutLots: 'OutLots',
    Stocks: 'Stocks',
    StockAssignment: 'StockAssignment',
    Shipment: 'Shipment',
    ShipmentItem: 'ShipmentItem',
    StockHistory: 'StockHistory',
    ShipmentHistory: 'ShipmentHistory',
    AdminNotification: 'AdminNotification',
    Contact: 'Contact',
    Favorite: 'Favorite'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "user" | "catalog" | "sellingPrice" | "outLots" | "stocks" | "stockAssignment" | "shipment" | "shipmentItem" | "stockHistory" | "shipmentHistory" | "adminNotification" | "contact" | "favorite"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Catalog: {
        payload: Prisma.$CatalogPayload<ExtArgs>
        fields: Prisma.CatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          findFirst: {
            args: Prisma.CatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          findMany: {
            args: Prisma.CatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>[]
          }
          create: {
            args: Prisma.CatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          createMany: {
            args: Prisma.CatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>[]
          }
          delete: {
            args: Prisma.CatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          update: {
            args: Prisma.CatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          deleteMany: {
            args: Prisma.CatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CatalogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>[]
          }
          upsert: {
            args: Prisma.CatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          aggregate: {
            args: Prisma.CatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalog>
          }
          groupBy: {
            args: Prisma.CatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogCountAggregateOutputType> | number
          }
        }
      }
      SellingPrice: {
        payload: Prisma.$SellingPricePayload<ExtArgs>
        fields: Prisma.SellingPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellingPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellingPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>
          }
          findFirst: {
            args: Prisma.SellingPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellingPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>
          }
          findMany: {
            args: Prisma.SellingPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>[]
          }
          create: {
            args: Prisma.SellingPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>
          }
          createMany: {
            args: Prisma.SellingPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellingPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>[]
          }
          delete: {
            args: Prisma.SellingPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>
          }
          update: {
            args: Prisma.SellingPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>
          }
          deleteMany: {
            args: Prisma.SellingPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellingPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellingPriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>[]
          }
          upsert: {
            args: Prisma.SellingPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPricePayload>
          }
          aggregate: {
            args: Prisma.SellingPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellingPrice>
          }
          groupBy: {
            args: Prisma.SellingPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellingPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellingPriceCountArgs<ExtArgs>
            result: $Utils.Optional<SellingPriceCountAggregateOutputType> | number
          }
        }
      }
      OutLots: {
        payload: Prisma.$OutLotsPayload<ExtArgs>
        fields: Prisma.OutLotsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutLotsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutLotsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>
          }
          findFirst: {
            args: Prisma.OutLotsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutLotsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>
          }
          findMany: {
            args: Prisma.OutLotsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>[]
          }
          create: {
            args: Prisma.OutLotsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>
          }
          createMany: {
            args: Prisma.OutLotsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutLotsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>[]
          }
          delete: {
            args: Prisma.OutLotsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>
          }
          update: {
            args: Prisma.OutLotsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>
          }
          deleteMany: {
            args: Prisma.OutLotsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutLotsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutLotsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>[]
          }
          upsert: {
            args: Prisma.OutLotsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutLotsPayload>
          }
          aggregate: {
            args: Prisma.OutLotsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutLots>
          }
          groupBy: {
            args: Prisma.OutLotsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutLotsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutLotsCountArgs<ExtArgs>
            result: $Utils.Optional<OutLotsCountAggregateOutputType> | number
          }
        }
      }
      Stocks: {
        payload: Prisma.$StocksPayload<ExtArgs>
        fields: Prisma.StocksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StocksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StocksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>
          }
          findFirst: {
            args: Prisma.StocksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StocksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>
          }
          findMany: {
            args: Prisma.StocksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>[]
          }
          create: {
            args: Prisma.StocksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>
          }
          createMany: {
            args: Prisma.StocksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StocksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>[]
          }
          delete: {
            args: Prisma.StocksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>
          }
          update: {
            args: Prisma.StocksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>
          }
          deleteMany: {
            args: Prisma.StocksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StocksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StocksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>[]
          }
          upsert: {
            args: Prisma.StocksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StocksPayload>
          }
          aggregate: {
            args: Prisma.StocksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStocks>
          }
          groupBy: {
            args: Prisma.StocksGroupByArgs<ExtArgs>
            result: $Utils.Optional<StocksGroupByOutputType>[]
          }
          count: {
            args: Prisma.StocksCountArgs<ExtArgs>
            result: $Utils.Optional<StocksCountAggregateOutputType> | number
          }
        }
      }
      StockAssignment: {
        payload: Prisma.$StockAssignmentPayload<ExtArgs>
        fields: Prisma.StockAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>
          }
          findFirst: {
            args: Prisma.StockAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>
          }
          findMany: {
            args: Prisma.StockAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>[]
          }
          create: {
            args: Prisma.StockAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>
          }
          createMany: {
            args: Prisma.StockAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>[]
          }
          delete: {
            args: Prisma.StockAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>
          }
          update: {
            args: Prisma.StockAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.StockAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.StockAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAssignmentPayload>
          }
          aggregate: {
            args: Prisma.StockAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockAssignment>
          }
          groupBy: {
            args: Prisma.StockAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<StockAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Shipment: {
        payload: Prisma.$ShipmentPayload<ExtArgs>
        fields: Prisma.ShipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findFirst: {
            args: Prisma.ShipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findMany: {
            args: Prisma.ShipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          create: {
            args: Prisma.ShipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          createMany: {
            args: Prisma.ShipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          delete: {
            args: Prisma.ShipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          update: {
            args: Prisma.ShipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          upsert: {
            args: Prisma.ShipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          aggregate: {
            args: Prisma.ShipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipment>
          }
          groupBy: {
            args: Prisma.ShipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentCountAggregateOutputType> | number
          }
        }
      }
      ShipmentItem: {
        payload: Prisma.$ShipmentItemPayload<ExtArgs>
        fields: Prisma.ShipmentItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>
          }
          findFirst: {
            args: Prisma.ShipmentItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>
          }
          findMany: {
            args: Prisma.ShipmentItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>[]
          }
          create: {
            args: Prisma.ShipmentItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>
          }
          createMany: {
            args: Prisma.ShipmentItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>[]
          }
          delete: {
            args: Prisma.ShipmentItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>
          }
          update: {
            args: Prisma.ShipmentItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShipmentItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>[]
          }
          upsert: {
            args: Prisma.ShipmentItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentItemPayload>
          }
          aggregate: {
            args: Prisma.ShipmentItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipmentItem>
          }
          groupBy: {
            args: Prisma.ShipmentItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentItemCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentItemCountAggregateOutputType> | number
          }
        }
      }
      StockHistory: {
        payload: Prisma.$StockHistoryPayload<ExtArgs>
        fields: Prisma.StockHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>
          }
          findFirst: {
            args: Prisma.StockHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>
          }
          findMany: {
            args: Prisma.StockHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>[]
          }
          create: {
            args: Prisma.StockHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>
          }
          createMany: {
            args: Prisma.StockHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>[]
          }
          delete: {
            args: Prisma.StockHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>
          }
          update: {
            args: Prisma.StockHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>
          }
          deleteMany: {
            args: Prisma.StockHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>[]
          }
          upsert: {
            args: Prisma.StockHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockHistoryPayload>
          }
          aggregate: {
            args: Prisma.StockHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockHistory>
          }
          groupBy: {
            args: Prisma.StockHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<StockHistoryCountAggregateOutputType> | number
          }
        }
      }
      ShipmentHistory: {
        payload: Prisma.$ShipmentHistoryPayload<ExtArgs>
        fields: Prisma.ShipmentHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>
          }
          findFirst: {
            args: Prisma.ShipmentHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>
          }
          findMany: {
            args: Prisma.ShipmentHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>[]
          }
          create: {
            args: Prisma.ShipmentHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>
          }
          createMany: {
            args: Prisma.ShipmentHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>[]
          }
          delete: {
            args: Prisma.ShipmentHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>
          }
          update: {
            args: Prisma.ShipmentHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShipmentHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ShipmentHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentHistoryPayload>
          }
          aggregate: {
            args: Prisma.ShipmentHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipmentHistory>
          }
          groupBy: {
            args: Prisma.ShipmentHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentHistoryCountAggregateOutputType> | number
          }
        }
      }
      AdminNotification: {
        payload: Prisma.$AdminNotificationPayload<ExtArgs>
        fields: Prisma.AdminNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          findFirst: {
            args: Prisma.AdminNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          findMany: {
            args: Prisma.AdminNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>[]
          }
          create: {
            args: Prisma.AdminNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          createMany: {
            args: Prisma.AdminNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>[]
          }
          delete: {
            args: Prisma.AdminNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          update: {
            args: Prisma.AdminNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          deleteMany: {
            args: Prisma.AdminNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>[]
          }
          upsert: {
            args: Prisma.AdminNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          aggregate: {
            args: Prisma.AdminNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminNotification>
          }
          groupBy: {
            args: Prisma.AdminNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<AdminNotificationCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    user?: UserOmit
    catalog?: CatalogOmit
    sellingPrice?: SellingPriceOmit
    outLots?: OutLotsOmit
    stocks?: StocksOmit
    stockAssignment?: StockAssignmentOmit
    shipment?: ShipmentOmit
    shipmentItem?: ShipmentItemOmit
    stockHistory?: StockHistoryOmit
    shipmentHistory?: ShipmentHistoryOmit
    adminNotification?: AdminNotificationOmit
    contact?: ContactOmit
    favorite?: FavoriteOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    catalogs: number
    stocks: number
    sellingPrices: number
    outLots: number
    notifications: number
    shipments: number
    stockHistory: number
    shipmentHistory: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalogs?: boolean | AdminCountOutputTypeCountCatalogsArgs
    stocks?: boolean | AdminCountOutputTypeCountStocksArgs
    sellingPrices?: boolean | AdminCountOutputTypeCountSellingPricesArgs
    outLots?: boolean | AdminCountOutputTypeCountOutLotsArgs
    notifications?: boolean | AdminCountOutputTypeCountNotificationsArgs
    shipments?: boolean | AdminCountOutputTypeCountShipmentsArgs
    stockHistory?: boolean | AdminCountOutputTypeCountStockHistoryArgs
    shipmentHistory?: boolean | AdminCountOutputTypeCountShipmentHistoryArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountCatalogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StocksWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountSellingPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingPriceWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountOutLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutLotsWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNotificationWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountStockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockHistoryWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountShipmentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentHistoryWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    shipments: number
    stockHistory: number
    shipmentHistory: number
    favorites: number
    assignments: number
    contacts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipments?: boolean | UserCountOutputTypeCountShipmentsArgs
    stockHistory?: boolean | UserCountOutputTypeCountStockHistoryArgs
    shipmentHistory?: boolean | UserCountOutputTypeCountShipmentHistoryArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    assignments?: boolean | UserCountOutputTypeCountAssignmentsArgs
    contacts?: boolean | UserCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShipmentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type StocksCountOutputType
   */

  export type StocksCountOutputType = {
    assignments: number
    shipmentItems: number
    history: number
    favorites: number
  }

  export type StocksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | StocksCountOutputTypeCountAssignmentsArgs
    shipmentItems?: boolean | StocksCountOutputTypeCountShipmentItemsArgs
    history?: boolean | StocksCountOutputTypeCountHistoryArgs
    favorites?: boolean | StocksCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes
  /**
   * StocksCountOutputType without action
   */
  export type StocksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StocksCountOutputType
     */
    select?: StocksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StocksCountOutputType without action
   */
  export type StocksCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAssignmentWhereInput
  }

  /**
   * StocksCountOutputType without action
   */
  export type StocksCountOutputTypeCountShipmentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentItemWhereInput
  }

  /**
   * StocksCountOutputType without action
   */
  export type StocksCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockHistoryWhereInput
  }

  /**
   * StocksCountOutputType without action
   */
  export type StocksCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }


  /**
   * Count Type ShipmentCountOutputType
   */

  export type ShipmentCountOutputType = {
    historyEntries: number
    stockHistory: number
    stocks: number
  }

  export type ShipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    historyEntries?: boolean | ShipmentCountOutputTypeCountHistoryEntriesArgs
    stockHistory?: boolean | ShipmentCountOutputTypeCountStockHistoryArgs
    stocks?: boolean | ShipmentCountOutputTypeCountStocksArgs
  }

  // Custom InputTypes
  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentCountOutputType
     */
    select?: ShipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountHistoryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentHistoryWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountStockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockHistoryWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    adminCognitoId: string | null
    name: string | null
    email: string | null
    phoneNumber: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    adminCognitoId: string | null
    name: string | null
    email: string | null
    phoneNumber: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    adminCognitoId: number
    name: number
    email: number
    phoneNumber: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    adminCognitoId?: true
    name?: true
    email?: true
    phoneNumber?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    adminCognitoId?: true
    name?: true
    email?: true
    phoneNumber?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    adminCognitoId?: true
    name?: true
    email?: true
    phoneNumber?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    adminCognitoId: string
    name: string | null
    email: string | null
    phoneNumber: string | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminCognitoId?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    catalogs?: boolean | Admin$catalogsArgs<ExtArgs>
    stocks?: boolean | Admin$stocksArgs<ExtArgs>
    sellingPrices?: boolean | Admin$sellingPricesArgs<ExtArgs>
    outLots?: boolean | Admin$outLotsArgs<ExtArgs>
    notifications?: boolean | Admin$notificationsArgs<ExtArgs>
    shipments?: boolean | Admin$shipmentsArgs<ExtArgs>
    stockHistory?: boolean | Admin$stockHistoryArgs<ExtArgs>
    shipmentHistory?: boolean | Admin$shipmentHistoryArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminCognitoId?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminCognitoId?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    adminCognitoId?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminCognitoId" | "name" | "email" | "phoneNumber", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalogs?: boolean | Admin$catalogsArgs<ExtArgs>
    stocks?: boolean | Admin$stocksArgs<ExtArgs>
    sellingPrices?: boolean | Admin$sellingPricesArgs<ExtArgs>
    outLots?: boolean | Admin$outLotsArgs<ExtArgs>
    notifications?: boolean | Admin$notificationsArgs<ExtArgs>
    shipments?: boolean | Admin$shipmentsArgs<ExtArgs>
    stockHistory?: boolean | Admin$stockHistoryArgs<ExtArgs>
    shipmentHistory?: boolean | Admin$shipmentHistoryArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      catalogs: Prisma.$CatalogPayload<ExtArgs>[]
      stocks: Prisma.$StocksPayload<ExtArgs>[]
      sellingPrices: Prisma.$SellingPricePayload<ExtArgs>[]
      outLots: Prisma.$OutLotsPayload<ExtArgs>[]
      notifications: Prisma.$AdminNotificationPayload<ExtArgs>[]
      shipments: Prisma.$ShipmentPayload<ExtArgs>[]
      stockHistory: Prisma.$StockHistoryPayload<ExtArgs>[]
      shipmentHistory: Prisma.$ShipmentHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adminCognitoId: string
      name: string | null
      email: string | null
      phoneNumber: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    catalogs<T extends Admin$catalogsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$catalogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stocks<T extends Admin$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Admin$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sellingPrices<T extends Admin$sellingPricesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$sellingPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outLots<T extends Admin$outLotsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$outLotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Admin$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shipments<T extends Admin$shipmentsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$shipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockHistory<T extends Admin$stockHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Admin$stockHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shipmentHistory<T extends Admin$shipmentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Admin$shipmentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly adminCognitoId: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly phoneNumber: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.catalogs
   */
  export type Admin$catalogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    where?: CatalogWhereInput
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    cursor?: CatalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogScalarFieldEnum | CatalogScalarFieldEnum[]
  }

  /**
   * Admin.stocks
   */
  export type Admin$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    where?: StocksWhereInput
    orderBy?: StocksOrderByWithRelationInput | StocksOrderByWithRelationInput[]
    cursor?: StocksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StocksScalarFieldEnum | StocksScalarFieldEnum[]
  }

  /**
   * Admin.sellingPrices
   */
  export type Admin$sellingPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    where?: SellingPriceWhereInput
    orderBy?: SellingPriceOrderByWithRelationInput | SellingPriceOrderByWithRelationInput[]
    cursor?: SellingPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellingPriceScalarFieldEnum | SellingPriceScalarFieldEnum[]
  }

  /**
   * Admin.outLots
   */
  export type Admin$outLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    where?: OutLotsWhereInput
    orderBy?: OutLotsOrderByWithRelationInput | OutLotsOrderByWithRelationInput[]
    cursor?: OutLotsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutLotsScalarFieldEnum | OutLotsScalarFieldEnum[]
  }

  /**
   * Admin.notifications
   */
  export type Admin$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    where?: AdminNotificationWhereInput
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    cursor?: AdminNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminNotificationScalarFieldEnum | AdminNotificationScalarFieldEnum[]
  }

  /**
   * Admin.shipments
   */
  export type Admin$shipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Admin.stockHistory
   */
  export type Admin$stockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    where?: StockHistoryWhereInput
    orderBy?: StockHistoryOrderByWithRelationInput | StockHistoryOrderByWithRelationInput[]
    cursor?: StockHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockHistoryScalarFieldEnum | StockHistoryScalarFieldEnum[]
  }

  /**
   * Admin.shipmentHistory
   */
  export type Admin$shipmentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    where?: ShipmentHistoryWhereInput
    orderBy?: ShipmentHistoryOrderByWithRelationInput | ShipmentHistoryOrderByWithRelationInput[]
    cursor?: ShipmentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentHistoryScalarFieldEnum | ShipmentHistoryScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    userCognitoId: string | null
    name: string | null
    email: string | null
    role: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    userCognitoId: string | null
    name: string | null
    email: string | null
    role: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userCognitoId: number
    name: number
    email: number
    role: number
    phoneNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    userCognitoId?: true
    name?: true
    email?: true
    role?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userCognitoId?: true
    name?: true
    email?: true
    role?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userCognitoId?: true
    name?: true
    email?: true
    role?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    userCognitoId: string
    name: string | null
    email: string | null
    role: string
    phoneNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCognitoId?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shipments?: boolean | User$shipmentsArgs<ExtArgs>
    stockHistory?: boolean | User$stockHistoryArgs<ExtArgs>
    shipmentHistory?: boolean | User$shipmentHistoryArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    assignments?: boolean | User$assignmentsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCognitoId?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCognitoId?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    userCognitoId?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userCognitoId" | "name" | "email" | "role" | "phoneNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipments?: boolean | User$shipmentsArgs<ExtArgs>
    stockHistory?: boolean | User$stockHistoryArgs<ExtArgs>
    shipmentHistory?: boolean | User$shipmentHistoryArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    assignments?: boolean | User$assignmentsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      shipments: Prisma.$ShipmentPayload<ExtArgs>[]
      stockHistory: Prisma.$StockHistoryPayload<ExtArgs>[]
      shipmentHistory: Prisma.$ShipmentHistoryPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      assignments: Prisma.$StockAssignmentPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userCognitoId: string
      name: string | null
      email: string | null
      role: string
      phoneNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shipments<T extends User$shipmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$shipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockHistory<T extends User$stockHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$stockHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shipmentHistory<T extends User$shipmentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$shipmentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends User$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly userCognitoId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.shipments
   */
  export type User$shipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * User.stockHistory
   */
  export type User$stockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    where?: StockHistoryWhereInput
    orderBy?: StockHistoryOrderByWithRelationInput | StockHistoryOrderByWithRelationInput[]
    cursor?: StockHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockHistoryScalarFieldEnum | StockHistoryScalarFieldEnum[]
  }

  /**
   * User.shipmentHistory
   */
  export type User$shipmentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    where?: ShipmentHistoryWhereInput
    orderBy?: ShipmentHistoryOrderByWithRelationInput | ShipmentHistoryOrderByWithRelationInput[]
    cursor?: ShipmentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentHistoryScalarFieldEnum | ShipmentHistoryScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.assignments
   */
  export type User$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    where?: StockAssignmentWhereInput
    orderBy?: StockAssignmentOrderByWithRelationInput | StockAssignmentOrderByWithRelationInput[]
    cursor?: StockAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockAssignmentScalarFieldEnum | StockAssignmentScalarFieldEnum[]
  }

  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Catalog
   */

  export type AggregateCatalog = {
    _count: CatalogCountAggregateOutputType | null
    _avg: CatalogAvgAggregateOutputType | null
    _sum: CatalogSumAggregateOutputType | null
    _min: CatalogMinAggregateOutputType | null
    _max: CatalogMaxAggregateOutputType | null
  }

  export type CatalogAvgAggregateOutputType = {
    id: number | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    askingPrice: number | null
  }

  export type CatalogSumAggregateOutputType = {
    id: number | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    askingPrice: number | null
  }

  export type CatalogMinAggregateOutputType = {
    id: number | null
    broker: $Enums.Broker | null
    lotNo: string | null
    sellingMark: string | null
    grade: $Enums.TeaGrade | null
    invoiceNo: string | null
    saleCode: string | null
    category: $Enums.TeaCategory | null
    reprint: string | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    askingPrice: number | null
    producerCountry: string | null
    manufactureDate: Date | null
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogMaxAggregateOutputType = {
    id: number | null
    broker: $Enums.Broker | null
    lotNo: string | null
    sellingMark: string | null
    grade: $Enums.TeaGrade | null
    invoiceNo: string | null
    saleCode: string | null
    category: $Enums.TeaCategory | null
    reprint: string | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    askingPrice: number | null
    producerCountry: string | null
    manufactureDate: Date | null
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogCountAggregateOutputType = {
    id: number
    broker: number
    lotNo: number
    sellingMark: number
    grade: number
    invoiceNo: number
    saleCode: number
    category: number
    reprint: number
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    producerCountry: number
    manufactureDate: number
    adminCognitoId: number
    userCognitoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogAvgAggregateInputType = {
    id?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
  }

  export type CatalogSumAggregateInputType = {
    id?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
  }

  export type CatalogMinAggregateInputType = {
    id?: true
    broker?: true
    lotNo?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    saleCode?: true
    category?: true
    reprint?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
    producerCountry?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogMaxAggregateInputType = {
    id?: true
    broker?: true
    lotNo?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    saleCode?: true
    category?: true
    reprint?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
    producerCountry?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogCountAggregateInputType = {
    id?: true
    broker?: true
    lotNo?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    saleCode?: true
    category?: true
    reprint?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
    producerCountry?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Catalog to aggregate.
     */
    where?: CatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogs to fetch.
     */
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Catalogs
    **/
    _count?: true | CatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogMaxAggregateInputType
  }

  export type GetCatalogAggregateType<T extends CatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalog[P]>
      : GetScalarType<T[P], AggregateCatalog[P]>
  }




  export type CatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogWhereInput
    orderBy?: CatalogOrderByWithAggregationInput | CatalogOrderByWithAggregationInput[]
    by: CatalogScalarFieldEnum[] | CatalogScalarFieldEnum
    having?: CatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogCountAggregateInputType | true
    _avg?: CatalogAvgAggregateInputType
    _sum?: CatalogSumAggregateInputType
    _min?: CatalogMinAggregateInputType
    _max?: CatalogMaxAggregateInputType
  }

  export type CatalogGroupByOutputType = {
    id: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    producerCountry: string | null
    manufactureDate: Date
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CatalogCountAggregateOutputType | null
    _avg: CatalogAvgAggregateOutputType | null
    _sum: CatalogSumAggregateOutputType | null
    _min: CatalogMinAggregateOutputType | null
    _max: CatalogMaxAggregateOutputType | null
  }

  type GetCatalogGroupByPayload<T extends CatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogGroupByOutputType[P]>
        }
      >
    >


  export type CatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broker?: boolean
    lotNo?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    saleCode?: boolean
    category?: boolean
    reprint?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    askingPrice?: boolean
    producerCountry?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | Catalog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["catalog"]>

  export type CatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broker?: boolean
    lotNo?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    saleCode?: boolean
    category?: boolean
    reprint?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    askingPrice?: boolean
    producerCountry?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | Catalog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["catalog"]>

  export type CatalogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broker?: boolean
    lotNo?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    saleCode?: boolean
    category?: boolean
    reprint?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    askingPrice?: boolean
    producerCountry?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | Catalog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["catalog"]>

  export type CatalogSelectScalar = {
    id?: boolean
    broker?: boolean
    lotNo?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    saleCode?: boolean
    category?: boolean
    reprint?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    askingPrice?: boolean
    producerCountry?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CatalogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "broker" | "lotNo" | "sellingMark" | "grade" | "invoiceNo" | "saleCode" | "category" | "reprint" | "bags" | "netWeight" | "totalWeight" | "askingPrice" | "producerCountry" | "manufactureDate" | "adminCognitoId" | "userCognitoId" | "createdAt" | "updatedAt", ExtArgs["result"]["catalog"]>
  export type CatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Catalog$adminArgs<ExtArgs>
  }
  export type CatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Catalog$adminArgs<ExtArgs>
  }
  export type CatalogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Catalog$adminArgs<ExtArgs>
  }

  export type $CatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Catalog"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      broker: $Enums.Broker
      lotNo: string
      sellingMark: string
      grade: $Enums.TeaGrade
      invoiceNo: string
      saleCode: string
      category: $Enums.TeaCategory
      reprint: string
      bags: number
      netWeight: number
      totalWeight: number
      askingPrice: number
      producerCountry: string | null
      manufactureDate: Date
      adminCognitoId: string | null
      userCognitoId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalog"]>
    composites: {}
  }

  type CatalogGetPayload<S extends boolean | null | undefined | CatalogDefaultArgs> = $Result.GetResult<Prisma.$CatalogPayload, S>

  type CatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CatalogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CatalogCountAggregateInputType | true
    }

  export interface CatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Catalog'], meta: { name: 'Catalog' } }
    /**
     * Find zero or one Catalog that matches the filter.
     * @param {CatalogFindUniqueArgs} args - Arguments to find a Catalog
     * @example
     * // Get one Catalog
     * const catalog = await prisma.catalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogFindUniqueArgs>(args: SelectSubset<T, CatalogFindUniqueArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Catalog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CatalogFindUniqueOrThrowArgs} args - Arguments to find a Catalog
     * @example
     * // Get one Catalog
     * const catalog = await prisma.catalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Catalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFindFirstArgs} args - Arguments to find a Catalog
     * @example
     * // Get one Catalog
     * const catalog = await prisma.catalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogFindFirstArgs>(args?: SelectSubset<T, CatalogFindFirstArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Catalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFindFirstOrThrowArgs} args - Arguments to find a Catalog
     * @example
     * // Get one Catalog
     * const catalog = await prisma.catalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Catalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Catalogs
     * const catalogs = await prisma.catalog.findMany()
     * 
     * // Get first 10 Catalogs
     * const catalogs = await prisma.catalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogWithIdOnly = await prisma.catalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogFindManyArgs>(args?: SelectSubset<T, CatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Catalog.
     * @param {CatalogCreateArgs} args - Arguments to create a Catalog.
     * @example
     * // Create one Catalog
     * const Catalog = await prisma.catalog.create({
     *   data: {
     *     // ... data to create a Catalog
     *   }
     * })
     * 
     */
    create<T extends CatalogCreateArgs>(args: SelectSubset<T, CatalogCreateArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Catalogs.
     * @param {CatalogCreateManyArgs} args - Arguments to create many Catalogs.
     * @example
     * // Create many Catalogs
     * const catalog = await prisma.catalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogCreateManyArgs>(args?: SelectSubset<T, CatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Catalogs and returns the data saved in the database.
     * @param {CatalogCreateManyAndReturnArgs} args - Arguments to create many Catalogs.
     * @example
     * // Create many Catalogs
     * const catalog = await prisma.catalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Catalogs and only return the `id`
     * const catalogWithIdOnly = await prisma.catalog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Catalog.
     * @param {CatalogDeleteArgs} args - Arguments to delete one Catalog.
     * @example
     * // Delete one Catalog
     * const Catalog = await prisma.catalog.delete({
     *   where: {
     *     // ... filter to delete one Catalog
     *   }
     * })
     * 
     */
    delete<T extends CatalogDeleteArgs>(args: SelectSubset<T, CatalogDeleteArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Catalog.
     * @param {CatalogUpdateArgs} args - Arguments to update one Catalog.
     * @example
     * // Update one Catalog
     * const catalog = await prisma.catalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogUpdateArgs>(args: SelectSubset<T, CatalogUpdateArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Catalogs.
     * @param {CatalogDeleteManyArgs} args - Arguments to filter Catalogs to delete.
     * @example
     * // Delete a few Catalogs
     * const { count } = await prisma.catalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogDeleteManyArgs>(args?: SelectSubset<T, CatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Catalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Catalogs
     * const catalog = await prisma.catalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogUpdateManyArgs>(args: SelectSubset<T, CatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Catalogs and returns the data updated in the database.
     * @param {CatalogUpdateManyAndReturnArgs} args - Arguments to update many Catalogs.
     * @example
     * // Update many Catalogs
     * const catalog = await prisma.catalog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Catalogs and only return the `id`
     * const catalogWithIdOnly = await prisma.catalog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CatalogUpdateManyAndReturnArgs>(args: SelectSubset<T, CatalogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Catalog.
     * @param {CatalogUpsertArgs} args - Arguments to update or create a Catalog.
     * @example
     * // Update or create a Catalog
     * const catalog = await prisma.catalog.upsert({
     *   create: {
     *     // ... data to create a Catalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Catalog we want to update
     *   }
     * })
     */
    upsert<T extends CatalogUpsertArgs>(args: SelectSubset<T, CatalogUpsertArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Catalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCountArgs} args - Arguments to filter Catalogs to count.
     * @example
     * // Count the number of Catalogs
     * const count = await prisma.catalog.count({
     *   where: {
     *     // ... the filter for the Catalogs we want to count
     *   }
     * })
    **/
    count<T extends CatalogCountArgs>(
      args?: Subset<T, CatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Catalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogAggregateArgs>(args: Subset<T, CatalogAggregateArgs>): Prisma.PrismaPromise<GetCatalogAggregateType<T>>

    /**
     * Group by Catalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogGroupByArgs['orderBy'] }
        : { orderBy?: CatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Catalog model
   */
  readonly fields: CatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Catalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends Catalog$adminArgs<ExtArgs> = {}>(args?: Subset<T, Catalog$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Catalog model
   */
  interface CatalogFieldRefs {
    readonly id: FieldRef<"Catalog", 'Int'>
    readonly broker: FieldRef<"Catalog", 'Broker'>
    readonly lotNo: FieldRef<"Catalog", 'String'>
    readonly sellingMark: FieldRef<"Catalog", 'String'>
    readonly grade: FieldRef<"Catalog", 'TeaGrade'>
    readonly invoiceNo: FieldRef<"Catalog", 'String'>
    readonly saleCode: FieldRef<"Catalog", 'String'>
    readonly category: FieldRef<"Catalog", 'TeaCategory'>
    readonly reprint: FieldRef<"Catalog", 'String'>
    readonly bags: FieldRef<"Catalog", 'Int'>
    readonly netWeight: FieldRef<"Catalog", 'Float'>
    readonly totalWeight: FieldRef<"Catalog", 'Float'>
    readonly askingPrice: FieldRef<"Catalog", 'Float'>
    readonly producerCountry: FieldRef<"Catalog", 'String'>
    readonly manufactureDate: FieldRef<"Catalog", 'DateTime'>
    readonly adminCognitoId: FieldRef<"Catalog", 'String'>
    readonly userCognitoId: FieldRef<"Catalog", 'String'>
    readonly createdAt: FieldRef<"Catalog", 'DateTime'>
    readonly updatedAt: FieldRef<"Catalog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Catalog findUnique
   */
  export type CatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalog to fetch.
     */
    where: CatalogWhereUniqueInput
  }

  /**
   * Catalog findUniqueOrThrow
   */
  export type CatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalog to fetch.
     */
    where: CatalogWhereUniqueInput
  }

  /**
   * Catalog findFirst
   */
  export type CatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalog to fetch.
     */
    where?: CatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogs to fetch.
     */
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Catalogs.
     */
    cursor?: CatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Catalogs.
     */
    distinct?: CatalogScalarFieldEnum | CatalogScalarFieldEnum[]
  }

  /**
   * Catalog findFirstOrThrow
   */
  export type CatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalog to fetch.
     */
    where?: CatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogs to fetch.
     */
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Catalogs.
     */
    cursor?: CatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Catalogs.
     */
    distinct?: CatalogScalarFieldEnum | CatalogScalarFieldEnum[]
  }

  /**
   * Catalog findMany
   */
  export type CatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalogs to fetch.
     */
    where?: CatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogs to fetch.
     */
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Catalogs.
     */
    cursor?: CatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogs.
     */
    skip?: number
    distinct?: CatalogScalarFieldEnum | CatalogScalarFieldEnum[]
  }

  /**
   * Catalog create
   */
  export type CatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a Catalog.
     */
    data: XOR<CatalogCreateInput, CatalogUncheckedCreateInput>
  }

  /**
   * Catalog createMany
   */
  export type CatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Catalogs.
     */
    data: CatalogCreateManyInput | CatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Catalog createManyAndReturn
   */
  export type CatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * The data used to create many Catalogs.
     */
    data: CatalogCreateManyInput | CatalogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Catalog update
   */
  export type CatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a Catalog.
     */
    data: XOR<CatalogUpdateInput, CatalogUncheckedUpdateInput>
    /**
     * Choose, which Catalog to update.
     */
    where: CatalogWhereUniqueInput
  }

  /**
   * Catalog updateMany
   */
  export type CatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Catalogs.
     */
    data: XOR<CatalogUpdateManyMutationInput, CatalogUncheckedUpdateManyInput>
    /**
     * Filter which Catalogs to update
     */
    where?: CatalogWhereInput
    /**
     * Limit how many Catalogs to update.
     */
    limit?: number
  }

  /**
   * Catalog updateManyAndReturn
   */
  export type CatalogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * The data used to update Catalogs.
     */
    data: XOR<CatalogUpdateManyMutationInput, CatalogUncheckedUpdateManyInput>
    /**
     * Filter which Catalogs to update
     */
    where?: CatalogWhereInput
    /**
     * Limit how many Catalogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Catalog upsert
   */
  export type CatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the Catalog to update in case it exists.
     */
    where: CatalogWhereUniqueInput
    /**
     * In case the Catalog found by the `where` argument doesn't exist, create a new Catalog with this data.
     */
    create: XOR<CatalogCreateInput, CatalogUncheckedCreateInput>
    /**
     * In case the Catalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogUpdateInput, CatalogUncheckedUpdateInput>
  }

  /**
   * Catalog delete
   */
  export type CatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter which Catalog to delete.
     */
    where: CatalogWhereUniqueInput
  }

  /**
   * Catalog deleteMany
   */
  export type CatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Catalogs to delete
     */
    where?: CatalogWhereInput
    /**
     * Limit how many Catalogs to delete.
     */
    limit?: number
  }

  /**
   * Catalog.admin
   */
  export type Catalog$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Catalog without action
   */
  export type CatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
  }


  /**
   * Model SellingPrice
   */

  export type AggregateSellingPrice = {
    _count: SellingPriceCountAggregateOutputType | null
    _avg: SellingPriceAvgAggregateOutputType | null
    _sum: SellingPriceSumAggregateOutputType | null
    _min: SellingPriceMinAggregateOutputType | null
    _max: SellingPriceMaxAggregateOutputType | null
  }

  export type SellingPriceAvgAggregateOutputType = {
    id: number | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    askingPrice: number | null
    purchasePrice: number | null
  }

  export type SellingPriceSumAggregateOutputType = {
    id: number | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    askingPrice: number | null
    purchasePrice: number | null
  }

  export type SellingPriceMinAggregateOutputType = {
    id: number | null
    broker: $Enums.Broker | null
    lotNo: string | null
    sellingMark: string | null
    grade: $Enums.TeaGrade | null
    invoiceNo: string | null
    saleCode: string | null
    category: $Enums.TeaCategory | null
    reprint: string | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    askingPrice: number | null
    purchasePrice: number | null
    producerCountry: string | null
    manufactureDate: Date | null
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellingPriceMaxAggregateOutputType = {
    id: number | null
    broker: $Enums.Broker | null
    lotNo: string | null
    sellingMark: string | null
    grade: $Enums.TeaGrade | null
    invoiceNo: string | null
    saleCode: string | null
    category: $Enums.TeaCategory | null
    reprint: string | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    askingPrice: number | null
    purchasePrice: number | null
    producerCountry: string | null
    manufactureDate: Date | null
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellingPriceCountAggregateOutputType = {
    id: number
    broker: number
    lotNo: number
    sellingMark: number
    grade: number
    invoiceNo: number
    saleCode: number
    category: number
    reprint: number
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    purchasePrice: number
    producerCountry: number
    manufactureDate: number
    adminCognitoId: number
    userCognitoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellingPriceAvgAggregateInputType = {
    id?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
    purchasePrice?: true
  }

  export type SellingPriceSumAggregateInputType = {
    id?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
    purchasePrice?: true
  }

  export type SellingPriceMinAggregateInputType = {
    id?: true
    broker?: true
    lotNo?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    saleCode?: true
    category?: true
    reprint?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
    purchasePrice?: true
    producerCountry?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellingPriceMaxAggregateInputType = {
    id?: true
    broker?: true
    lotNo?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    saleCode?: true
    category?: true
    reprint?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
    purchasePrice?: true
    producerCountry?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellingPriceCountAggregateInputType = {
    id?: true
    broker?: true
    lotNo?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    saleCode?: true
    category?: true
    reprint?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    askingPrice?: true
    purchasePrice?: true
    producerCountry?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellingPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingPrice to aggregate.
     */
    where?: SellingPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingPrices to fetch.
     */
    orderBy?: SellingPriceOrderByWithRelationInput | SellingPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellingPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellingPrices
    **/
    _count?: true | SellingPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellingPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellingPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellingPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellingPriceMaxAggregateInputType
  }

  export type GetSellingPriceAggregateType<T extends SellingPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateSellingPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellingPrice[P]>
      : GetScalarType<T[P], AggregateSellingPrice[P]>
  }




  export type SellingPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingPriceWhereInput
    orderBy?: SellingPriceOrderByWithAggregationInput | SellingPriceOrderByWithAggregationInput[]
    by: SellingPriceScalarFieldEnum[] | SellingPriceScalarFieldEnum
    having?: SellingPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellingPriceCountAggregateInputType | true
    _avg?: SellingPriceAvgAggregateInputType
    _sum?: SellingPriceSumAggregateInputType
    _min?: SellingPriceMinAggregateInputType
    _max?: SellingPriceMaxAggregateInputType
  }

  export type SellingPriceGroupByOutputType = {
    id: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    purchasePrice: number
    producerCountry: string | null
    manufactureDate: Date
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SellingPriceCountAggregateOutputType | null
    _avg: SellingPriceAvgAggregateOutputType | null
    _sum: SellingPriceSumAggregateOutputType | null
    _min: SellingPriceMinAggregateOutputType | null
    _max: SellingPriceMaxAggregateOutputType | null
  }

  type GetSellingPriceGroupByPayload<T extends SellingPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellingPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellingPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellingPriceGroupByOutputType[P]>
            : GetScalarType<T[P], SellingPriceGroupByOutputType[P]>
        }
      >
    >


  export type SellingPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broker?: boolean
    lotNo?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    saleCode?: boolean
    category?: boolean
    reprint?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    askingPrice?: boolean
    purchasePrice?: boolean
    producerCountry?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | SellingPrice$adminArgs<ExtArgs>
  }, ExtArgs["result"]["sellingPrice"]>

  export type SellingPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broker?: boolean
    lotNo?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    saleCode?: boolean
    category?: boolean
    reprint?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    askingPrice?: boolean
    purchasePrice?: boolean
    producerCountry?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | SellingPrice$adminArgs<ExtArgs>
  }, ExtArgs["result"]["sellingPrice"]>

  export type SellingPriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broker?: boolean
    lotNo?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    saleCode?: boolean
    category?: boolean
    reprint?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    askingPrice?: boolean
    purchasePrice?: boolean
    producerCountry?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | SellingPrice$adminArgs<ExtArgs>
  }, ExtArgs["result"]["sellingPrice"]>

  export type SellingPriceSelectScalar = {
    id?: boolean
    broker?: boolean
    lotNo?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    saleCode?: boolean
    category?: boolean
    reprint?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    askingPrice?: boolean
    purchasePrice?: boolean
    producerCountry?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellingPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "broker" | "lotNo" | "sellingMark" | "grade" | "invoiceNo" | "saleCode" | "category" | "reprint" | "bags" | "netWeight" | "totalWeight" | "askingPrice" | "purchasePrice" | "producerCountry" | "manufactureDate" | "adminCognitoId" | "userCognitoId" | "createdAt" | "updatedAt", ExtArgs["result"]["sellingPrice"]>
  export type SellingPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | SellingPrice$adminArgs<ExtArgs>
  }
  export type SellingPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | SellingPrice$adminArgs<ExtArgs>
  }
  export type SellingPriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | SellingPrice$adminArgs<ExtArgs>
  }

  export type $SellingPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellingPrice"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      broker: $Enums.Broker
      lotNo: string
      sellingMark: string
      grade: $Enums.TeaGrade
      invoiceNo: string
      saleCode: string
      category: $Enums.TeaCategory
      reprint: string
      bags: number
      netWeight: number
      totalWeight: number
      askingPrice: number
      purchasePrice: number
      producerCountry: string | null
      manufactureDate: Date
      adminCognitoId: string | null
      userCognitoId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellingPrice"]>
    composites: {}
  }

  type SellingPriceGetPayload<S extends boolean | null | undefined | SellingPriceDefaultArgs> = $Result.GetResult<Prisma.$SellingPricePayload, S>

  type SellingPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellingPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellingPriceCountAggregateInputType | true
    }

  export interface SellingPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellingPrice'], meta: { name: 'SellingPrice' } }
    /**
     * Find zero or one SellingPrice that matches the filter.
     * @param {SellingPriceFindUniqueArgs} args - Arguments to find a SellingPrice
     * @example
     * // Get one SellingPrice
     * const sellingPrice = await prisma.sellingPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellingPriceFindUniqueArgs>(args: SelectSubset<T, SellingPriceFindUniqueArgs<ExtArgs>>): Prisma__SellingPriceClient<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellingPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellingPriceFindUniqueOrThrowArgs} args - Arguments to find a SellingPrice
     * @example
     * // Get one SellingPrice
     * const sellingPrice = await prisma.sellingPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellingPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, SellingPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellingPriceClient<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellingPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPriceFindFirstArgs} args - Arguments to find a SellingPrice
     * @example
     * // Get one SellingPrice
     * const sellingPrice = await prisma.sellingPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellingPriceFindFirstArgs>(args?: SelectSubset<T, SellingPriceFindFirstArgs<ExtArgs>>): Prisma__SellingPriceClient<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellingPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPriceFindFirstOrThrowArgs} args - Arguments to find a SellingPrice
     * @example
     * // Get one SellingPrice
     * const sellingPrice = await prisma.sellingPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellingPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, SellingPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellingPriceClient<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellingPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellingPrices
     * const sellingPrices = await prisma.sellingPrice.findMany()
     * 
     * // Get first 10 SellingPrices
     * const sellingPrices = await prisma.sellingPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellingPriceWithIdOnly = await prisma.sellingPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellingPriceFindManyArgs>(args?: SelectSubset<T, SellingPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellingPrice.
     * @param {SellingPriceCreateArgs} args - Arguments to create a SellingPrice.
     * @example
     * // Create one SellingPrice
     * const SellingPrice = await prisma.sellingPrice.create({
     *   data: {
     *     // ... data to create a SellingPrice
     *   }
     * })
     * 
     */
    create<T extends SellingPriceCreateArgs>(args: SelectSubset<T, SellingPriceCreateArgs<ExtArgs>>): Prisma__SellingPriceClient<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellingPrices.
     * @param {SellingPriceCreateManyArgs} args - Arguments to create many SellingPrices.
     * @example
     * // Create many SellingPrices
     * const sellingPrice = await prisma.sellingPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellingPriceCreateManyArgs>(args?: SelectSubset<T, SellingPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellingPrices and returns the data saved in the database.
     * @param {SellingPriceCreateManyAndReturnArgs} args - Arguments to create many SellingPrices.
     * @example
     * // Create many SellingPrices
     * const sellingPrice = await prisma.sellingPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellingPrices and only return the `id`
     * const sellingPriceWithIdOnly = await prisma.sellingPrice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellingPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, SellingPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellingPrice.
     * @param {SellingPriceDeleteArgs} args - Arguments to delete one SellingPrice.
     * @example
     * // Delete one SellingPrice
     * const SellingPrice = await prisma.sellingPrice.delete({
     *   where: {
     *     // ... filter to delete one SellingPrice
     *   }
     * })
     * 
     */
    delete<T extends SellingPriceDeleteArgs>(args: SelectSubset<T, SellingPriceDeleteArgs<ExtArgs>>): Prisma__SellingPriceClient<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellingPrice.
     * @param {SellingPriceUpdateArgs} args - Arguments to update one SellingPrice.
     * @example
     * // Update one SellingPrice
     * const sellingPrice = await prisma.sellingPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellingPriceUpdateArgs>(args: SelectSubset<T, SellingPriceUpdateArgs<ExtArgs>>): Prisma__SellingPriceClient<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellingPrices.
     * @param {SellingPriceDeleteManyArgs} args - Arguments to filter SellingPrices to delete.
     * @example
     * // Delete a few SellingPrices
     * const { count } = await prisma.sellingPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellingPriceDeleteManyArgs>(args?: SelectSubset<T, SellingPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellingPrices
     * const sellingPrice = await prisma.sellingPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellingPriceUpdateManyArgs>(args: SelectSubset<T, SellingPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingPrices and returns the data updated in the database.
     * @param {SellingPriceUpdateManyAndReturnArgs} args - Arguments to update many SellingPrices.
     * @example
     * // Update many SellingPrices
     * const sellingPrice = await prisma.sellingPrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellingPrices and only return the `id`
     * const sellingPriceWithIdOnly = await prisma.sellingPrice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellingPriceUpdateManyAndReturnArgs>(args: SelectSubset<T, SellingPriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellingPrice.
     * @param {SellingPriceUpsertArgs} args - Arguments to update or create a SellingPrice.
     * @example
     * // Update or create a SellingPrice
     * const sellingPrice = await prisma.sellingPrice.upsert({
     *   create: {
     *     // ... data to create a SellingPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellingPrice we want to update
     *   }
     * })
     */
    upsert<T extends SellingPriceUpsertArgs>(args: SelectSubset<T, SellingPriceUpsertArgs<ExtArgs>>): Prisma__SellingPriceClient<$Result.GetResult<Prisma.$SellingPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellingPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPriceCountArgs} args - Arguments to filter SellingPrices to count.
     * @example
     * // Count the number of SellingPrices
     * const count = await prisma.sellingPrice.count({
     *   where: {
     *     // ... the filter for the SellingPrices we want to count
     *   }
     * })
    **/
    count<T extends SellingPriceCountArgs>(
      args?: Subset<T, SellingPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellingPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellingPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellingPriceAggregateArgs>(args: Subset<T, SellingPriceAggregateArgs>): Prisma.PrismaPromise<GetSellingPriceAggregateType<T>>

    /**
     * Group by SellingPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellingPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellingPriceGroupByArgs['orderBy'] }
        : { orderBy?: SellingPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellingPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellingPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellingPrice model
   */
  readonly fields: SellingPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellingPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellingPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends SellingPrice$adminArgs<ExtArgs> = {}>(args?: Subset<T, SellingPrice$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellingPrice model
   */
  interface SellingPriceFieldRefs {
    readonly id: FieldRef<"SellingPrice", 'Int'>
    readonly broker: FieldRef<"SellingPrice", 'Broker'>
    readonly lotNo: FieldRef<"SellingPrice", 'String'>
    readonly sellingMark: FieldRef<"SellingPrice", 'String'>
    readonly grade: FieldRef<"SellingPrice", 'TeaGrade'>
    readonly invoiceNo: FieldRef<"SellingPrice", 'String'>
    readonly saleCode: FieldRef<"SellingPrice", 'String'>
    readonly category: FieldRef<"SellingPrice", 'TeaCategory'>
    readonly reprint: FieldRef<"SellingPrice", 'String'>
    readonly bags: FieldRef<"SellingPrice", 'Int'>
    readonly netWeight: FieldRef<"SellingPrice", 'Float'>
    readonly totalWeight: FieldRef<"SellingPrice", 'Float'>
    readonly askingPrice: FieldRef<"SellingPrice", 'Float'>
    readonly purchasePrice: FieldRef<"SellingPrice", 'Float'>
    readonly producerCountry: FieldRef<"SellingPrice", 'String'>
    readonly manufactureDate: FieldRef<"SellingPrice", 'DateTime'>
    readonly adminCognitoId: FieldRef<"SellingPrice", 'String'>
    readonly userCognitoId: FieldRef<"SellingPrice", 'String'>
    readonly createdAt: FieldRef<"SellingPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"SellingPrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellingPrice findUnique
   */
  export type SellingPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * Filter, which SellingPrice to fetch.
     */
    where: SellingPriceWhereUniqueInput
  }

  /**
   * SellingPrice findUniqueOrThrow
   */
  export type SellingPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * Filter, which SellingPrice to fetch.
     */
    where: SellingPriceWhereUniqueInput
  }

  /**
   * SellingPrice findFirst
   */
  export type SellingPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * Filter, which SellingPrice to fetch.
     */
    where?: SellingPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingPrices to fetch.
     */
    orderBy?: SellingPriceOrderByWithRelationInput | SellingPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingPrices.
     */
    cursor?: SellingPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingPrices.
     */
    distinct?: SellingPriceScalarFieldEnum | SellingPriceScalarFieldEnum[]
  }

  /**
   * SellingPrice findFirstOrThrow
   */
  export type SellingPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * Filter, which SellingPrice to fetch.
     */
    where?: SellingPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingPrices to fetch.
     */
    orderBy?: SellingPriceOrderByWithRelationInput | SellingPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingPrices.
     */
    cursor?: SellingPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingPrices.
     */
    distinct?: SellingPriceScalarFieldEnum | SellingPriceScalarFieldEnum[]
  }

  /**
   * SellingPrice findMany
   */
  export type SellingPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * Filter, which SellingPrices to fetch.
     */
    where?: SellingPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingPrices to fetch.
     */
    orderBy?: SellingPriceOrderByWithRelationInput | SellingPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellingPrices.
     */
    cursor?: SellingPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingPrices.
     */
    skip?: number
    distinct?: SellingPriceScalarFieldEnum | SellingPriceScalarFieldEnum[]
  }

  /**
   * SellingPrice create
   */
  export type SellingPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a SellingPrice.
     */
    data: XOR<SellingPriceCreateInput, SellingPriceUncheckedCreateInput>
  }

  /**
   * SellingPrice createMany
   */
  export type SellingPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellingPrices.
     */
    data: SellingPriceCreateManyInput | SellingPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellingPrice createManyAndReturn
   */
  export type SellingPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * The data used to create many SellingPrices.
     */
    data: SellingPriceCreateManyInput | SellingPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellingPrice update
   */
  export type SellingPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a SellingPrice.
     */
    data: XOR<SellingPriceUpdateInput, SellingPriceUncheckedUpdateInput>
    /**
     * Choose, which SellingPrice to update.
     */
    where: SellingPriceWhereUniqueInput
  }

  /**
   * SellingPrice updateMany
   */
  export type SellingPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellingPrices.
     */
    data: XOR<SellingPriceUpdateManyMutationInput, SellingPriceUncheckedUpdateManyInput>
    /**
     * Filter which SellingPrices to update
     */
    where?: SellingPriceWhereInput
    /**
     * Limit how many SellingPrices to update.
     */
    limit?: number
  }

  /**
   * SellingPrice updateManyAndReturn
   */
  export type SellingPriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * The data used to update SellingPrices.
     */
    data: XOR<SellingPriceUpdateManyMutationInput, SellingPriceUncheckedUpdateManyInput>
    /**
     * Filter which SellingPrices to update
     */
    where?: SellingPriceWhereInput
    /**
     * Limit how many SellingPrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellingPrice upsert
   */
  export type SellingPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the SellingPrice to update in case it exists.
     */
    where: SellingPriceWhereUniqueInput
    /**
     * In case the SellingPrice found by the `where` argument doesn't exist, create a new SellingPrice with this data.
     */
    create: XOR<SellingPriceCreateInput, SellingPriceUncheckedCreateInput>
    /**
     * In case the SellingPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellingPriceUpdateInput, SellingPriceUncheckedUpdateInput>
  }

  /**
   * SellingPrice delete
   */
  export type SellingPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
    /**
     * Filter which SellingPrice to delete.
     */
    where: SellingPriceWhereUniqueInput
  }

  /**
   * SellingPrice deleteMany
   */
  export type SellingPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingPrices to delete
     */
    where?: SellingPriceWhereInput
    /**
     * Limit how many SellingPrices to delete.
     */
    limit?: number
  }

  /**
   * SellingPrice.admin
   */
  export type SellingPrice$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * SellingPrice without action
   */
  export type SellingPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPrice
     */
    select?: SellingPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingPrice
     */
    omit?: SellingPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingPriceInclude<ExtArgs> | null
  }


  /**
   * Model OutLots
   */

  export type AggregateOutLots = {
    _count: OutLotsCountAggregateOutputType | null
    _avg: OutLotsAvgAggregateOutputType | null
    _sum: OutLotsSumAggregateOutputType | null
    _min: OutLotsMinAggregateOutputType | null
    _max: OutLotsMaxAggregateOutputType | null
  }

  export type OutLotsAvgAggregateOutputType = {
    id: number | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    baselinePrice: number | null
  }

  export type OutLotsSumAggregateOutputType = {
    id: number | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    baselinePrice: number | null
  }

  export type OutLotsMinAggregateOutputType = {
    id: number | null
    auction: string | null
    lotNo: string | null
    broker: $Enums.Broker | null
    sellingMark: string | null
    grade: $Enums.TeaGrade | null
    invoiceNo: string | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    baselinePrice: number | null
    manufactureDate: Date | null
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutLotsMaxAggregateOutputType = {
    id: number | null
    auction: string | null
    lotNo: string | null
    broker: $Enums.Broker | null
    sellingMark: string | null
    grade: $Enums.TeaGrade | null
    invoiceNo: string | null
    bags: number | null
    netWeight: number | null
    totalWeight: number | null
    baselinePrice: number | null
    manufactureDate: Date | null
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutLotsCountAggregateOutputType = {
    id: number
    auction: number
    lotNo: number
    broker: number
    sellingMark: number
    grade: number
    invoiceNo: number
    bags: number
    netWeight: number
    totalWeight: number
    baselinePrice: number
    manufactureDate: number
    adminCognitoId: number
    userCognitoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutLotsAvgAggregateInputType = {
    id?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    baselinePrice?: true
  }

  export type OutLotsSumAggregateInputType = {
    id?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    baselinePrice?: true
  }

  export type OutLotsMinAggregateInputType = {
    id?: true
    auction?: true
    lotNo?: true
    broker?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    baselinePrice?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutLotsMaxAggregateInputType = {
    id?: true
    auction?: true
    lotNo?: true
    broker?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    baselinePrice?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutLotsCountAggregateInputType = {
    id?: true
    auction?: true
    lotNo?: true
    broker?: true
    sellingMark?: true
    grade?: true
    invoiceNo?: true
    bags?: true
    netWeight?: true
    totalWeight?: true
    baselinePrice?: true
    manufactureDate?: true
    adminCognitoId?: true
    userCognitoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutLotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutLots to aggregate.
     */
    where?: OutLotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutLots to fetch.
     */
    orderBy?: OutLotsOrderByWithRelationInput | OutLotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutLotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutLots
    **/
    _count?: true | OutLotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutLotsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutLotsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutLotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutLotsMaxAggregateInputType
  }

  export type GetOutLotsAggregateType<T extends OutLotsAggregateArgs> = {
        [P in keyof T & keyof AggregateOutLots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutLots[P]>
      : GetScalarType<T[P], AggregateOutLots[P]>
  }




  export type OutLotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutLotsWhereInput
    orderBy?: OutLotsOrderByWithAggregationInput | OutLotsOrderByWithAggregationInput[]
    by: OutLotsScalarFieldEnum[] | OutLotsScalarFieldEnum
    having?: OutLotsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutLotsCountAggregateInputType | true
    _avg?: OutLotsAvgAggregateInputType
    _sum?: OutLotsSumAggregateInputType
    _min?: OutLotsMinAggregateInputType
    _max?: OutLotsMaxAggregateInputType
  }

  export type OutLotsGroupByOutputType = {
    id: number
    auction: string
    lotNo: string
    broker: $Enums.Broker
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    netWeight: number
    totalWeight: number
    baselinePrice: number
    manufactureDate: Date
    adminCognitoId: string | null
    userCognitoId: string | null
    createdAt: Date
    updatedAt: Date
    _count: OutLotsCountAggregateOutputType | null
    _avg: OutLotsAvgAggregateOutputType | null
    _sum: OutLotsSumAggregateOutputType | null
    _min: OutLotsMinAggregateOutputType | null
    _max: OutLotsMaxAggregateOutputType | null
  }

  type GetOutLotsGroupByPayload<T extends OutLotsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutLotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutLotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutLotsGroupByOutputType[P]>
            : GetScalarType<T[P], OutLotsGroupByOutputType[P]>
        }
      >
    >


  export type OutLotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auction?: boolean
    lotNo?: boolean
    broker?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    baselinePrice?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | OutLots$adminArgs<ExtArgs>
  }, ExtArgs["result"]["outLots"]>

  export type OutLotsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auction?: boolean
    lotNo?: boolean
    broker?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    baselinePrice?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | OutLots$adminArgs<ExtArgs>
  }, ExtArgs["result"]["outLots"]>

  export type OutLotsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auction?: boolean
    lotNo?: boolean
    broker?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    baselinePrice?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | OutLots$adminArgs<ExtArgs>
  }, ExtArgs["result"]["outLots"]>

  export type OutLotsSelectScalar = {
    id?: boolean
    auction?: boolean
    lotNo?: boolean
    broker?: boolean
    sellingMark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    bags?: boolean
    netWeight?: boolean
    totalWeight?: boolean
    baselinePrice?: boolean
    manufactureDate?: boolean
    adminCognitoId?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutLotsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auction" | "lotNo" | "broker" | "sellingMark" | "grade" | "invoiceNo" | "bags" | "netWeight" | "totalWeight" | "baselinePrice" | "manufactureDate" | "adminCognitoId" | "userCognitoId" | "createdAt" | "updatedAt", ExtArgs["result"]["outLots"]>
  export type OutLotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | OutLots$adminArgs<ExtArgs>
  }
  export type OutLotsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | OutLots$adminArgs<ExtArgs>
  }
  export type OutLotsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | OutLots$adminArgs<ExtArgs>
  }

  export type $OutLotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutLots"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      auction: string
      lotNo: string
      broker: $Enums.Broker
      sellingMark: string
      grade: $Enums.TeaGrade
      invoiceNo: string
      bags: number
      netWeight: number
      totalWeight: number
      baselinePrice: number
      manufactureDate: Date
      adminCognitoId: string | null
      userCognitoId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outLots"]>
    composites: {}
  }

  type OutLotsGetPayload<S extends boolean | null | undefined | OutLotsDefaultArgs> = $Result.GetResult<Prisma.$OutLotsPayload, S>

  type OutLotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutLotsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutLotsCountAggregateInputType | true
    }

  export interface OutLotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutLots'], meta: { name: 'OutLots' } }
    /**
     * Find zero or one OutLots that matches the filter.
     * @param {OutLotsFindUniqueArgs} args - Arguments to find a OutLots
     * @example
     * // Get one OutLots
     * const outLots = await prisma.outLots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutLotsFindUniqueArgs>(args: SelectSubset<T, OutLotsFindUniqueArgs<ExtArgs>>): Prisma__OutLotsClient<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutLots that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutLotsFindUniqueOrThrowArgs} args - Arguments to find a OutLots
     * @example
     * // Get one OutLots
     * const outLots = await prisma.outLots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutLotsFindUniqueOrThrowArgs>(args: SelectSubset<T, OutLotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutLotsClient<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutLots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutLotsFindFirstArgs} args - Arguments to find a OutLots
     * @example
     * // Get one OutLots
     * const outLots = await prisma.outLots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutLotsFindFirstArgs>(args?: SelectSubset<T, OutLotsFindFirstArgs<ExtArgs>>): Prisma__OutLotsClient<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutLots that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutLotsFindFirstOrThrowArgs} args - Arguments to find a OutLots
     * @example
     * // Get one OutLots
     * const outLots = await prisma.outLots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutLotsFindFirstOrThrowArgs>(args?: SelectSubset<T, OutLotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutLotsClient<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutLots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutLotsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutLots
     * const outLots = await prisma.outLots.findMany()
     * 
     * // Get first 10 OutLots
     * const outLots = await prisma.outLots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outLotsWithIdOnly = await prisma.outLots.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutLotsFindManyArgs>(args?: SelectSubset<T, OutLotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutLots.
     * @param {OutLotsCreateArgs} args - Arguments to create a OutLots.
     * @example
     * // Create one OutLots
     * const OutLots = await prisma.outLots.create({
     *   data: {
     *     // ... data to create a OutLots
     *   }
     * })
     * 
     */
    create<T extends OutLotsCreateArgs>(args: SelectSubset<T, OutLotsCreateArgs<ExtArgs>>): Prisma__OutLotsClient<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutLots.
     * @param {OutLotsCreateManyArgs} args - Arguments to create many OutLots.
     * @example
     * // Create many OutLots
     * const outLots = await prisma.outLots.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutLotsCreateManyArgs>(args?: SelectSubset<T, OutLotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutLots and returns the data saved in the database.
     * @param {OutLotsCreateManyAndReturnArgs} args - Arguments to create many OutLots.
     * @example
     * // Create many OutLots
     * const outLots = await prisma.outLots.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutLots and only return the `id`
     * const outLotsWithIdOnly = await prisma.outLots.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutLotsCreateManyAndReturnArgs>(args?: SelectSubset<T, OutLotsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OutLots.
     * @param {OutLotsDeleteArgs} args - Arguments to delete one OutLots.
     * @example
     * // Delete one OutLots
     * const OutLots = await prisma.outLots.delete({
     *   where: {
     *     // ... filter to delete one OutLots
     *   }
     * })
     * 
     */
    delete<T extends OutLotsDeleteArgs>(args: SelectSubset<T, OutLotsDeleteArgs<ExtArgs>>): Prisma__OutLotsClient<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutLots.
     * @param {OutLotsUpdateArgs} args - Arguments to update one OutLots.
     * @example
     * // Update one OutLots
     * const outLots = await prisma.outLots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutLotsUpdateArgs>(args: SelectSubset<T, OutLotsUpdateArgs<ExtArgs>>): Prisma__OutLotsClient<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutLots.
     * @param {OutLotsDeleteManyArgs} args - Arguments to filter OutLots to delete.
     * @example
     * // Delete a few OutLots
     * const { count } = await prisma.outLots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutLotsDeleteManyArgs>(args?: SelectSubset<T, OutLotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutLotsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutLots
     * const outLots = await prisma.outLots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutLotsUpdateManyArgs>(args: SelectSubset<T, OutLotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutLots and returns the data updated in the database.
     * @param {OutLotsUpdateManyAndReturnArgs} args - Arguments to update many OutLots.
     * @example
     * // Update many OutLots
     * const outLots = await prisma.outLots.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutLots and only return the `id`
     * const outLotsWithIdOnly = await prisma.outLots.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutLotsUpdateManyAndReturnArgs>(args: SelectSubset<T, OutLotsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OutLots.
     * @param {OutLotsUpsertArgs} args - Arguments to update or create a OutLots.
     * @example
     * // Update or create a OutLots
     * const outLots = await prisma.outLots.upsert({
     *   create: {
     *     // ... data to create a OutLots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutLots we want to update
     *   }
     * })
     */
    upsert<T extends OutLotsUpsertArgs>(args: SelectSubset<T, OutLotsUpsertArgs<ExtArgs>>): Prisma__OutLotsClient<$Result.GetResult<Prisma.$OutLotsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OutLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutLotsCountArgs} args - Arguments to filter OutLots to count.
     * @example
     * // Count the number of OutLots
     * const count = await prisma.outLots.count({
     *   where: {
     *     // ... the filter for the OutLots we want to count
     *   }
     * })
    **/
    count<T extends OutLotsCountArgs>(
      args?: Subset<T, OutLotsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutLotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutLotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutLotsAggregateArgs>(args: Subset<T, OutLotsAggregateArgs>): Prisma.PrismaPromise<GetOutLotsAggregateType<T>>

    /**
     * Group by OutLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutLotsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutLotsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutLotsGroupByArgs['orderBy'] }
        : { orderBy?: OutLotsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutLotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutLotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutLots model
   */
  readonly fields: OutLotsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutLots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutLotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends OutLots$adminArgs<ExtArgs> = {}>(args?: Subset<T, OutLots$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutLots model
   */
  interface OutLotsFieldRefs {
    readonly id: FieldRef<"OutLots", 'Int'>
    readonly auction: FieldRef<"OutLots", 'String'>
    readonly lotNo: FieldRef<"OutLots", 'String'>
    readonly broker: FieldRef<"OutLots", 'Broker'>
    readonly sellingMark: FieldRef<"OutLots", 'String'>
    readonly grade: FieldRef<"OutLots", 'TeaGrade'>
    readonly invoiceNo: FieldRef<"OutLots", 'String'>
    readonly bags: FieldRef<"OutLots", 'Int'>
    readonly netWeight: FieldRef<"OutLots", 'Float'>
    readonly totalWeight: FieldRef<"OutLots", 'Float'>
    readonly baselinePrice: FieldRef<"OutLots", 'Float'>
    readonly manufactureDate: FieldRef<"OutLots", 'DateTime'>
    readonly adminCognitoId: FieldRef<"OutLots", 'String'>
    readonly userCognitoId: FieldRef<"OutLots", 'String'>
    readonly createdAt: FieldRef<"OutLots", 'DateTime'>
    readonly updatedAt: FieldRef<"OutLots", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutLots findUnique
   */
  export type OutLotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * Filter, which OutLots to fetch.
     */
    where: OutLotsWhereUniqueInput
  }

  /**
   * OutLots findUniqueOrThrow
   */
  export type OutLotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * Filter, which OutLots to fetch.
     */
    where: OutLotsWhereUniqueInput
  }

  /**
   * OutLots findFirst
   */
  export type OutLotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * Filter, which OutLots to fetch.
     */
    where?: OutLotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutLots to fetch.
     */
    orderBy?: OutLotsOrderByWithRelationInput | OutLotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutLots.
     */
    cursor?: OutLotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutLots.
     */
    distinct?: OutLotsScalarFieldEnum | OutLotsScalarFieldEnum[]
  }

  /**
   * OutLots findFirstOrThrow
   */
  export type OutLotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * Filter, which OutLots to fetch.
     */
    where?: OutLotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutLots to fetch.
     */
    orderBy?: OutLotsOrderByWithRelationInput | OutLotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutLots.
     */
    cursor?: OutLotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutLots.
     */
    distinct?: OutLotsScalarFieldEnum | OutLotsScalarFieldEnum[]
  }

  /**
   * OutLots findMany
   */
  export type OutLotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * Filter, which OutLots to fetch.
     */
    where?: OutLotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutLots to fetch.
     */
    orderBy?: OutLotsOrderByWithRelationInput | OutLotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutLots.
     */
    cursor?: OutLotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutLots.
     */
    skip?: number
    distinct?: OutLotsScalarFieldEnum | OutLotsScalarFieldEnum[]
  }

  /**
   * OutLots create
   */
  export type OutLotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * The data needed to create a OutLots.
     */
    data: XOR<OutLotsCreateInput, OutLotsUncheckedCreateInput>
  }

  /**
   * OutLots createMany
   */
  export type OutLotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutLots.
     */
    data: OutLotsCreateManyInput | OutLotsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutLots createManyAndReturn
   */
  export type OutLotsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * The data used to create many OutLots.
     */
    data: OutLotsCreateManyInput | OutLotsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutLots update
   */
  export type OutLotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * The data needed to update a OutLots.
     */
    data: XOR<OutLotsUpdateInput, OutLotsUncheckedUpdateInput>
    /**
     * Choose, which OutLots to update.
     */
    where: OutLotsWhereUniqueInput
  }

  /**
   * OutLots updateMany
   */
  export type OutLotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutLots.
     */
    data: XOR<OutLotsUpdateManyMutationInput, OutLotsUncheckedUpdateManyInput>
    /**
     * Filter which OutLots to update
     */
    where?: OutLotsWhereInput
    /**
     * Limit how many OutLots to update.
     */
    limit?: number
  }

  /**
   * OutLots updateManyAndReturn
   */
  export type OutLotsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * The data used to update OutLots.
     */
    data: XOR<OutLotsUpdateManyMutationInput, OutLotsUncheckedUpdateManyInput>
    /**
     * Filter which OutLots to update
     */
    where?: OutLotsWhereInput
    /**
     * Limit how many OutLots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutLots upsert
   */
  export type OutLotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * The filter to search for the OutLots to update in case it exists.
     */
    where: OutLotsWhereUniqueInput
    /**
     * In case the OutLots found by the `where` argument doesn't exist, create a new OutLots with this data.
     */
    create: XOR<OutLotsCreateInput, OutLotsUncheckedCreateInput>
    /**
     * In case the OutLots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutLotsUpdateInput, OutLotsUncheckedUpdateInput>
  }

  /**
   * OutLots delete
   */
  export type OutLotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
    /**
     * Filter which OutLots to delete.
     */
    where: OutLotsWhereUniqueInput
  }

  /**
   * OutLots deleteMany
   */
  export type OutLotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutLots to delete
     */
    where?: OutLotsWhereInput
    /**
     * Limit how many OutLots to delete.
     */
    limit?: number
  }

  /**
   * OutLots.admin
   */
  export type OutLots$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * OutLots without action
   */
  export type OutLotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutLots
     */
    select?: OutLotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutLots
     */
    omit?: OutLotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutLotsInclude<ExtArgs> | null
  }


  /**
   * Model Stocks
   */

  export type AggregateStocks = {
    _count: StocksCountAggregateOutputType | null
    _avg: StocksAvgAggregateOutputType | null
    _sum: StocksSumAggregateOutputType | null
    _min: StocksMinAggregateOutputType | null
    _max: StocksMaxAggregateOutputType | null
  }

  export type StocksAvgAggregateOutputType = {
    id: number | null
    bags: number | null
    weight: number | null
    purchaseValue: number | null
    totalPurchaseValue: number | null
    agingDays: number | null
    penalty: number | null
    bgtCommission: number | null
    maerskFee: number | null
    commission: number | null
    netPrice: number | null
    total: number | null
    lowStockThreshold: number | null
  }

  export type StocksSumAggregateOutputType = {
    id: number | null
    bags: number | null
    weight: number | null
    purchaseValue: number | null
    totalPurchaseValue: number | null
    agingDays: number | null
    penalty: number | null
    bgtCommission: number | null
    maerskFee: number | null
    commission: number | null
    netPrice: number | null
    total: number | null
    lowStockThreshold: number | null
  }

  export type StocksMinAggregateOutputType = {
    id: number | null
    saleCode: string | null
    broker: $Enums.Broker | null
    lotNo: string | null
    mark: string | null
    grade: $Enums.TeaGrade | null
    invoiceNo: string | null
    bags: number | null
    weight: number | null
    purchaseValue: number | null
    totalPurchaseValue: number | null
    agingDays: number | null
    penalty: number | null
    bgtCommission: number | null
    maerskFee: number | null
    commission: number | null
    netPrice: number | null
    total: number | null
    batchNumber: string | null
    lowStockThreshold: number | null
    adminCognitoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StocksMaxAggregateOutputType = {
    id: number | null
    saleCode: string | null
    broker: $Enums.Broker | null
    lotNo: string | null
    mark: string | null
    grade: $Enums.TeaGrade | null
    invoiceNo: string | null
    bags: number | null
    weight: number | null
    purchaseValue: number | null
    totalPurchaseValue: number | null
    agingDays: number | null
    penalty: number | null
    bgtCommission: number | null
    maerskFee: number | null
    commission: number | null
    netPrice: number | null
    total: number | null
    batchNumber: string | null
    lowStockThreshold: number | null
    adminCognitoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StocksCountAggregateOutputType = {
    id: number
    saleCode: number
    broker: number
    lotNo: number
    mark: number
    grade: number
    invoiceNo: number
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber: number
    lowStockThreshold: number
    adminCognitoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StocksAvgAggregateInputType = {
    id?: true
    bags?: true
    weight?: true
    purchaseValue?: true
    totalPurchaseValue?: true
    agingDays?: true
    penalty?: true
    bgtCommission?: true
    maerskFee?: true
    commission?: true
    netPrice?: true
    total?: true
    lowStockThreshold?: true
  }

  export type StocksSumAggregateInputType = {
    id?: true
    bags?: true
    weight?: true
    purchaseValue?: true
    totalPurchaseValue?: true
    agingDays?: true
    penalty?: true
    bgtCommission?: true
    maerskFee?: true
    commission?: true
    netPrice?: true
    total?: true
    lowStockThreshold?: true
  }

  export type StocksMinAggregateInputType = {
    id?: true
    saleCode?: true
    broker?: true
    lotNo?: true
    mark?: true
    grade?: true
    invoiceNo?: true
    bags?: true
    weight?: true
    purchaseValue?: true
    totalPurchaseValue?: true
    agingDays?: true
    penalty?: true
    bgtCommission?: true
    maerskFee?: true
    commission?: true
    netPrice?: true
    total?: true
    batchNumber?: true
    lowStockThreshold?: true
    adminCognitoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StocksMaxAggregateInputType = {
    id?: true
    saleCode?: true
    broker?: true
    lotNo?: true
    mark?: true
    grade?: true
    invoiceNo?: true
    bags?: true
    weight?: true
    purchaseValue?: true
    totalPurchaseValue?: true
    agingDays?: true
    penalty?: true
    bgtCommission?: true
    maerskFee?: true
    commission?: true
    netPrice?: true
    total?: true
    batchNumber?: true
    lowStockThreshold?: true
    adminCognitoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StocksCountAggregateInputType = {
    id?: true
    saleCode?: true
    broker?: true
    lotNo?: true
    mark?: true
    grade?: true
    invoiceNo?: true
    bags?: true
    weight?: true
    purchaseValue?: true
    totalPurchaseValue?: true
    agingDays?: true
    penalty?: true
    bgtCommission?: true
    maerskFee?: true
    commission?: true
    netPrice?: true
    total?: true
    batchNumber?: true
    lowStockThreshold?: true
    adminCognitoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StocksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to aggregate.
     */
    where?: StocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StocksOrderByWithRelationInput | StocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StocksMaxAggregateInputType
  }

  export type GetStocksAggregateType<T extends StocksAggregateArgs> = {
        [P in keyof T & keyof AggregateStocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStocks[P]>
      : GetScalarType<T[P], AggregateStocks[P]>
  }




  export type StocksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StocksWhereInput
    orderBy?: StocksOrderByWithAggregationInput | StocksOrderByWithAggregationInput[]
    by: StocksScalarFieldEnum[] | StocksScalarFieldEnum
    having?: StocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StocksCountAggregateInputType | true
    _avg?: StocksAvgAggregateInputType
    _sum?: StocksSumAggregateInputType
    _min?: StocksMinAggregateInputType
    _max?: StocksMaxAggregateInputType
  }

  export type StocksGroupByOutputType = {
    id: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber: string | null
    lowStockThreshold: number | null
    adminCognitoId: string
    createdAt: Date
    updatedAt: Date
    _count: StocksCountAggregateOutputType | null
    _avg: StocksAvgAggregateOutputType | null
    _sum: StocksSumAggregateOutputType | null
    _min: StocksMinAggregateOutputType | null
    _max: StocksMaxAggregateOutputType | null
  }

  type GetStocksGroupByPayload<T extends StocksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StocksGroupByOutputType[P]>
            : GetScalarType<T[P], StocksGroupByOutputType[P]>
        }
      >
    >


  export type StocksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleCode?: boolean
    broker?: boolean
    lotNo?: boolean
    mark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    bags?: boolean
    weight?: boolean
    purchaseValue?: boolean
    totalPurchaseValue?: boolean
    agingDays?: boolean
    penalty?: boolean
    bgtCommission?: boolean
    maerskFee?: boolean
    commission?: boolean
    netPrice?: boolean
    total?: boolean
    batchNumber?: boolean
    lowStockThreshold?: boolean
    adminCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    assignments?: boolean | Stocks$assignmentsArgs<ExtArgs>
    shipmentItems?: boolean | Stocks$shipmentItemsArgs<ExtArgs>
    history?: boolean | Stocks$historyArgs<ExtArgs>
    favorites?: boolean | Stocks$favoritesArgs<ExtArgs>
    _count?: boolean | StocksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stocks"]>

  export type StocksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleCode?: boolean
    broker?: boolean
    lotNo?: boolean
    mark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    bags?: boolean
    weight?: boolean
    purchaseValue?: boolean
    totalPurchaseValue?: boolean
    agingDays?: boolean
    penalty?: boolean
    bgtCommission?: boolean
    maerskFee?: boolean
    commission?: boolean
    netPrice?: boolean
    total?: boolean
    batchNumber?: boolean
    lowStockThreshold?: boolean
    adminCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stocks"]>

  export type StocksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleCode?: boolean
    broker?: boolean
    lotNo?: boolean
    mark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    bags?: boolean
    weight?: boolean
    purchaseValue?: boolean
    totalPurchaseValue?: boolean
    agingDays?: boolean
    penalty?: boolean
    bgtCommission?: boolean
    maerskFee?: boolean
    commission?: boolean
    netPrice?: boolean
    total?: boolean
    batchNumber?: boolean
    lowStockThreshold?: boolean
    adminCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stocks"]>

  export type StocksSelectScalar = {
    id?: boolean
    saleCode?: boolean
    broker?: boolean
    lotNo?: boolean
    mark?: boolean
    grade?: boolean
    invoiceNo?: boolean
    bags?: boolean
    weight?: boolean
    purchaseValue?: boolean
    totalPurchaseValue?: boolean
    agingDays?: boolean
    penalty?: boolean
    bgtCommission?: boolean
    maerskFee?: boolean
    commission?: boolean
    netPrice?: boolean
    total?: boolean
    batchNumber?: boolean
    lowStockThreshold?: boolean
    adminCognitoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StocksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleCode" | "broker" | "lotNo" | "mark" | "grade" | "invoiceNo" | "bags" | "weight" | "purchaseValue" | "totalPurchaseValue" | "agingDays" | "penalty" | "bgtCommission" | "maerskFee" | "commission" | "netPrice" | "total" | "batchNumber" | "lowStockThreshold" | "adminCognitoId" | "createdAt" | "updatedAt", ExtArgs["result"]["stocks"]>
  export type StocksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    assignments?: boolean | Stocks$assignmentsArgs<ExtArgs>
    shipmentItems?: boolean | Stocks$shipmentItemsArgs<ExtArgs>
    history?: boolean | Stocks$historyArgs<ExtArgs>
    favorites?: boolean | Stocks$favoritesArgs<ExtArgs>
    _count?: boolean | StocksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StocksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type StocksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $StocksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stocks"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      assignments: Prisma.$StockAssignmentPayload<ExtArgs>[]
      shipmentItems: Prisma.$ShipmentItemPayload<ExtArgs>[]
      history: Prisma.$StockHistoryPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      saleCode: string
      broker: $Enums.Broker
      lotNo: string
      mark: string
      grade: $Enums.TeaGrade
      invoiceNo: string
      bags: number
      weight: number
      purchaseValue: number
      totalPurchaseValue: number
      agingDays: number
      penalty: number
      bgtCommission: number
      maerskFee: number
      commission: number
      netPrice: number
      total: number
      batchNumber: string | null
      lowStockThreshold: number | null
      adminCognitoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stocks"]>
    composites: {}
  }

  type StocksGetPayload<S extends boolean | null | undefined | StocksDefaultArgs> = $Result.GetResult<Prisma.$StocksPayload, S>

  type StocksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StocksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StocksCountAggregateInputType | true
    }

  export interface StocksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stocks'], meta: { name: 'Stocks' } }
    /**
     * Find zero or one Stocks that matches the filter.
     * @param {StocksFindUniqueArgs} args - Arguments to find a Stocks
     * @example
     * // Get one Stocks
     * const stocks = await prisma.stocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StocksFindUniqueArgs>(args: SelectSubset<T, StocksFindUniqueArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stocks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StocksFindUniqueOrThrowArgs} args - Arguments to find a Stocks
     * @example
     * // Get one Stocks
     * const stocks = await prisma.stocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StocksFindUniqueOrThrowArgs>(args: SelectSubset<T, StocksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StocksFindFirstArgs} args - Arguments to find a Stocks
     * @example
     * // Get one Stocks
     * const stocks = await prisma.stocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StocksFindFirstArgs>(args?: SelectSubset<T, StocksFindFirstArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StocksFindFirstOrThrowArgs} args - Arguments to find a Stocks
     * @example
     * // Get one Stocks
     * const stocks = await prisma.stocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StocksFindFirstOrThrowArgs>(args?: SelectSubset<T, StocksFindFirstOrThrowArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StocksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stocks.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stocks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stocksWithIdOnly = await prisma.stocks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StocksFindManyArgs>(args?: SelectSubset<T, StocksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stocks.
     * @param {StocksCreateArgs} args - Arguments to create a Stocks.
     * @example
     * // Create one Stocks
     * const Stocks = await prisma.stocks.create({
     *   data: {
     *     // ... data to create a Stocks
     *   }
     * })
     * 
     */
    create<T extends StocksCreateArgs>(args: SelectSubset<T, StocksCreateArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stocks.
     * @param {StocksCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stocks = await prisma.stocks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StocksCreateManyArgs>(args?: SelectSubset<T, StocksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stocks and returns the data saved in the database.
     * @param {StocksCreateManyAndReturnArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stocks = await prisma.stocks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stocks and only return the `id`
     * const stocksWithIdOnly = await prisma.stocks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StocksCreateManyAndReturnArgs>(args?: SelectSubset<T, StocksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stocks.
     * @param {StocksDeleteArgs} args - Arguments to delete one Stocks.
     * @example
     * // Delete one Stocks
     * const Stocks = await prisma.stocks.delete({
     *   where: {
     *     // ... filter to delete one Stocks
     *   }
     * })
     * 
     */
    delete<T extends StocksDeleteArgs>(args: SelectSubset<T, StocksDeleteArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stocks.
     * @param {StocksUpdateArgs} args - Arguments to update one Stocks.
     * @example
     * // Update one Stocks
     * const stocks = await prisma.stocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StocksUpdateArgs>(args: SelectSubset<T, StocksUpdateArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StocksDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StocksDeleteManyArgs>(args?: SelectSubset<T, StocksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stocks = await prisma.stocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StocksUpdateManyArgs>(args: SelectSubset<T, StocksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks and returns the data updated in the database.
     * @param {StocksUpdateManyAndReturnArgs} args - Arguments to update many Stocks.
     * @example
     * // Update many Stocks
     * const stocks = await prisma.stocks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stocks and only return the `id`
     * const stocksWithIdOnly = await prisma.stocks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StocksUpdateManyAndReturnArgs>(args: SelectSubset<T, StocksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stocks.
     * @param {StocksUpsertArgs} args - Arguments to update or create a Stocks.
     * @example
     * // Update or create a Stocks
     * const stocks = await prisma.stocks.upsert({
     *   create: {
     *     // ... data to create a Stocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stocks we want to update
     *   }
     * })
     */
    upsert<T extends StocksUpsertArgs>(args: SelectSubset<T, StocksUpsertArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StocksCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stocks.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StocksCountArgs>(
      args?: Subset<T, StocksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StocksAggregateArgs>(args: Subset<T, StocksAggregateArgs>): Prisma.PrismaPromise<GetStocksAggregateType<T>>

    /**
     * Group by Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StocksGroupByArgs['orderBy'] }
        : { orderBy?: StocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStocksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stocks model
   */
  readonly fields: StocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StocksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignments<T extends Stocks$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Stocks$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shipmentItems<T extends Stocks$shipmentItemsArgs<ExtArgs> = {}>(args?: Subset<T, Stocks$shipmentItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends Stocks$historyArgs<ExtArgs> = {}>(args?: Subset<T, Stocks$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Stocks$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Stocks$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stocks model
   */
  interface StocksFieldRefs {
    readonly id: FieldRef<"Stocks", 'Int'>
    readonly saleCode: FieldRef<"Stocks", 'String'>
    readonly broker: FieldRef<"Stocks", 'Broker'>
    readonly lotNo: FieldRef<"Stocks", 'String'>
    readonly mark: FieldRef<"Stocks", 'String'>
    readonly grade: FieldRef<"Stocks", 'TeaGrade'>
    readonly invoiceNo: FieldRef<"Stocks", 'String'>
    readonly bags: FieldRef<"Stocks", 'Int'>
    readonly weight: FieldRef<"Stocks", 'Float'>
    readonly purchaseValue: FieldRef<"Stocks", 'Float'>
    readonly totalPurchaseValue: FieldRef<"Stocks", 'Float'>
    readonly agingDays: FieldRef<"Stocks", 'Int'>
    readonly penalty: FieldRef<"Stocks", 'Float'>
    readonly bgtCommission: FieldRef<"Stocks", 'Float'>
    readonly maerskFee: FieldRef<"Stocks", 'Float'>
    readonly commission: FieldRef<"Stocks", 'Float'>
    readonly netPrice: FieldRef<"Stocks", 'Float'>
    readonly total: FieldRef<"Stocks", 'Float'>
    readonly batchNumber: FieldRef<"Stocks", 'String'>
    readonly lowStockThreshold: FieldRef<"Stocks", 'Float'>
    readonly adminCognitoId: FieldRef<"Stocks", 'String'>
    readonly createdAt: FieldRef<"Stocks", 'DateTime'>
    readonly updatedAt: FieldRef<"Stocks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stocks findUnique
   */
  export type StocksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where: StocksWhereUniqueInput
  }

  /**
   * Stocks findUniqueOrThrow
   */
  export type StocksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where: StocksWhereUniqueInput
  }

  /**
   * Stocks findFirst
   */
  export type StocksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StocksOrderByWithRelationInput | StocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StocksScalarFieldEnum | StocksScalarFieldEnum[]
  }

  /**
   * Stocks findFirstOrThrow
   */
  export type StocksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StocksOrderByWithRelationInput | StocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StocksScalarFieldEnum | StocksScalarFieldEnum[]
  }

  /**
   * Stocks findMany
   */
  export type StocksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StocksOrderByWithRelationInput | StocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StocksScalarFieldEnum | StocksScalarFieldEnum[]
  }

  /**
   * Stocks create
   */
  export type StocksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * The data needed to create a Stocks.
     */
    data: XOR<StocksCreateInput, StocksUncheckedCreateInput>
  }

  /**
   * Stocks createMany
   */
  export type StocksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StocksCreateManyInput | StocksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stocks createManyAndReturn
   */
  export type StocksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * The data used to create many Stocks.
     */
    data: StocksCreateManyInput | StocksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stocks update
   */
  export type StocksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * The data needed to update a Stocks.
     */
    data: XOR<StocksUpdateInput, StocksUncheckedUpdateInput>
    /**
     * Choose, which Stocks to update.
     */
    where: StocksWhereUniqueInput
  }

  /**
   * Stocks updateMany
   */
  export type StocksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StocksUpdateManyMutationInput, StocksUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StocksWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
  }

  /**
   * Stocks updateManyAndReturn
   */
  export type StocksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * The data used to update Stocks.
     */
    data: XOR<StocksUpdateManyMutationInput, StocksUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StocksWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stocks upsert
   */
  export type StocksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * The filter to search for the Stocks to update in case it exists.
     */
    where: StocksWhereUniqueInput
    /**
     * In case the Stocks found by the `where` argument doesn't exist, create a new Stocks with this data.
     */
    create: XOR<StocksCreateInput, StocksUncheckedCreateInput>
    /**
     * In case the Stocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StocksUpdateInput, StocksUncheckedUpdateInput>
  }

  /**
   * Stocks delete
   */
  export type StocksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    /**
     * Filter which Stocks to delete.
     */
    where: StocksWhereUniqueInput
  }

  /**
   * Stocks deleteMany
   */
  export type StocksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StocksWhereInput
    /**
     * Limit how many Stocks to delete.
     */
    limit?: number
  }

  /**
   * Stocks.assignments
   */
  export type Stocks$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    where?: StockAssignmentWhereInput
    orderBy?: StockAssignmentOrderByWithRelationInput | StockAssignmentOrderByWithRelationInput[]
    cursor?: StockAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockAssignmentScalarFieldEnum | StockAssignmentScalarFieldEnum[]
  }

  /**
   * Stocks.shipmentItems
   */
  export type Stocks$shipmentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    where?: ShipmentItemWhereInput
    orderBy?: ShipmentItemOrderByWithRelationInput | ShipmentItemOrderByWithRelationInput[]
    cursor?: ShipmentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentItemScalarFieldEnum | ShipmentItemScalarFieldEnum[]
  }

  /**
   * Stocks.history
   */
  export type Stocks$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    where?: StockHistoryWhereInput
    orderBy?: StockHistoryOrderByWithRelationInput | StockHistoryOrderByWithRelationInput[]
    cursor?: StockHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockHistoryScalarFieldEnum | StockHistoryScalarFieldEnum[]
  }

  /**
   * Stocks.favorites
   */
  export type Stocks$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Stocks without action
   */
  export type StocksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
  }


  /**
   * Model StockAssignment
   */

  export type AggregateStockAssignment = {
    _count: StockAssignmentCountAggregateOutputType | null
    _avg: StockAssignmentAvgAggregateOutputType | null
    _sum: StockAssignmentSumAggregateOutputType | null
    _min: StockAssignmentMinAggregateOutputType | null
    _max: StockAssignmentMaxAggregateOutputType | null
  }

  export type StockAssignmentAvgAggregateOutputType = {
    id: number | null
    stocksId: number | null
    assignedWeight: number | null
  }

  export type StockAssignmentSumAggregateOutputType = {
    id: number | null
    stocksId: number | null
    assignedWeight: number | null
  }

  export type StockAssignmentMinAggregateOutputType = {
    id: number | null
    stocksId: number | null
    userCognitoId: string | null
    assignedWeight: number | null
    assignedAt: Date | null
  }

  export type StockAssignmentMaxAggregateOutputType = {
    id: number | null
    stocksId: number | null
    userCognitoId: string | null
    assignedWeight: number | null
    assignedAt: Date | null
  }

  export type StockAssignmentCountAggregateOutputType = {
    id: number
    stocksId: number
    userCognitoId: number
    assignedWeight: number
    assignedAt: number
    _all: number
  }


  export type StockAssignmentAvgAggregateInputType = {
    id?: true
    stocksId?: true
    assignedWeight?: true
  }

  export type StockAssignmentSumAggregateInputType = {
    id?: true
    stocksId?: true
    assignedWeight?: true
  }

  export type StockAssignmentMinAggregateInputType = {
    id?: true
    stocksId?: true
    userCognitoId?: true
    assignedWeight?: true
    assignedAt?: true
  }

  export type StockAssignmentMaxAggregateInputType = {
    id?: true
    stocksId?: true
    userCognitoId?: true
    assignedWeight?: true
    assignedAt?: true
  }

  export type StockAssignmentCountAggregateInputType = {
    id?: true
    stocksId?: true
    userCognitoId?: true
    assignedWeight?: true
    assignedAt?: true
    _all?: true
  }

  export type StockAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockAssignment to aggregate.
     */
    where?: StockAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAssignments to fetch.
     */
    orderBy?: StockAssignmentOrderByWithRelationInput | StockAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockAssignments
    **/
    _count?: true | StockAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockAssignmentMaxAggregateInputType
  }

  export type GetStockAssignmentAggregateType<T extends StockAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStockAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockAssignment[P]>
      : GetScalarType<T[P], AggregateStockAssignment[P]>
  }




  export type StockAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAssignmentWhereInput
    orderBy?: StockAssignmentOrderByWithAggregationInput | StockAssignmentOrderByWithAggregationInput[]
    by: StockAssignmentScalarFieldEnum[] | StockAssignmentScalarFieldEnum
    having?: StockAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockAssignmentCountAggregateInputType | true
    _avg?: StockAssignmentAvgAggregateInputType
    _sum?: StockAssignmentSumAggregateInputType
    _min?: StockAssignmentMinAggregateInputType
    _max?: StockAssignmentMaxAggregateInputType
  }

  export type StockAssignmentGroupByOutputType = {
    id: number
    stocksId: number
    userCognitoId: string
    assignedWeight: number
    assignedAt: Date
    _count: StockAssignmentCountAggregateOutputType | null
    _avg: StockAssignmentAvgAggregateOutputType | null
    _sum: StockAssignmentSumAggregateOutputType | null
    _min: StockAssignmentMinAggregateOutputType | null
    _max: StockAssignmentMaxAggregateOutputType | null
  }

  type GetStockAssignmentGroupByPayload<T extends StockAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], StockAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type StockAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stocksId?: boolean
    userCognitoId?: boolean
    assignedWeight?: boolean
    assignedAt?: boolean
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAssignment"]>

  export type StockAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stocksId?: boolean
    userCognitoId?: boolean
    assignedWeight?: boolean
    assignedAt?: boolean
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAssignment"]>

  export type StockAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stocksId?: boolean
    userCognitoId?: boolean
    assignedWeight?: boolean
    assignedAt?: boolean
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAssignment"]>

  export type StockAssignmentSelectScalar = {
    id?: boolean
    stocksId?: boolean
    userCognitoId?: boolean
    assignedWeight?: boolean
    assignedAt?: boolean
  }

  export type StockAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stocksId" | "userCognitoId" | "assignedWeight" | "assignedAt", ExtArgs["result"]["stockAssignment"]>
  export type StockAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StockAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StockAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StockAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockAssignment"
    objects: {
      stocks: Prisma.$StocksPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stocksId: number
      userCognitoId: string
      assignedWeight: number
      assignedAt: Date
    }, ExtArgs["result"]["stockAssignment"]>
    composites: {}
  }

  type StockAssignmentGetPayload<S extends boolean | null | undefined | StockAssignmentDefaultArgs> = $Result.GetResult<Prisma.$StockAssignmentPayload, S>

  type StockAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockAssignmentCountAggregateInputType | true
    }

  export interface StockAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockAssignment'], meta: { name: 'StockAssignment' } }
    /**
     * Find zero or one StockAssignment that matches the filter.
     * @param {StockAssignmentFindUniqueArgs} args - Arguments to find a StockAssignment
     * @example
     * // Get one StockAssignment
     * const stockAssignment = await prisma.stockAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockAssignmentFindUniqueArgs>(args: SelectSubset<T, StockAssignmentFindUniqueArgs<ExtArgs>>): Prisma__StockAssignmentClient<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockAssignmentFindUniqueOrThrowArgs} args - Arguments to find a StockAssignment
     * @example
     * // Get one StockAssignment
     * const stockAssignment = await prisma.stockAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StockAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockAssignmentClient<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAssignmentFindFirstArgs} args - Arguments to find a StockAssignment
     * @example
     * // Get one StockAssignment
     * const stockAssignment = await prisma.stockAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockAssignmentFindFirstArgs>(args?: SelectSubset<T, StockAssignmentFindFirstArgs<ExtArgs>>): Prisma__StockAssignmentClient<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAssignmentFindFirstOrThrowArgs} args - Arguments to find a StockAssignment
     * @example
     * // Get one StockAssignment
     * const stockAssignment = await prisma.stockAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StockAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockAssignmentClient<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockAssignments
     * const stockAssignments = await prisma.stockAssignment.findMany()
     * 
     * // Get first 10 StockAssignments
     * const stockAssignments = await prisma.stockAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockAssignmentWithIdOnly = await prisma.stockAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockAssignmentFindManyArgs>(args?: SelectSubset<T, StockAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockAssignment.
     * @param {StockAssignmentCreateArgs} args - Arguments to create a StockAssignment.
     * @example
     * // Create one StockAssignment
     * const StockAssignment = await prisma.stockAssignment.create({
     *   data: {
     *     // ... data to create a StockAssignment
     *   }
     * })
     * 
     */
    create<T extends StockAssignmentCreateArgs>(args: SelectSubset<T, StockAssignmentCreateArgs<ExtArgs>>): Prisma__StockAssignmentClient<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockAssignments.
     * @param {StockAssignmentCreateManyArgs} args - Arguments to create many StockAssignments.
     * @example
     * // Create many StockAssignments
     * const stockAssignment = await prisma.stockAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockAssignmentCreateManyArgs>(args?: SelectSubset<T, StockAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockAssignments and returns the data saved in the database.
     * @param {StockAssignmentCreateManyAndReturnArgs} args - Arguments to create many StockAssignments.
     * @example
     * // Create many StockAssignments
     * const stockAssignment = await prisma.stockAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockAssignments and only return the `id`
     * const stockAssignmentWithIdOnly = await prisma.stockAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, StockAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockAssignment.
     * @param {StockAssignmentDeleteArgs} args - Arguments to delete one StockAssignment.
     * @example
     * // Delete one StockAssignment
     * const StockAssignment = await prisma.stockAssignment.delete({
     *   where: {
     *     // ... filter to delete one StockAssignment
     *   }
     * })
     * 
     */
    delete<T extends StockAssignmentDeleteArgs>(args: SelectSubset<T, StockAssignmentDeleteArgs<ExtArgs>>): Prisma__StockAssignmentClient<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockAssignment.
     * @param {StockAssignmentUpdateArgs} args - Arguments to update one StockAssignment.
     * @example
     * // Update one StockAssignment
     * const stockAssignment = await prisma.stockAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockAssignmentUpdateArgs>(args: SelectSubset<T, StockAssignmentUpdateArgs<ExtArgs>>): Prisma__StockAssignmentClient<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockAssignments.
     * @param {StockAssignmentDeleteManyArgs} args - Arguments to filter StockAssignments to delete.
     * @example
     * // Delete a few StockAssignments
     * const { count } = await prisma.stockAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockAssignmentDeleteManyArgs>(args?: SelectSubset<T, StockAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockAssignments
     * const stockAssignment = await prisma.stockAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockAssignmentUpdateManyArgs>(args: SelectSubset<T, StockAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockAssignments and returns the data updated in the database.
     * @param {StockAssignmentUpdateManyAndReturnArgs} args - Arguments to update many StockAssignments.
     * @example
     * // Update many StockAssignments
     * const stockAssignment = await prisma.stockAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockAssignments and only return the `id`
     * const stockAssignmentWithIdOnly = await prisma.stockAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, StockAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockAssignment.
     * @param {StockAssignmentUpsertArgs} args - Arguments to update or create a StockAssignment.
     * @example
     * // Update or create a StockAssignment
     * const stockAssignment = await prisma.stockAssignment.upsert({
     *   create: {
     *     // ... data to create a StockAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockAssignment we want to update
     *   }
     * })
     */
    upsert<T extends StockAssignmentUpsertArgs>(args: SelectSubset<T, StockAssignmentUpsertArgs<ExtArgs>>): Prisma__StockAssignmentClient<$Result.GetResult<Prisma.$StockAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAssignmentCountArgs} args - Arguments to filter StockAssignments to count.
     * @example
     * // Count the number of StockAssignments
     * const count = await prisma.stockAssignment.count({
     *   where: {
     *     // ... the filter for the StockAssignments we want to count
     *   }
     * })
    **/
    count<T extends StockAssignmentCountArgs>(
      args?: Subset<T, StockAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAssignmentAggregateArgs>(args: Subset<T, StockAssignmentAggregateArgs>): Prisma.PrismaPromise<GetStockAssignmentAggregateType<T>>

    /**
     * Group by StockAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: StockAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockAssignment model
   */
  readonly fields: StockAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stocks<T extends StocksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StocksDefaultArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockAssignment model
   */
  interface StockAssignmentFieldRefs {
    readonly id: FieldRef<"StockAssignment", 'Int'>
    readonly stocksId: FieldRef<"StockAssignment", 'Int'>
    readonly userCognitoId: FieldRef<"StockAssignment", 'String'>
    readonly assignedWeight: FieldRef<"StockAssignment", 'Float'>
    readonly assignedAt: FieldRef<"StockAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockAssignment findUnique
   */
  export type StockAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAssignment to fetch.
     */
    where: StockAssignmentWhereUniqueInput
  }

  /**
   * StockAssignment findUniqueOrThrow
   */
  export type StockAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAssignment to fetch.
     */
    where: StockAssignmentWhereUniqueInput
  }

  /**
   * StockAssignment findFirst
   */
  export type StockAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAssignment to fetch.
     */
    where?: StockAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAssignments to fetch.
     */
    orderBy?: StockAssignmentOrderByWithRelationInput | StockAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockAssignments.
     */
    cursor?: StockAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockAssignments.
     */
    distinct?: StockAssignmentScalarFieldEnum | StockAssignmentScalarFieldEnum[]
  }

  /**
   * StockAssignment findFirstOrThrow
   */
  export type StockAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAssignment to fetch.
     */
    where?: StockAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAssignments to fetch.
     */
    orderBy?: StockAssignmentOrderByWithRelationInput | StockAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockAssignments.
     */
    cursor?: StockAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockAssignments.
     */
    distinct?: StockAssignmentScalarFieldEnum | StockAssignmentScalarFieldEnum[]
  }

  /**
   * StockAssignment findMany
   */
  export type StockAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAssignments to fetch.
     */
    where?: StockAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAssignments to fetch.
     */
    orderBy?: StockAssignmentOrderByWithRelationInput | StockAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockAssignments.
     */
    cursor?: StockAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAssignments.
     */
    skip?: number
    distinct?: StockAssignmentScalarFieldEnum | StockAssignmentScalarFieldEnum[]
  }

  /**
   * StockAssignment create
   */
  export type StockAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StockAssignment.
     */
    data: XOR<StockAssignmentCreateInput, StockAssignmentUncheckedCreateInput>
  }

  /**
   * StockAssignment createMany
   */
  export type StockAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockAssignments.
     */
    data: StockAssignmentCreateManyInput | StockAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockAssignment createManyAndReturn
   */
  export type StockAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many StockAssignments.
     */
    data: StockAssignmentCreateManyInput | StockAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockAssignment update
   */
  export type StockAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StockAssignment.
     */
    data: XOR<StockAssignmentUpdateInput, StockAssignmentUncheckedUpdateInput>
    /**
     * Choose, which StockAssignment to update.
     */
    where: StockAssignmentWhereUniqueInput
  }

  /**
   * StockAssignment updateMany
   */
  export type StockAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockAssignments.
     */
    data: XOR<StockAssignmentUpdateManyMutationInput, StockAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which StockAssignments to update
     */
    where?: StockAssignmentWhereInput
    /**
     * Limit how many StockAssignments to update.
     */
    limit?: number
  }

  /**
   * StockAssignment updateManyAndReturn
   */
  export type StockAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update StockAssignments.
     */
    data: XOR<StockAssignmentUpdateManyMutationInput, StockAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which StockAssignments to update
     */
    where?: StockAssignmentWhereInput
    /**
     * Limit how many StockAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockAssignment upsert
   */
  export type StockAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StockAssignment to update in case it exists.
     */
    where: StockAssignmentWhereUniqueInput
    /**
     * In case the StockAssignment found by the `where` argument doesn't exist, create a new StockAssignment with this data.
     */
    create: XOR<StockAssignmentCreateInput, StockAssignmentUncheckedCreateInput>
    /**
     * In case the StockAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockAssignmentUpdateInput, StockAssignmentUncheckedUpdateInput>
  }

  /**
   * StockAssignment delete
   */
  export type StockAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
    /**
     * Filter which StockAssignment to delete.
     */
    where: StockAssignmentWhereUniqueInput
  }

  /**
   * StockAssignment deleteMany
   */
  export type StockAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockAssignments to delete
     */
    where?: StockAssignmentWhereInput
    /**
     * Limit how many StockAssignments to delete.
     */
    limit?: number
  }

  /**
   * StockAssignment without action
   */
  export type StockAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAssignment
     */
    select?: StockAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAssignment
     */
    omit?: StockAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Shipment
   */

  export type AggregateShipment = {
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  export type ShipmentAvgAggregateOutputType = {
    id: number | null
  }

  export type ShipmentSumAggregateOutputType = {
    id: number | null
  }

  export type ShipmentMinAggregateOutputType = {
    id: number | null
    shipmentDate: Date | null
    status: $Enums.ShipmentStatus | null
    userCognitoId: string | null
    adminCognitoId: string | null
    consignee: string | null
    vessel: $Enums.Vessel | null
    shipmark: string | null
    packagingInstructions: $Enums.PackagingInstructions | null
    additionalInstructions: string | null
    createdAt: Date | null
  }

  export type ShipmentMaxAggregateOutputType = {
    id: number | null
    shipmentDate: Date | null
    status: $Enums.ShipmentStatus | null
    userCognitoId: string | null
    adminCognitoId: string | null
    consignee: string | null
    vessel: $Enums.Vessel | null
    shipmark: string | null
    packagingInstructions: $Enums.PackagingInstructions | null
    additionalInstructions: string | null
    createdAt: Date | null
  }

  export type ShipmentCountAggregateOutputType = {
    id: number
    shipmentDate: number
    status: number
    userCognitoId: number
    adminCognitoId: number
    consignee: number
    vessel: number
    shipmark: number
    packagingInstructions: number
    additionalInstructions: number
    createdAt: number
    _all: number
  }


  export type ShipmentAvgAggregateInputType = {
    id?: true
  }

  export type ShipmentSumAggregateInputType = {
    id?: true
  }

  export type ShipmentMinAggregateInputType = {
    id?: true
    shipmentDate?: true
    status?: true
    userCognitoId?: true
    adminCognitoId?: true
    consignee?: true
    vessel?: true
    shipmark?: true
    packagingInstructions?: true
    additionalInstructions?: true
    createdAt?: true
  }

  export type ShipmentMaxAggregateInputType = {
    id?: true
    shipmentDate?: true
    status?: true
    userCognitoId?: true
    adminCognitoId?: true
    consignee?: true
    vessel?: true
    shipmark?: true
    packagingInstructions?: true
    additionalInstructions?: true
    createdAt?: true
  }

  export type ShipmentCountAggregateInputType = {
    id?: true
    shipmentDate?: true
    status?: true
    userCognitoId?: true
    adminCognitoId?: true
    consignee?: true
    vessel?: true
    shipmark?: true
    packagingInstructions?: true
    additionalInstructions?: true
    createdAt?: true
    _all?: true
  }

  export type ShipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipment to aggregate.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shipments
    **/
    _count?: true | ShipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentMaxAggregateInputType
  }

  export type GetShipmentAggregateType<T extends ShipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateShipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipment[P]>
      : GetScalarType<T[P], AggregateShipment[P]>
  }




  export type ShipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithAggregationInput | ShipmentOrderByWithAggregationInput[]
    by: ShipmentScalarFieldEnum[] | ShipmentScalarFieldEnum
    having?: ShipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentCountAggregateInputType | true
    _avg?: ShipmentAvgAggregateInputType
    _sum?: ShipmentSumAggregateInputType
    _min?: ShipmentMinAggregateInputType
    _max?: ShipmentMaxAggregateInputType
  }

  export type ShipmentGroupByOutputType = {
    id: number
    shipmentDate: Date
    status: $Enums.ShipmentStatus
    userCognitoId: string
    adminCognitoId: string | null
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions: string | null
    createdAt: Date
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  type GetShipmentGroupByPayload<T extends ShipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentDate?: boolean
    status?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    consignee?: boolean
    vessel?: boolean
    shipmark?: boolean
    packagingInstructions?: boolean
    additionalInstructions?: boolean
    createdAt?: boolean
    historyEntries?: boolean | Shipment$historyEntriesArgs<ExtArgs>
    stockHistory?: boolean | Shipment$stockHistoryArgs<ExtArgs>
    stocks?: boolean | Shipment$stocksArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | Shipment$adminArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentDate?: boolean
    status?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    consignee?: boolean
    vessel?: boolean
    shipmark?: boolean
    packagingInstructions?: boolean
    additionalInstructions?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | Shipment$adminArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentDate?: boolean
    status?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    consignee?: boolean
    vessel?: boolean
    shipmark?: boolean
    packagingInstructions?: boolean
    additionalInstructions?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | Shipment$adminArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectScalar = {
    id?: boolean
    shipmentDate?: boolean
    status?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    consignee?: boolean
    vessel?: boolean
    shipmark?: boolean
    packagingInstructions?: boolean
    additionalInstructions?: boolean
    createdAt?: boolean
  }

  export type ShipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shipmentDate" | "status" | "userCognitoId" | "adminCognitoId" | "consignee" | "vessel" | "shipmark" | "packagingInstructions" | "additionalInstructions" | "createdAt", ExtArgs["result"]["shipment"]>
  export type ShipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    historyEntries?: boolean | Shipment$historyEntriesArgs<ExtArgs>
    stockHistory?: boolean | Shipment$stockHistoryArgs<ExtArgs>
    stocks?: boolean | Shipment$stocksArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | Shipment$adminArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | Shipment$adminArgs<ExtArgs>
  }
  export type ShipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | Shipment$adminArgs<ExtArgs>
  }

  export type $ShipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shipment"
    objects: {
      historyEntries: Prisma.$ShipmentHistoryPayload<ExtArgs>[]
      stockHistory: Prisma.$StockHistoryPayload<ExtArgs>[]
      stocks: Prisma.$ShipmentItemPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipmentDate: Date
      status: $Enums.ShipmentStatus
      userCognitoId: string
      adminCognitoId: string | null
      consignee: string
      vessel: $Enums.Vessel
      shipmark: string
      packagingInstructions: $Enums.PackagingInstructions
      additionalInstructions: string | null
      createdAt: Date
    }, ExtArgs["result"]["shipment"]>
    composites: {}
  }

  type ShipmentGetPayload<S extends boolean | null | undefined | ShipmentDefaultArgs> = $Result.GetResult<Prisma.$ShipmentPayload, S>

  type ShipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShipmentCountAggregateInputType | true
    }

  export interface ShipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shipment'], meta: { name: 'Shipment' } }
    /**
     * Find zero or one Shipment that matches the filter.
     * @param {ShipmentFindUniqueArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentFindUniqueArgs>(args: SelectSubset<T, ShipmentFindUniqueArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShipmentFindUniqueOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentFindFirstArgs>(args?: SelectSubset<T, ShipmentFindFirstArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shipments
     * const shipments = await prisma.shipment.findMany()
     * 
     * // Get first 10 Shipments
     * const shipments = await prisma.shipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentWithIdOnly = await prisma.shipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentFindManyArgs>(args?: SelectSubset<T, ShipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shipment.
     * @param {ShipmentCreateArgs} args - Arguments to create a Shipment.
     * @example
     * // Create one Shipment
     * const Shipment = await prisma.shipment.create({
     *   data: {
     *     // ... data to create a Shipment
     *   }
     * })
     * 
     */
    create<T extends ShipmentCreateArgs>(args: SelectSubset<T, ShipmentCreateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shipments.
     * @param {ShipmentCreateManyArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentCreateManyArgs>(args?: SelectSubset<T, ShipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shipments and returns the data saved in the database.
     * @param {ShipmentCreateManyAndReturnArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shipments and only return the `id`
     * const shipmentWithIdOnly = await prisma.shipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shipment.
     * @param {ShipmentDeleteArgs} args - Arguments to delete one Shipment.
     * @example
     * // Delete one Shipment
     * const Shipment = await prisma.shipment.delete({
     *   where: {
     *     // ... filter to delete one Shipment
     *   }
     * })
     * 
     */
    delete<T extends ShipmentDeleteArgs>(args: SelectSubset<T, ShipmentDeleteArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shipment.
     * @param {ShipmentUpdateArgs} args - Arguments to update one Shipment.
     * @example
     * // Update one Shipment
     * const shipment = await prisma.shipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentUpdateArgs>(args: SelectSubset<T, ShipmentUpdateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shipments.
     * @param {ShipmentDeleteManyArgs} args - Arguments to filter Shipments to delete.
     * @example
     * // Delete a few Shipments
     * const { count } = await prisma.shipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentDeleteManyArgs>(args?: SelectSubset<T, ShipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentUpdateManyArgs>(args: SelectSubset<T, ShipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments and returns the data updated in the database.
     * @param {ShipmentUpdateManyAndReturnArgs} args - Arguments to update many Shipments.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shipments and only return the `id`
     * const shipmentWithIdOnly = await prisma.shipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ShipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shipment.
     * @param {ShipmentUpsertArgs} args - Arguments to update or create a Shipment.
     * @example
     * // Update or create a Shipment
     * const shipment = await prisma.shipment.upsert({
     *   create: {
     *     // ... data to create a Shipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipment we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentUpsertArgs>(args: SelectSubset<T, ShipmentUpsertArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentCountArgs} args - Arguments to filter Shipments to count.
     * @example
     * // Count the number of Shipments
     * const count = await prisma.shipment.count({
     *   where: {
     *     // ... the filter for the Shipments we want to count
     *   }
     * })
    **/
    count<T extends ShipmentCountArgs>(
      args?: Subset<T, ShipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentAggregateArgs>(args: Subset<T, ShipmentAggregateArgs>): Prisma.PrismaPromise<GetShipmentAggregateType<T>>

    /**
     * Group by Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shipment model
   */
  readonly fields: ShipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    historyEntries<T extends Shipment$historyEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$historyEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockHistory<T extends Shipment$stockHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$stockHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stocks<T extends Shipment$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admin<T extends Shipment$adminArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shipment model
   */
  interface ShipmentFieldRefs {
    readonly id: FieldRef<"Shipment", 'Int'>
    readonly shipmentDate: FieldRef<"Shipment", 'DateTime'>
    readonly status: FieldRef<"Shipment", 'ShipmentStatus'>
    readonly userCognitoId: FieldRef<"Shipment", 'String'>
    readonly adminCognitoId: FieldRef<"Shipment", 'String'>
    readonly consignee: FieldRef<"Shipment", 'String'>
    readonly vessel: FieldRef<"Shipment", 'Vessel'>
    readonly shipmark: FieldRef<"Shipment", 'String'>
    readonly packagingInstructions: FieldRef<"Shipment", 'PackagingInstructions'>
    readonly additionalInstructions: FieldRef<"Shipment", 'String'>
    readonly createdAt: FieldRef<"Shipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shipment findUnique
   */
  export type ShipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findUniqueOrThrow
   */
  export type ShipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findFirst
   */
  export type ShipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findFirstOrThrow
   */
  export type ShipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findMany
   */
  export type ShipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipments to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment create
   */
  export type ShipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Shipment.
     */
    data: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
  }

  /**
   * Shipment createMany
   */
  export type ShipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shipment createManyAndReturn
   */
  export type ShipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipment update
   */
  export type ShipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Shipment.
     */
    data: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
    /**
     * Choose, which Shipment to update.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment updateMany
   */
  export type ShipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to update.
     */
    limit?: number
  }

  /**
   * Shipment updateManyAndReturn
   */
  export type ShipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipment upsert
   */
  export type ShipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Shipment to update in case it exists.
     */
    where: ShipmentWhereUniqueInput
    /**
     * In case the Shipment found by the `where` argument doesn't exist, create a new Shipment with this data.
     */
    create: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
    /**
     * In case the Shipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
  }

  /**
   * Shipment delete
   */
  export type ShipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter which Shipment to delete.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment deleteMany
   */
  export type ShipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipments to delete
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to delete.
     */
    limit?: number
  }

  /**
   * Shipment.historyEntries
   */
  export type Shipment$historyEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    where?: ShipmentHistoryWhereInput
    orderBy?: ShipmentHistoryOrderByWithRelationInput | ShipmentHistoryOrderByWithRelationInput[]
    cursor?: ShipmentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentHistoryScalarFieldEnum | ShipmentHistoryScalarFieldEnum[]
  }

  /**
   * Shipment.stockHistory
   */
  export type Shipment$stockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    where?: StockHistoryWhereInput
    orderBy?: StockHistoryOrderByWithRelationInput | StockHistoryOrderByWithRelationInput[]
    cursor?: StockHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockHistoryScalarFieldEnum | StockHistoryScalarFieldEnum[]
  }

  /**
   * Shipment.stocks
   */
  export type Shipment$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    where?: ShipmentItemWhereInput
    orderBy?: ShipmentItemOrderByWithRelationInput | ShipmentItemOrderByWithRelationInput[]
    cursor?: ShipmentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentItemScalarFieldEnum | ShipmentItemScalarFieldEnum[]
  }

  /**
   * Shipment.admin
   */
  export type Shipment$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Shipment without action
   */
  export type ShipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
  }


  /**
   * Model ShipmentItem
   */

  export type AggregateShipmentItem = {
    _count: ShipmentItemCountAggregateOutputType | null
    _avg: ShipmentItemAvgAggregateOutputType | null
    _sum: ShipmentItemSumAggregateOutputType | null
    _min: ShipmentItemMinAggregateOutputType | null
    _max: ShipmentItemMaxAggregateOutputType | null
  }

  export type ShipmentItemAvgAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    stocksId: number | null
    assignedWeight: number | null
  }

  export type ShipmentItemSumAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    stocksId: number | null
    assignedWeight: number | null
  }

  export type ShipmentItemMinAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    stocksId: number | null
    assignedWeight: number | null
  }

  export type ShipmentItemMaxAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    stocksId: number | null
    assignedWeight: number | null
  }

  export type ShipmentItemCountAggregateOutputType = {
    id: number
    shipmentId: number
    stocksId: number
    assignedWeight: number
    _all: number
  }


  export type ShipmentItemAvgAggregateInputType = {
    id?: true
    shipmentId?: true
    stocksId?: true
    assignedWeight?: true
  }

  export type ShipmentItemSumAggregateInputType = {
    id?: true
    shipmentId?: true
    stocksId?: true
    assignedWeight?: true
  }

  export type ShipmentItemMinAggregateInputType = {
    id?: true
    shipmentId?: true
    stocksId?: true
    assignedWeight?: true
  }

  export type ShipmentItemMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    stocksId?: true
    assignedWeight?: true
  }

  export type ShipmentItemCountAggregateInputType = {
    id?: true
    shipmentId?: true
    stocksId?: true
    assignedWeight?: true
    _all?: true
  }

  export type ShipmentItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShipmentItem to aggregate.
     */
    where?: ShipmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentItems to fetch.
     */
    orderBy?: ShipmentItemOrderByWithRelationInput | ShipmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShipmentItems
    **/
    _count?: true | ShipmentItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipmentItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipmentItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentItemMaxAggregateInputType
  }

  export type GetShipmentItemAggregateType<T extends ShipmentItemAggregateArgs> = {
        [P in keyof T & keyof AggregateShipmentItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipmentItem[P]>
      : GetScalarType<T[P], AggregateShipmentItem[P]>
  }




  export type ShipmentItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentItemWhereInput
    orderBy?: ShipmentItemOrderByWithAggregationInput | ShipmentItemOrderByWithAggregationInput[]
    by: ShipmentItemScalarFieldEnum[] | ShipmentItemScalarFieldEnum
    having?: ShipmentItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentItemCountAggregateInputType | true
    _avg?: ShipmentItemAvgAggregateInputType
    _sum?: ShipmentItemSumAggregateInputType
    _min?: ShipmentItemMinAggregateInputType
    _max?: ShipmentItemMaxAggregateInputType
  }

  export type ShipmentItemGroupByOutputType = {
    id: number
    shipmentId: number
    stocksId: number
    assignedWeight: number
    _count: ShipmentItemCountAggregateOutputType | null
    _avg: ShipmentItemAvgAggregateOutputType | null
    _sum: ShipmentItemSumAggregateOutputType | null
    _min: ShipmentItemMinAggregateOutputType | null
    _max: ShipmentItemMaxAggregateOutputType | null
  }

  type GetShipmentItemGroupByPayload<T extends ShipmentItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentItemGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentItemGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    stocksId?: boolean
    assignedWeight?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentItem"]>

  export type ShipmentItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    stocksId?: boolean
    assignedWeight?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentItem"]>

  export type ShipmentItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    stocksId?: boolean
    assignedWeight?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentItem"]>

  export type ShipmentItemSelectScalar = {
    id?: boolean
    shipmentId?: boolean
    stocksId?: boolean
    assignedWeight?: boolean
  }

  export type ShipmentItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shipmentId" | "stocksId" | "assignedWeight", ExtArgs["result"]["shipmentItem"]>
  export type ShipmentItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
  }
  export type ShipmentItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
  }
  export type ShipmentItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
  }

  export type $ShipmentItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShipmentItem"
    objects: {
      shipment: Prisma.$ShipmentPayload<ExtArgs>
      stocks: Prisma.$StocksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipmentId: number
      stocksId: number
      assignedWeight: number
    }, ExtArgs["result"]["shipmentItem"]>
    composites: {}
  }

  type ShipmentItemGetPayload<S extends boolean | null | undefined | ShipmentItemDefaultArgs> = $Result.GetResult<Prisma.$ShipmentItemPayload, S>

  type ShipmentItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShipmentItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShipmentItemCountAggregateInputType | true
    }

  export interface ShipmentItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShipmentItem'], meta: { name: 'ShipmentItem' } }
    /**
     * Find zero or one ShipmentItem that matches the filter.
     * @param {ShipmentItemFindUniqueArgs} args - Arguments to find a ShipmentItem
     * @example
     * // Get one ShipmentItem
     * const shipmentItem = await prisma.shipmentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentItemFindUniqueArgs>(args: SelectSubset<T, ShipmentItemFindUniqueArgs<ExtArgs>>): Prisma__ShipmentItemClient<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShipmentItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShipmentItemFindUniqueOrThrowArgs} args - Arguments to find a ShipmentItem
     * @example
     * // Get one ShipmentItem
     * const shipmentItem = await prisma.shipmentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentItemClient<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShipmentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentItemFindFirstArgs} args - Arguments to find a ShipmentItem
     * @example
     * // Get one ShipmentItem
     * const shipmentItem = await prisma.shipmentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentItemFindFirstArgs>(args?: SelectSubset<T, ShipmentItemFindFirstArgs<ExtArgs>>): Prisma__ShipmentItemClient<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShipmentItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentItemFindFirstOrThrowArgs} args - Arguments to find a ShipmentItem
     * @example
     * // Get one ShipmentItem
     * const shipmentItem = await prisma.shipmentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentItemClient<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShipmentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShipmentItems
     * const shipmentItems = await prisma.shipmentItem.findMany()
     * 
     * // Get first 10 ShipmentItems
     * const shipmentItems = await prisma.shipmentItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentItemWithIdOnly = await prisma.shipmentItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentItemFindManyArgs>(args?: SelectSubset<T, ShipmentItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShipmentItem.
     * @param {ShipmentItemCreateArgs} args - Arguments to create a ShipmentItem.
     * @example
     * // Create one ShipmentItem
     * const ShipmentItem = await prisma.shipmentItem.create({
     *   data: {
     *     // ... data to create a ShipmentItem
     *   }
     * })
     * 
     */
    create<T extends ShipmentItemCreateArgs>(args: SelectSubset<T, ShipmentItemCreateArgs<ExtArgs>>): Prisma__ShipmentItemClient<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShipmentItems.
     * @param {ShipmentItemCreateManyArgs} args - Arguments to create many ShipmentItems.
     * @example
     * // Create many ShipmentItems
     * const shipmentItem = await prisma.shipmentItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentItemCreateManyArgs>(args?: SelectSubset<T, ShipmentItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShipmentItems and returns the data saved in the database.
     * @param {ShipmentItemCreateManyAndReturnArgs} args - Arguments to create many ShipmentItems.
     * @example
     * // Create many ShipmentItems
     * const shipmentItem = await prisma.shipmentItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShipmentItems and only return the `id`
     * const shipmentItemWithIdOnly = await prisma.shipmentItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShipmentItem.
     * @param {ShipmentItemDeleteArgs} args - Arguments to delete one ShipmentItem.
     * @example
     * // Delete one ShipmentItem
     * const ShipmentItem = await prisma.shipmentItem.delete({
     *   where: {
     *     // ... filter to delete one ShipmentItem
     *   }
     * })
     * 
     */
    delete<T extends ShipmentItemDeleteArgs>(args: SelectSubset<T, ShipmentItemDeleteArgs<ExtArgs>>): Prisma__ShipmentItemClient<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShipmentItem.
     * @param {ShipmentItemUpdateArgs} args - Arguments to update one ShipmentItem.
     * @example
     * // Update one ShipmentItem
     * const shipmentItem = await prisma.shipmentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentItemUpdateArgs>(args: SelectSubset<T, ShipmentItemUpdateArgs<ExtArgs>>): Prisma__ShipmentItemClient<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShipmentItems.
     * @param {ShipmentItemDeleteManyArgs} args - Arguments to filter ShipmentItems to delete.
     * @example
     * // Delete a few ShipmentItems
     * const { count } = await prisma.shipmentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentItemDeleteManyArgs>(args?: SelectSubset<T, ShipmentItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShipmentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShipmentItems
     * const shipmentItem = await prisma.shipmentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentItemUpdateManyArgs>(args: SelectSubset<T, ShipmentItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShipmentItems and returns the data updated in the database.
     * @param {ShipmentItemUpdateManyAndReturnArgs} args - Arguments to update many ShipmentItems.
     * @example
     * // Update many ShipmentItems
     * const shipmentItem = await prisma.shipmentItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShipmentItems and only return the `id`
     * const shipmentItemWithIdOnly = await prisma.shipmentItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShipmentItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ShipmentItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShipmentItem.
     * @param {ShipmentItemUpsertArgs} args - Arguments to update or create a ShipmentItem.
     * @example
     * // Update or create a ShipmentItem
     * const shipmentItem = await prisma.shipmentItem.upsert({
     *   create: {
     *     // ... data to create a ShipmentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShipmentItem we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentItemUpsertArgs>(args: SelectSubset<T, ShipmentItemUpsertArgs<ExtArgs>>): Prisma__ShipmentItemClient<$Result.GetResult<Prisma.$ShipmentItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShipmentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentItemCountArgs} args - Arguments to filter ShipmentItems to count.
     * @example
     * // Count the number of ShipmentItems
     * const count = await prisma.shipmentItem.count({
     *   where: {
     *     // ... the filter for the ShipmentItems we want to count
     *   }
     * })
    **/
    count<T extends ShipmentItemCountArgs>(
      args?: Subset<T, ShipmentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShipmentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentItemAggregateArgs>(args: Subset<T, ShipmentItemAggregateArgs>): Prisma.PrismaPromise<GetShipmentItemAggregateType<T>>

    /**
     * Group by ShipmentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentItemGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShipmentItem model
   */
  readonly fields: ShipmentItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShipmentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stocks<T extends StocksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StocksDefaultArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShipmentItem model
   */
  interface ShipmentItemFieldRefs {
    readonly id: FieldRef<"ShipmentItem", 'Int'>
    readonly shipmentId: FieldRef<"ShipmentItem", 'Int'>
    readonly stocksId: FieldRef<"ShipmentItem", 'Int'>
    readonly assignedWeight: FieldRef<"ShipmentItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ShipmentItem findUnique
   */
  export type ShipmentItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentItem to fetch.
     */
    where: ShipmentItemWhereUniqueInput
  }

  /**
   * ShipmentItem findUniqueOrThrow
   */
  export type ShipmentItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentItem to fetch.
     */
    where: ShipmentItemWhereUniqueInput
  }

  /**
   * ShipmentItem findFirst
   */
  export type ShipmentItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentItem to fetch.
     */
    where?: ShipmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentItems to fetch.
     */
    orderBy?: ShipmentItemOrderByWithRelationInput | ShipmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShipmentItems.
     */
    cursor?: ShipmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShipmentItems.
     */
    distinct?: ShipmentItemScalarFieldEnum | ShipmentItemScalarFieldEnum[]
  }

  /**
   * ShipmentItem findFirstOrThrow
   */
  export type ShipmentItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentItem to fetch.
     */
    where?: ShipmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentItems to fetch.
     */
    orderBy?: ShipmentItemOrderByWithRelationInput | ShipmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShipmentItems.
     */
    cursor?: ShipmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShipmentItems.
     */
    distinct?: ShipmentItemScalarFieldEnum | ShipmentItemScalarFieldEnum[]
  }

  /**
   * ShipmentItem findMany
   */
  export type ShipmentItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentItems to fetch.
     */
    where?: ShipmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentItems to fetch.
     */
    orderBy?: ShipmentItemOrderByWithRelationInput | ShipmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShipmentItems.
     */
    cursor?: ShipmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentItems.
     */
    skip?: number
    distinct?: ShipmentItemScalarFieldEnum | ShipmentItemScalarFieldEnum[]
  }

  /**
   * ShipmentItem create
   */
  export type ShipmentItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ShipmentItem.
     */
    data: XOR<ShipmentItemCreateInput, ShipmentItemUncheckedCreateInput>
  }

  /**
   * ShipmentItem createMany
   */
  export type ShipmentItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShipmentItems.
     */
    data: ShipmentItemCreateManyInput | ShipmentItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShipmentItem createManyAndReturn
   */
  export type ShipmentItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * The data used to create many ShipmentItems.
     */
    data: ShipmentItemCreateManyInput | ShipmentItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShipmentItem update
   */
  export type ShipmentItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ShipmentItem.
     */
    data: XOR<ShipmentItemUpdateInput, ShipmentItemUncheckedUpdateInput>
    /**
     * Choose, which ShipmentItem to update.
     */
    where: ShipmentItemWhereUniqueInput
  }

  /**
   * ShipmentItem updateMany
   */
  export type ShipmentItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShipmentItems.
     */
    data: XOR<ShipmentItemUpdateManyMutationInput, ShipmentItemUncheckedUpdateManyInput>
    /**
     * Filter which ShipmentItems to update
     */
    where?: ShipmentItemWhereInput
    /**
     * Limit how many ShipmentItems to update.
     */
    limit?: number
  }

  /**
   * ShipmentItem updateManyAndReturn
   */
  export type ShipmentItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * The data used to update ShipmentItems.
     */
    data: XOR<ShipmentItemUpdateManyMutationInput, ShipmentItemUncheckedUpdateManyInput>
    /**
     * Filter which ShipmentItems to update
     */
    where?: ShipmentItemWhereInput
    /**
     * Limit how many ShipmentItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShipmentItem upsert
   */
  export type ShipmentItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ShipmentItem to update in case it exists.
     */
    where: ShipmentItemWhereUniqueInput
    /**
     * In case the ShipmentItem found by the `where` argument doesn't exist, create a new ShipmentItem with this data.
     */
    create: XOR<ShipmentItemCreateInput, ShipmentItemUncheckedCreateInput>
    /**
     * In case the ShipmentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentItemUpdateInput, ShipmentItemUncheckedUpdateInput>
  }

  /**
   * ShipmentItem delete
   */
  export type ShipmentItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
    /**
     * Filter which ShipmentItem to delete.
     */
    where: ShipmentItemWhereUniqueInput
  }

  /**
   * ShipmentItem deleteMany
   */
  export type ShipmentItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShipmentItems to delete
     */
    where?: ShipmentItemWhereInput
    /**
     * Limit how many ShipmentItems to delete.
     */
    limit?: number
  }

  /**
   * ShipmentItem without action
   */
  export type ShipmentItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentItem
     */
    select?: ShipmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentItem
     */
    omit?: ShipmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentItemInclude<ExtArgs> | null
  }


  /**
   * Model StockHistory
   */

  export type AggregateStockHistory = {
    _count: StockHistoryCountAggregateOutputType | null
    _avg: StockHistoryAvgAggregateOutputType | null
    _sum: StockHistorySumAggregateOutputType | null
    _min: StockHistoryMinAggregateOutputType | null
    _max: StockHistoryMaxAggregateOutputType | null
  }

  export type StockHistoryAvgAggregateOutputType = {
    id: number | null
    stocksId: number | null
    shipmentId: number | null
  }

  export type StockHistorySumAggregateOutputType = {
    id: number | null
    stocksId: number | null
    shipmentId: number | null
  }

  export type StockHistoryMinAggregateOutputType = {
    id: number | null
    stocksId: number | null
    action: string | null
    timestamp: Date | null
    userCognitoId: string | null
    adminCognitoId: string | null
    shipmentId: number | null
  }

  export type StockHistoryMaxAggregateOutputType = {
    id: number | null
    stocksId: number | null
    action: string | null
    timestamp: Date | null
    userCognitoId: string | null
    adminCognitoId: string | null
    shipmentId: number | null
  }

  export type StockHistoryCountAggregateOutputType = {
    id: number
    stocksId: number
    action: number
    timestamp: number
    userCognitoId: number
    adminCognitoId: number
    details: number
    shipmentId: number
    _all: number
  }


  export type StockHistoryAvgAggregateInputType = {
    id?: true
    stocksId?: true
    shipmentId?: true
  }

  export type StockHistorySumAggregateInputType = {
    id?: true
    stocksId?: true
    shipmentId?: true
  }

  export type StockHistoryMinAggregateInputType = {
    id?: true
    stocksId?: true
    action?: true
    timestamp?: true
    userCognitoId?: true
    adminCognitoId?: true
    shipmentId?: true
  }

  export type StockHistoryMaxAggregateInputType = {
    id?: true
    stocksId?: true
    action?: true
    timestamp?: true
    userCognitoId?: true
    adminCognitoId?: true
    shipmentId?: true
  }

  export type StockHistoryCountAggregateInputType = {
    id?: true
    stocksId?: true
    action?: true
    timestamp?: true
    userCognitoId?: true
    adminCognitoId?: true
    details?: true
    shipmentId?: true
    _all?: true
  }

  export type StockHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockHistory to aggregate.
     */
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     */
    orderBy?: StockHistoryOrderByWithRelationInput | StockHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockHistories
    **/
    _count?: true | StockHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockHistoryMaxAggregateInputType
  }

  export type GetStockHistoryAggregateType<T extends StockHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStockHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockHistory[P]>
      : GetScalarType<T[P], AggregateStockHistory[P]>
  }




  export type StockHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockHistoryWhereInput
    orderBy?: StockHistoryOrderByWithAggregationInput | StockHistoryOrderByWithAggregationInput[]
    by: StockHistoryScalarFieldEnum[] | StockHistoryScalarFieldEnum
    having?: StockHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockHistoryCountAggregateInputType | true
    _avg?: StockHistoryAvgAggregateInputType
    _sum?: StockHistorySumAggregateInputType
    _min?: StockHistoryMinAggregateInputType
    _max?: StockHistoryMaxAggregateInputType
  }

  export type StockHistoryGroupByOutputType = {
    id: number
    stocksId: number
    action: string
    timestamp: Date
    userCognitoId: string | null
    adminCognitoId: string | null
    details: JsonValue | null
    shipmentId: number | null
    _count: StockHistoryCountAggregateOutputType | null
    _avg: StockHistoryAvgAggregateOutputType | null
    _sum: StockHistorySumAggregateOutputType | null
    _min: StockHistoryMinAggregateOutputType | null
    _max: StockHistoryMaxAggregateOutputType | null
  }

  type GetStockHistoryGroupByPayload<T extends StockHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], StockHistoryGroupByOutputType[P]>
        }
      >
    >


  export type StockHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stocksId?: boolean
    action?: boolean
    timestamp?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    details?: boolean
    shipmentId?: boolean
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | StockHistory$userArgs<ExtArgs>
    admin?: boolean | StockHistory$adminArgs<ExtArgs>
    shipment?: boolean | StockHistory$shipmentArgs<ExtArgs>
  }, ExtArgs["result"]["stockHistory"]>

  export type StockHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stocksId?: boolean
    action?: boolean
    timestamp?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    details?: boolean
    shipmentId?: boolean
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | StockHistory$userArgs<ExtArgs>
    admin?: boolean | StockHistory$adminArgs<ExtArgs>
    shipment?: boolean | StockHistory$shipmentArgs<ExtArgs>
  }, ExtArgs["result"]["stockHistory"]>

  export type StockHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stocksId?: boolean
    action?: boolean
    timestamp?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    details?: boolean
    shipmentId?: boolean
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | StockHistory$userArgs<ExtArgs>
    admin?: boolean | StockHistory$adminArgs<ExtArgs>
    shipment?: boolean | StockHistory$shipmentArgs<ExtArgs>
  }, ExtArgs["result"]["stockHistory"]>

  export type StockHistorySelectScalar = {
    id?: boolean
    stocksId?: boolean
    action?: boolean
    timestamp?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    details?: boolean
    shipmentId?: boolean
  }

  export type StockHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stocksId" | "action" | "timestamp" | "userCognitoId" | "adminCognitoId" | "details" | "shipmentId", ExtArgs["result"]["stockHistory"]>
  export type StockHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | StockHistory$userArgs<ExtArgs>
    admin?: boolean | StockHistory$adminArgs<ExtArgs>
    shipment?: boolean | StockHistory$shipmentArgs<ExtArgs>
  }
  export type StockHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | StockHistory$userArgs<ExtArgs>
    admin?: boolean | StockHistory$adminArgs<ExtArgs>
    shipment?: boolean | StockHistory$shipmentArgs<ExtArgs>
  }
  export type StockHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | StocksDefaultArgs<ExtArgs>
    user?: boolean | StockHistory$userArgs<ExtArgs>
    admin?: boolean | StockHistory$adminArgs<ExtArgs>
    shipment?: boolean | StockHistory$shipmentArgs<ExtArgs>
  }

  export type $StockHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockHistory"
    objects: {
      stocks: Prisma.$StocksPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      shipment: Prisma.$ShipmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stocksId: number
      action: string
      timestamp: Date
      userCognitoId: string | null
      adminCognitoId: string | null
      details: Prisma.JsonValue | null
      shipmentId: number | null
    }, ExtArgs["result"]["stockHistory"]>
    composites: {}
  }

  type StockHistoryGetPayload<S extends boolean | null | undefined | StockHistoryDefaultArgs> = $Result.GetResult<Prisma.$StockHistoryPayload, S>

  type StockHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockHistoryCountAggregateInputType | true
    }

  export interface StockHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockHistory'], meta: { name: 'StockHistory' } }
    /**
     * Find zero or one StockHistory that matches the filter.
     * @param {StockHistoryFindUniqueArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockHistoryFindUniqueArgs>(args: SelectSubset<T, StockHistoryFindUniqueArgs<ExtArgs>>): Prisma__StockHistoryClient<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockHistoryFindUniqueOrThrowArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StockHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockHistoryClient<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindFirstArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockHistoryFindFirstArgs>(args?: SelectSubset<T, StockHistoryFindFirstArgs<ExtArgs>>): Prisma__StockHistoryClient<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindFirstOrThrowArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StockHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockHistoryClient<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockHistories
     * const stockHistories = await prisma.stockHistory.findMany()
     * 
     * // Get first 10 StockHistories
     * const stockHistories = await prisma.stockHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockHistoryWithIdOnly = await prisma.stockHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockHistoryFindManyArgs>(args?: SelectSubset<T, StockHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockHistory.
     * @param {StockHistoryCreateArgs} args - Arguments to create a StockHistory.
     * @example
     * // Create one StockHistory
     * const StockHistory = await prisma.stockHistory.create({
     *   data: {
     *     // ... data to create a StockHistory
     *   }
     * })
     * 
     */
    create<T extends StockHistoryCreateArgs>(args: SelectSubset<T, StockHistoryCreateArgs<ExtArgs>>): Prisma__StockHistoryClient<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockHistories.
     * @param {StockHistoryCreateManyArgs} args - Arguments to create many StockHistories.
     * @example
     * // Create many StockHistories
     * const stockHistory = await prisma.stockHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockHistoryCreateManyArgs>(args?: SelectSubset<T, StockHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockHistories and returns the data saved in the database.
     * @param {StockHistoryCreateManyAndReturnArgs} args - Arguments to create many StockHistories.
     * @example
     * // Create many StockHistories
     * const stockHistory = await prisma.stockHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockHistories and only return the `id`
     * const stockHistoryWithIdOnly = await prisma.stockHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StockHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockHistory.
     * @param {StockHistoryDeleteArgs} args - Arguments to delete one StockHistory.
     * @example
     * // Delete one StockHistory
     * const StockHistory = await prisma.stockHistory.delete({
     *   where: {
     *     // ... filter to delete one StockHistory
     *   }
     * })
     * 
     */
    delete<T extends StockHistoryDeleteArgs>(args: SelectSubset<T, StockHistoryDeleteArgs<ExtArgs>>): Prisma__StockHistoryClient<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockHistory.
     * @param {StockHistoryUpdateArgs} args - Arguments to update one StockHistory.
     * @example
     * // Update one StockHistory
     * const stockHistory = await prisma.stockHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockHistoryUpdateArgs>(args: SelectSubset<T, StockHistoryUpdateArgs<ExtArgs>>): Prisma__StockHistoryClient<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockHistories.
     * @param {StockHistoryDeleteManyArgs} args - Arguments to filter StockHistories to delete.
     * @example
     * // Delete a few StockHistories
     * const { count } = await prisma.stockHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockHistoryDeleteManyArgs>(args?: SelectSubset<T, StockHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockHistories
     * const stockHistory = await prisma.stockHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockHistoryUpdateManyArgs>(args: SelectSubset<T, StockHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockHistories and returns the data updated in the database.
     * @param {StockHistoryUpdateManyAndReturnArgs} args - Arguments to update many StockHistories.
     * @example
     * // Update many StockHistories
     * const stockHistory = await prisma.stockHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockHistories and only return the `id`
     * const stockHistoryWithIdOnly = await prisma.stockHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, StockHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockHistory.
     * @param {StockHistoryUpsertArgs} args - Arguments to update or create a StockHistory.
     * @example
     * // Update or create a StockHistory
     * const stockHistory = await prisma.stockHistory.upsert({
     *   create: {
     *     // ... data to create a StockHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockHistory we want to update
     *   }
     * })
     */
    upsert<T extends StockHistoryUpsertArgs>(args: SelectSubset<T, StockHistoryUpsertArgs<ExtArgs>>): Prisma__StockHistoryClient<$Result.GetResult<Prisma.$StockHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryCountArgs} args - Arguments to filter StockHistories to count.
     * @example
     * // Count the number of StockHistories
     * const count = await prisma.stockHistory.count({
     *   where: {
     *     // ... the filter for the StockHistories we want to count
     *   }
     * })
    **/
    count<T extends StockHistoryCountArgs>(
      args?: Subset<T, StockHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockHistoryAggregateArgs>(args: Subset<T, StockHistoryAggregateArgs>): Prisma.PrismaPromise<GetStockHistoryAggregateType<T>>

    /**
     * Group by StockHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockHistoryGroupByArgs['orderBy'] }
        : { orderBy?: StockHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockHistory model
   */
  readonly fields: StockHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stocks<T extends StocksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StocksDefaultArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends StockHistory$userArgs<ExtArgs> = {}>(args?: Subset<T, StockHistory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends StockHistory$adminArgs<ExtArgs> = {}>(args?: Subset<T, StockHistory$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shipment<T extends StockHistory$shipmentArgs<ExtArgs> = {}>(args?: Subset<T, StockHistory$shipmentArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockHistory model
   */
  interface StockHistoryFieldRefs {
    readonly id: FieldRef<"StockHistory", 'Int'>
    readonly stocksId: FieldRef<"StockHistory", 'Int'>
    readonly action: FieldRef<"StockHistory", 'String'>
    readonly timestamp: FieldRef<"StockHistory", 'DateTime'>
    readonly userCognitoId: FieldRef<"StockHistory", 'String'>
    readonly adminCognitoId: FieldRef<"StockHistory", 'String'>
    readonly details: FieldRef<"StockHistory", 'Json'>
    readonly shipmentId: FieldRef<"StockHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StockHistory findUnique
   */
  export type StockHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StockHistory to fetch.
     */
    where: StockHistoryWhereUniqueInput
  }

  /**
   * StockHistory findUniqueOrThrow
   */
  export type StockHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StockHistory to fetch.
     */
    where: StockHistoryWhereUniqueInput
  }

  /**
   * StockHistory findFirst
   */
  export type StockHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StockHistory to fetch.
     */
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     */
    orderBy?: StockHistoryOrderByWithRelationInput | StockHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockHistories.
     */
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockHistories.
     */
    distinct?: StockHistoryScalarFieldEnum | StockHistoryScalarFieldEnum[]
  }

  /**
   * StockHistory findFirstOrThrow
   */
  export type StockHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StockHistory to fetch.
     */
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     */
    orderBy?: StockHistoryOrderByWithRelationInput | StockHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockHistories.
     */
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockHistories.
     */
    distinct?: StockHistoryScalarFieldEnum | StockHistoryScalarFieldEnum[]
  }

  /**
   * StockHistory findMany
   */
  export type StockHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StockHistories to fetch.
     */
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     */
    orderBy?: StockHistoryOrderByWithRelationInput | StockHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockHistories.
     */
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     */
    skip?: number
    distinct?: StockHistoryScalarFieldEnum | StockHistoryScalarFieldEnum[]
  }

  /**
   * StockHistory create
   */
  export type StockHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a StockHistory.
     */
    data: XOR<StockHistoryCreateInput, StockHistoryUncheckedCreateInput>
  }

  /**
   * StockHistory createMany
   */
  export type StockHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockHistories.
     */
    data: StockHistoryCreateManyInput | StockHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockHistory createManyAndReturn
   */
  export type StockHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many StockHistories.
     */
    data: StockHistoryCreateManyInput | StockHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockHistory update
   */
  export type StockHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a StockHistory.
     */
    data: XOR<StockHistoryUpdateInput, StockHistoryUncheckedUpdateInput>
    /**
     * Choose, which StockHistory to update.
     */
    where: StockHistoryWhereUniqueInput
  }

  /**
   * StockHistory updateMany
   */
  export type StockHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockHistories.
     */
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StockHistories to update
     */
    where?: StockHistoryWhereInput
    /**
     * Limit how many StockHistories to update.
     */
    limit?: number
  }

  /**
   * StockHistory updateManyAndReturn
   */
  export type StockHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * The data used to update StockHistories.
     */
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StockHistories to update
     */
    where?: StockHistoryWhereInput
    /**
     * Limit how many StockHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockHistory upsert
   */
  export type StockHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the StockHistory to update in case it exists.
     */
    where: StockHistoryWhereUniqueInput
    /**
     * In case the StockHistory found by the `where` argument doesn't exist, create a new StockHistory with this data.
     */
    create: XOR<StockHistoryCreateInput, StockHistoryUncheckedCreateInput>
    /**
     * In case the StockHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockHistoryUpdateInput, StockHistoryUncheckedUpdateInput>
  }

  /**
   * StockHistory delete
   */
  export type StockHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
    /**
     * Filter which StockHistory to delete.
     */
    where: StockHistoryWhereUniqueInput
  }

  /**
   * StockHistory deleteMany
   */
  export type StockHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockHistories to delete
     */
    where?: StockHistoryWhereInput
    /**
     * Limit how many StockHistories to delete.
     */
    limit?: number
  }

  /**
   * StockHistory.user
   */
  export type StockHistory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StockHistory.admin
   */
  export type StockHistory$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * StockHistory.shipment
   */
  export type StockHistory$shipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * StockHistory without action
   */
  export type StockHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockHistory
     */
    select?: StockHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockHistory
     */
    omit?: StockHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ShipmentHistory
   */

  export type AggregateShipmentHistory = {
    _count: ShipmentHistoryCountAggregateOutputType | null
    _avg: ShipmentHistoryAvgAggregateOutputType | null
    _sum: ShipmentHistorySumAggregateOutputType | null
    _min: ShipmentHistoryMinAggregateOutputType | null
    _max: ShipmentHistoryMaxAggregateOutputType | null
  }

  export type ShipmentHistoryAvgAggregateOutputType = {
    id: number | null
    shipmentId: number | null
  }

  export type ShipmentHistorySumAggregateOutputType = {
    id: number | null
    shipmentId: number | null
  }

  export type ShipmentHistoryMinAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    action: string | null
    timestamp: Date | null
    userCognitoId: string | null
    adminCognitoId: string | null
  }

  export type ShipmentHistoryMaxAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    action: string | null
    timestamp: Date | null
    userCognitoId: string | null
    adminCognitoId: string | null
  }

  export type ShipmentHistoryCountAggregateOutputType = {
    id: number
    shipmentId: number
    action: number
    timestamp: number
    userCognitoId: number
    adminCognitoId: number
    details: number
    _all: number
  }


  export type ShipmentHistoryAvgAggregateInputType = {
    id?: true
    shipmentId?: true
  }

  export type ShipmentHistorySumAggregateInputType = {
    id?: true
    shipmentId?: true
  }

  export type ShipmentHistoryMinAggregateInputType = {
    id?: true
    shipmentId?: true
    action?: true
    timestamp?: true
    userCognitoId?: true
    adminCognitoId?: true
  }

  export type ShipmentHistoryMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    action?: true
    timestamp?: true
    userCognitoId?: true
    adminCognitoId?: true
  }

  export type ShipmentHistoryCountAggregateInputType = {
    id?: true
    shipmentId?: true
    action?: true
    timestamp?: true
    userCognitoId?: true
    adminCognitoId?: true
    details?: true
    _all?: true
  }

  export type ShipmentHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShipmentHistory to aggregate.
     */
    where?: ShipmentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentHistories to fetch.
     */
    orderBy?: ShipmentHistoryOrderByWithRelationInput | ShipmentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShipmentHistories
    **/
    _count?: true | ShipmentHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipmentHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipmentHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentHistoryMaxAggregateInputType
  }

  export type GetShipmentHistoryAggregateType<T extends ShipmentHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateShipmentHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipmentHistory[P]>
      : GetScalarType<T[P], AggregateShipmentHistory[P]>
  }




  export type ShipmentHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentHistoryWhereInput
    orderBy?: ShipmentHistoryOrderByWithAggregationInput | ShipmentHistoryOrderByWithAggregationInput[]
    by: ShipmentHistoryScalarFieldEnum[] | ShipmentHistoryScalarFieldEnum
    having?: ShipmentHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentHistoryCountAggregateInputType | true
    _avg?: ShipmentHistoryAvgAggregateInputType
    _sum?: ShipmentHistorySumAggregateInputType
    _min?: ShipmentHistoryMinAggregateInputType
    _max?: ShipmentHistoryMaxAggregateInputType
  }

  export type ShipmentHistoryGroupByOutputType = {
    id: number
    shipmentId: number
    action: string
    timestamp: Date
    userCognitoId: string | null
    adminCognitoId: string | null
    details: JsonValue | null
    _count: ShipmentHistoryCountAggregateOutputType | null
    _avg: ShipmentHistoryAvgAggregateOutputType | null
    _sum: ShipmentHistorySumAggregateOutputType | null
    _min: ShipmentHistoryMinAggregateOutputType | null
    _max: ShipmentHistoryMaxAggregateOutputType | null
  }

  type GetShipmentHistoryGroupByPayload<T extends ShipmentHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    action?: boolean
    timestamp?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    details?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    user?: boolean | ShipmentHistory$userArgs<ExtArgs>
    admin?: boolean | ShipmentHistory$adminArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentHistory"]>

  export type ShipmentHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    action?: boolean
    timestamp?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    details?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    user?: boolean | ShipmentHistory$userArgs<ExtArgs>
    admin?: boolean | ShipmentHistory$adminArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentHistory"]>

  export type ShipmentHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    action?: boolean
    timestamp?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    details?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    user?: boolean | ShipmentHistory$userArgs<ExtArgs>
    admin?: boolean | ShipmentHistory$adminArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentHistory"]>

  export type ShipmentHistorySelectScalar = {
    id?: boolean
    shipmentId?: boolean
    action?: boolean
    timestamp?: boolean
    userCognitoId?: boolean
    adminCognitoId?: boolean
    details?: boolean
  }

  export type ShipmentHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shipmentId" | "action" | "timestamp" | "userCognitoId" | "adminCognitoId" | "details", ExtArgs["result"]["shipmentHistory"]>
  export type ShipmentHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    user?: boolean | ShipmentHistory$userArgs<ExtArgs>
    admin?: boolean | ShipmentHistory$adminArgs<ExtArgs>
  }
  export type ShipmentHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    user?: boolean | ShipmentHistory$userArgs<ExtArgs>
    admin?: boolean | ShipmentHistory$adminArgs<ExtArgs>
  }
  export type ShipmentHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    user?: boolean | ShipmentHistory$userArgs<ExtArgs>
    admin?: boolean | ShipmentHistory$adminArgs<ExtArgs>
  }

  export type $ShipmentHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShipmentHistory"
    objects: {
      shipment: Prisma.$ShipmentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipmentId: number
      action: string
      timestamp: Date
      userCognitoId: string | null
      adminCognitoId: string | null
      details: Prisma.JsonValue | null
    }, ExtArgs["result"]["shipmentHistory"]>
    composites: {}
  }

  type ShipmentHistoryGetPayload<S extends boolean | null | undefined | ShipmentHistoryDefaultArgs> = $Result.GetResult<Prisma.$ShipmentHistoryPayload, S>

  type ShipmentHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShipmentHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShipmentHistoryCountAggregateInputType | true
    }

  export interface ShipmentHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShipmentHistory'], meta: { name: 'ShipmentHistory' } }
    /**
     * Find zero or one ShipmentHistory that matches the filter.
     * @param {ShipmentHistoryFindUniqueArgs} args - Arguments to find a ShipmentHistory
     * @example
     * // Get one ShipmentHistory
     * const shipmentHistory = await prisma.shipmentHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentHistoryFindUniqueArgs>(args: SelectSubset<T, ShipmentHistoryFindUniqueArgs<ExtArgs>>): Prisma__ShipmentHistoryClient<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShipmentHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShipmentHistoryFindUniqueOrThrowArgs} args - Arguments to find a ShipmentHistory
     * @example
     * // Get one ShipmentHistory
     * const shipmentHistory = await prisma.shipmentHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentHistoryClient<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShipmentHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentHistoryFindFirstArgs} args - Arguments to find a ShipmentHistory
     * @example
     * // Get one ShipmentHistory
     * const shipmentHistory = await prisma.shipmentHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentHistoryFindFirstArgs>(args?: SelectSubset<T, ShipmentHistoryFindFirstArgs<ExtArgs>>): Prisma__ShipmentHistoryClient<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShipmentHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentHistoryFindFirstOrThrowArgs} args - Arguments to find a ShipmentHistory
     * @example
     * // Get one ShipmentHistory
     * const shipmentHistory = await prisma.shipmentHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentHistoryClient<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShipmentHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShipmentHistories
     * const shipmentHistories = await prisma.shipmentHistory.findMany()
     * 
     * // Get first 10 ShipmentHistories
     * const shipmentHistories = await prisma.shipmentHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentHistoryWithIdOnly = await prisma.shipmentHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentHistoryFindManyArgs>(args?: SelectSubset<T, ShipmentHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShipmentHistory.
     * @param {ShipmentHistoryCreateArgs} args - Arguments to create a ShipmentHistory.
     * @example
     * // Create one ShipmentHistory
     * const ShipmentHistory = await prisma.shipmentHistory.create({
     *   data: {
     *     // ... data to create a ShipmentHistory
     *   }
     * })
     * 
     */
    create<T extends ShipmentHistoryCreateArgs>(args: SelectSubset<T, ShipmentHistoryCreateArgs<ExtArgs>>): Prisma__ShipmentHistoryClient<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShipmentHistories.
     * @param {ShipmentHistoryCreateManyArgs} args - Arguments to create many ShipmentHistories.
     * @example
     * // Create many ShipmentHistories
     * const shipmentHistory = await prisma.shipmentHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentHistoryCreateManyArgs>(args?: SelectSubset<T, ShipmentHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShipmentHistories and returns the data saved in the database.
     * @param {ShipmentHistoryCreateManyAndReturnArgs} args - Arguments to create many ShipmentHistories.
     * @example
     * // Create many ShipmentHistories
     * const shipmentHistory = await prisma.shipmentHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShipmentHistories and only return the `id`
     * const shipmentHistoryWithIdOnly = await prisma.shipmentHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShipmentHistory.
     * @param {ShipmentHistoryDeleteArgs} args - Arguments to delete one ShipmentHistory.
     * @example
     * // Delete one ShipmentHistory
     * const ShipmentHistory = await prisma.shipmentHistory.delete({
     *   where: {
     *     // ... filter to delete one ShipmentHistory
     *   }
     * })
     * 
     */
    delete<T extends ShipmentHistoryDeleteArgs>(args: SelectSubset<T, ShipmentHistoryDeleteArgs<ExtArgs>>): Prisma__ShipmentHistoryClient<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShipmentHistory.
     * @param {ShipmentHistoryUpdateArgs} args - Arguments to update one ShipmentHistory.
     * @example
     * // Update one ShipmentHistory
     * const shipmentHistory = await prisma.shipmentHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentHistoryUpdateArgs>(args: SelectSubset<T, ShipmentHistoryUpdateArgs<ExtArgs>>): Prisma__ShipmentHistoryClient<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShipmentHistories.
     * @param {ShipmentHistoryDeleteManyArgs} args - Arguments to filter ShipmentHistories to delete.
     * @example
     * // Delete a few ShipmentHistories
     * const { count } = await prisma.shipmentHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentHistoryDeleteManyArgs>(args?: SelectSubset<T, ShipmentHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShipmentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShipmentHistories
     * const shipmentHistory = await prisma.shipmentHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentHistoryUpdateManyArgs>(args: SelectSubset<T, ShipmentHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShipmentHistories and returns the data updated in the database.
     * @param {ShipmentHistoryUpdateManyAndReturnArgs} args - Arguments to update many ShipmentHistories.
     * @example
     * // Update many ShipmentHistories
     * const shipmentHistory = await prisma.shipmentHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShipmentHistories and only return the `id`
     * const shipmentHistoryWithIdOnly = await prisma.shipmentHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShipmentHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ShipmentHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShipmentHistory.
     * @param {ShipmentHistoryUpsertArgs} args - Arguments to update or create a ShipmentHistory.
     * @example
     * // Update or create a ShipmentHistory
     * const shipmentHistory = await prisma.shipmentHistory.upsert({
     *   create: {
     *     // ... data to create a ShipmentHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShipmentHistory we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentHistoryUpsertArgs>(args: SelectSubset<T, ShipmentHistoryUpsertArgs<ExtArgs>>): Prisma__ShipmentHistoryClient<$Result.GetResult<Prisma.$ShipmentHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShipmentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentHistoryCountArgs} args - Arguments to filter ShipmentHistories to count.
     * @example
     * // Count the number of ShipmentHistories
     * const count = await prisma.shipmentHistory.count({
     *   where: {
     *     // ... the filter for the ShipmentHistories we want to count
     *   }
     * })
    **/
    count<T extends ShipmentHistoryCountArgs>(
      args?: Subset<T, ShipmentHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShipmentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentHistoryAggregateArgs>(args: Subset<T, ShipmentHistoryAggregateArgs>): Prisma.PrismaPromise<GetShipmentHistoryAggregateType<T>>

    /**
     * Group by ShipmentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShipmentHistory model
   */
  readonly fields: ShipmentHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShipmentHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ShipmentHistory$userArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentHistory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends ShipmentHistory$adminArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentHistory$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShipmentHistory model
   */
  interface ShipmentHistoryFieldRefs {
    readonly id: FieldRef<"ShipmentHistory", 'Int'>
    readonly shipmentId: FieldRef<"ShipmentHistory", 'Int'>
    readonly action: FieldRef<"ShipmentHistory", 'String'>
    readonly timestamp: FieldRef<"ShipmentHistory", 'DateTime'>
    readonly userCognitoId: FieldRef<"ShipmentHistory", 'String'>
    readonly adminCognitoId: FieldRef<"ShipmentHistory", 'String'>
    readonly details: FieldRef<"ShipmentHistory", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ShipmentHistory findUnique
   */
  export type ShipmentHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentHistory to fetch.
     */
    where: ShipmentHistoryWhereUniqueInput
  }

  /**
   * ShipmentHistory findUniqueOrThrow
   */
  export type ShipmentHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentHistory to fetch.
     */
    where: ShipmentHistoryWhereUniqueInput
  }

  /**
   * ShipmentHistory findFirst
   */
  export type ShipmentHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentHistory to fetch.
     */
    where?: ShipmentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentHistories to fetch.
     */
    orderBy?: ShipmentHistoryOrderByWithRelationInput | ShipmentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShipmentHistories.
     */
    cursor?: ShipmentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShipmentHistories.
     */
    distinct?: ShipmentHistoryScalarFieldEnum | ShipmentHistoryScalarFieldEnum[]
  }

  /**
   * ShipmentHistory findFirstOrThrow
   */
  export type ShipmentHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentHistory to fetch.
     */
    where?: ShipmentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentHistories to fetch.
     */
    orderBy?: ShipmentHistoryOrderByWithRelationInput | ShipmentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShipmentHistories.
     */
    cursor?: ShipmentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShipmentHistories.
     */
    distinct?: ShipmentHistoryScalarFieldEnum | ShipmentHistoryScalarFieldEnum[]
  }

  /**
   * ShipmentHistory findMany
   */
  export type ShipmentHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentHistories to fetch.
     */
    where?: ShipmentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentHistories to fetch.
     */
    orderBy?: ShipmentHistoryOrderByWithRelationInput | ShipmentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShipmentHistories.
     */
    cursor?: ShipmentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentHistories.
     */
    skip?: number
    distinct?: ShipmentHistoryScalarFieldEnum | ShipmentHistoryScalarFieldEnum[]
  }

  /**
   * ShipmentHistory create
   */
  export type ShipmentHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ShipmentHistory.
     */
    data: XOR<ShipmentHistoryCreateInput, ShipmentHistoryUncheckedCreateInput>
  }

  /**
   * ShipmentHistory createMany
   */
  export type ShipmentHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShipmentHistories.
     */
    data: ShipmentHistoryCreateManyInput | ShipmentHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShipmentHistory createManyAndReturn
   */
  export type ShipmentHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ShipmentHistories.
     */
    data: ShipmentHistoryCreateManyInput | ShipmentHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShipmentHistory update
   */
  export type ShipmentHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ShipmentHistory.
     */
    data: XOR<ShipmentHistoryUpdateInput, ShipmentHistoryUncheckedUpdateInput>
    /**
     * Choose, which ShipmentHistory to update.
     */
    where: ShipmentHistoryWhereUniqueInput
  }

  /**
   * ShipmentHistory updateMany
   */
  export type ShipmentHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShipmentHistories.
     */
    data: XOR<ShipmentHistoryUpdateManyMutationInput, ShipmentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ShipmentHistories to update
     */
    where?: ShipmentHistoryWhereInput
    /**
     * Limit how many ShipmentHistories to update.
     */
    limit?: number
  }

  /**
   * ShipmentHistory updateManyAndReturn
   */
  export type ShipmentHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ShipmentHistories.
     */
    data: XOR<ShipmentHistoryUpdateManyMutationInput, ShipmentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ShipmentHistories to update
     */
    where?: ShipmentHistoryWhereInput
    /**
     * Limit how many ShipmentHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShipmentHistory upsert
   */
  export type ShipmentHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ShipmentHistory to update in case it exists.
     */
    where: ShipmentHistoryWhereUniqueInput
    /**
     * In case the ShipmentHistory found by the `where` argument doesn't exist, create a new ShipmentHistory with this data.
     */
    create: XOR<ShipmentHistoryCreateInput, ShipmentHistoryUncheckedCreateInput>
    /**
     * In case the ShipmentHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentHistoryUpdateInput, ShipmentHistoryUncheckedUpdateInput>
  }

  /**
   * ShipmentHistory delete
   */
  export type ShipmentHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
    /**
     * Filter which ShipmentHistory to delete.
     */
    where: ShipmentHistoryWhereUniqueInput
  }

  /**
   * ShipmentHistory deleteMany
   */
  export type ShipmentHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShipmentHistories to delete
     */
    where?: ShipmentHistoryWhereInput
    /**
     * Limit how many ShipmentHistories to delete.
     */
    limit?: number
  }

  /**
   * ShipmentHistory.user
   */
  export type ShipmentHistory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ShipmentHistory.admin
   */
  export type ShipmentHistory$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * ShipmentHistory without action
   */
  export type ShipmentHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentHistory
     */
    select?: ShipmentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShipmentHistory
     */
    omit?: ShipmentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AdminNotification
   */

  export type AggregateAdminNotification = {
    _count: AdminNotificationCountAggregateOutputType | null
    _avg: AdminNotificationAvgAggregateOutputType | null
    _sum: AdminNotificationSumAggregateOutputType | null
    _min: AdminNotificationMinAggregateOutputType | null
    _max: AdminNotificationMaxAggregateOutputType | null
  }

  export type AdminNotificationAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminNotificationSumAggregateOutputType = {
    id: number | null
  }

  export type AdminNotificationMinAggregateOutputType = {
    id: number | null
    adminCognitoId: string | null
    message: string | null
    createdAt: Date | null
  }

  export type AdminNotificationMaxAggregateOutputType = {
    id: number | null
    adminCognitoId: string | null
    message: string | null
    createdAt: Date | null
  }

  export type AdminNotificationCountAggregateOutputType = {
    id: number
    adminCognitoId: number
    message: number
    details: number
    createdAt: number
    _all: number
  }


  export type AdminNotificationAvgAggregateInputType = {
    id?: true
  }

  export type AdminNotificationSumAggregateInputType = {
    id?: true
  }

  export type AdminNotificationMinAggregateInputType = {
    id?: true
    adminCognitoId?: true
    message?: true
    createdAt?: true
  }

  export type AdminNotificationMaxAggregateInputType = {
    id?: true
    adminCognitoId?: true
    message?: true
    createdAt?: true
  }

  export type AdminNotificationCountAggregateInputType = {
    id?: true
    adminCognitoId?: true
    message?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AdminNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminNotification to aggregate.
     */
    where?: AdminNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotifications to fetch.
     */
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminNotifications
    **/
    _count?: true | AdminNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminNotificationMaxAggregateInputType
  }

  export type GetAdminNotificationAggregateType<T extends AdminNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminNotification[P]>
      : GetScalarType<T[P], AggregateAdminNotification[P]>
  }




  export type AdminNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNotificationWhereInput
    orderBy?: AdminNotificationOrderByWithAggregationInput | AdminNotificationOrderByWithAggregationInput[]
    by: AdminNotificationScalarFieldEnum[] | AdminNotificationScalarFieldEnum
    having?: AdminNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminNotificationCountAggregateInputType | true
    _avg?: AdminNotificationAvgAggregateInputType
    _sum?: AdminNotificationSumAggregateInputType
    _min?: AdminNotificationMinAggregateInputType
    _max?: AdminNotificationMaxAggregateInputType
  }

  export type AdminNotificationGroupByOutputType = {
    id: number
    adminCognitoId: string
    message: string
    details: JsonValue
    createdAt: Date
    _count: AdminNotificationCountAggregateOutputType | null
    _avg: AdminNotificationAvgAggregateOutputType | null
    _sum: AdminNotificationSumAggregateOutputType | null
    _min: AdminNotificationMinAggregateOutputType | null
    _max: AdminNotificationMaxAggregateOutputType | null
  }

  type GetAdminNotificationGroupByPayload<T extends AdminNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], AdminNotificationGroupByOutputType[P]>
        }
      >
    >


  export type AdminNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminCognitoId?: boolean
    message?: boolean
    details?: boolean
    createdAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminNotification"]>

  export type AdminNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminCognitoId?: boolean
    message?: boolean
    details?: boolean
    createdAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminNotification"]>

  export type AdminNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminCognitoId?: boolean
    message?: boolean
    details?: boolean
    createdAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminNotification"]>

  export type AdminNotificationSelectScalar = {
    id?: boolean
    adminCognitoId?: boolean
    message?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AdminNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminCognitoId" | "message" | "details" | "createdAt", ExtArgs["result"]["adminNotification"]>
  export type AdminNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminNotification"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adminCognitoId: string
      message: string
      details: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["adminNotification"]>
    composites: {}
  }

  type AdminNotificationGetPayload<S extends boolean | null | undefined | AdminNotificationDefaultArgs> = $Result.GetResult<Prisma.$AdminNotificationPayload, S>

  type AdminNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminNotificationCountAggregateInputType | true
    }

  export interface AdminNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminNotification'], meta: { name: 'AdminNotification' } }
    /**
     * Find zero or one AdminNotification that matches the filter.
     * @param {AdminNotificationFindUniqueArgs} args - Arguments to find a AdminNotification
     * @example
     * // Get one AdminNotification
     * const adminNotification = await prisma.adminNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminNotificationFindUniqueArgs>(args: SelectSubset<T, AdminNotificationFindUniqueArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminNotificationFindUniqueOrThrowArgs} args - Arguments to find a AdminNotification
     * @example
     * // Get one AdminNotification
     * const adminNotification = await prisma.adminNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationFindFirstArgs} args - Arguments to find a AdminNotification
     * @example
     * // Get one AdminNotification
     * const adminNotification = await prisma.adminNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminNotificationFindFirstArgs>(args?: SelectSubset<T, AdminNotificationFindFirstArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationFindFirstOrThrowArgs} args - Arguments to find a AdminNotification
     * @example
     * // Get one AdminNotification
     * const adminNotification = await prisma.adminNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminNotifications
     * const adminNotifications = await prisma.adminNotification.findMany()
     * 
     * // Get first 10 AdminNotifications
     * const adminNotifications = await prisma.adminNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminNotificationWithIdOnly = await prisma.adminNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminNotificationFindManyArgs>(args?: SelectSubset<T, AdminNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminNotification.
     * @param {AdminNotificationCreateArgs} args - Arguments to create a AdminNotification.
     * @example
     * // Create one AdminNotification
     * const AdminNotification = await prisma.adminNotification.create({
     *   data: {
     *     // ... data to create a AdminNotification
     *   }
     * })
     * 
     */
    create<T extends AdminNotificationCreateArgs>(args: SelectSubset<T, AdminNotificationCreateArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminNotifications.
     * @param {AdminNotificationCreateManyArgs} args - Arguments to create many AdminNotifications.
     * @example
     * // Create many AdminNotifications
     * const adminNotification = await prisma.adminNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminNotificationCreateManyArgs>(args?: SelectSubset<T, AdminNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminNotifications and returns the data saved in the database.
     * @param {AdminNotificationCreateManyAndReturnArgs} args - Arguments to create many AdminNotifications.
     * @example
     * // Create many AdminNotifications
     * const adminNotification = await prisma.adminNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminNotifications and only return the `id`
     * const adminNotificationWithIdOnly = await prisma.adminNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminNotification.
     * @param {AdminNotificationDeleteArgs} args - Arguments to delete one AdminNotification.
     * @example
     * // Delete one AdminNotification
     * const AdminNotification = await prisma.adminNotification.delete({
     *   where: {
     *     // ... filter to delete one AdminNotification
     *   }
     * })
     * 
     */
    delete<T extends AdminNotificationDeleteArgs>(args: SelectSubset<T, AdminNotificationDeleteArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminNotification.
     * @param {AdminNotificationUpdateArgs} args - Arguments to update one AdminNotification.
     * @example
     * // Update one AdminNotification
     * const adminNotification = await prisma.adminNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminNotificationUpdateArgs>(args: SelectSubset<T, AdminNotificationUpdateArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminNotifications.
     * @param {AdminNotificationDeleteManyArgs} args - Arguments to filter AdminNotifications to delete.
     * @example
     * // Delete a few AdminNotifications
     * const { count } = await prisma.adminNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminNotificationDeleteManyArgs>(args?: SelectSubset<T, AdminNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminNotifications
     * const adminNotification = await prisma.adminNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminNotificationUpdateManyArgs>(args: SelectSubset<T, AdminNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminNotifications and returns the data updated in the database.
     * @param {AdminNotificationUpdateManyAndReturnArgs} args - Arguments to update many AdminNotifications.
     * @example
     * // Update many AdminNotifications
     * const adminNotification = await prisma.adminNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminNotifications and only return the `id`
     * const adminNotificationWithIdOnly = await prisma.adminNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminNotification.
     * @param {AdminNotificationUpsertArgs} args - Arguments to update or create a AdminNotification.
     * @example
     * // Update or create a AdminNotification
     * const adminNotification = await prisma.adminNotification.upsert({
     *   create: {
     *     // ... data to create a AdminNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminNotification we want to update
     *   }
     * })
     */
    upsert<T extends AdminNotificationUpsertArgs>(args: SelectSubset<T, AdminNotificationUpsertArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationCountArgs} args - Arguments to filter AdminNotifications to count.
     * @example
     * // Count the number of AdminNotifications
     * const count = await prisma.adminNotification.count({
     *   where: {
     *     // ... the filter for the AdminNotifications we want to count
     *   }
     * })
    **/
    count<T extends AdminNotificationCountArgs>(
      args?: Subset<T, AdminNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminNotificationAggregateArgs>(args: Subset<T, AdminNotificationAggregateArgs>): Prisma.PrismaPromise<GetAdminNotificationAggregateType<T>>

    /**
     * Group by AdminNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminNotificationGroupByArgs['orderBy'] }
        : { orderBy?: AdminNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminNotification model
   */
  readonly fields: AdminNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminNotification model
   */
  interface AdminNotificationFieldRefs {
    readonly id: FieldRef<"AdminNotification", 'Int'>
    readonly adminCognitoId: FieldRef<"AdminNotification", 'String'>
    readonly message: FieldRef<"AdminNotification", 'String'>
    readonly details: FieldRef<"AdminNotification", 'Json'>
    readonly createdAt: FieldRef<"AdminNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminNotification findUnique
   */
  export type AdminNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AdminNotification to fetch.
     */
    where: AdminNotificationWhereUniqueInput
  }

  /**
   * AdminNotification findUniqueOrThrow
   */
  export type AdminNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AdminNotification to fetch.
     */
    where: AdminNotificationWhereUniqueInput
  }

  /**
   * AdminNotification findFirst
   */
  export type AdminNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AdminNotification to fetch.
     */
    where?: AdminNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotifications to fetch.
     */
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminNotifications.
     */
    cursor?: AdminNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminNotifications.
     */
    distinct?: AdminNotificationScalarFieldEnum | AdminNotificationScalarFieldEnum[]
  }

  /**
   * AdminNotification findFirstOrThrow
   */
  export type AdminNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AdminNotification to fetch.
     */
    where?: AdminNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotifications to fetch.
     */
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminNotifications.
     */
    cursor?: AdminNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminNotifications.
     */
    distinct?: AdminNotificationScalarFieldEnum | AdminNotificationScalarFieldEnum[]
  }

  /**
   * AdminNotification findMany
   */
  export type AdminNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AdminNotifications to fetch.
     */
    where?: AdminNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotifications to fetch.
     */
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminNotifications.
     */
    cursor?: AdminNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotifications.
     */
    skip?: number
    distinct?: AdminNotificationScalarFieldEnum | AdminNotificationScalarFieldEnum[]
  }

  /**
   * AdminNotification create
   */
  export type AdminNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminNotification.
     */
    data: XOR<AdminNotificationCreateInput, AdminNotificationUncheckedCreateInput>
  }

  /**
   * AdminNotification createMany
   */
  export type AdminNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminNotifications.
     */
    data: AdminNotificationCreateManyInput | AdminNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminNotification createManyAndReturn
   */
  export type AdminNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many AdminNotifications.
     */
    data: AdminNotificationCreateManyInput | AdminNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminNotification update
   */
  export type AdminNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminNotification.
     */
    data: XOR<AdminNotificationUpdateInput, AdminNotificationUncheckedUpdateInput>
    /**
     * Choose, which AdminNotification to update.
     */
    where: AdminNotificationWhereUniqueInput
  }

  /**
   * AdminNotification updateMany
   */
  export type AdminNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminNotifications.
     */
    data: XOR<AdminNotificationUpdateManyMutationInput, AdminNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AdminNotifications to update
     */
    where?: AdminNotificationWhereInput
    /**
     * Limit how many AdminNotifications to update.
     */
    limit?: number
  }

  /**
   * AdminNotification updateManyAndReturn
   */
  export type AdminNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * The data used to update AdminNotifications.
     */
    data: XOR<AdminNotificationUpdateManyMutationInput, AdminNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AdminNotifications to update
     */
    where?: AdminNotificationWhereInput
    /**
     * Limit how many AdminNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminNotification upsert
   */
  export type AdminNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminNotification to update in case it exists.
     */
    where: AdminNotificationWhereUniqueInput
    /**
     * In case the AdminNotification found by the `where` argument doesn't exist, create a new AdminNotification with this data.
     */
    create: XOR<AdminNotificationCreateInput, AdminNotificationUncheckedCreateInput>
    /**
     * In case the AdminNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminNotificationUpdateInput, AdminNotificationUncheckedUpdateInput>
  }

  /**
   * AdminNotification delete
   */
  export type AdminNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
    /**
     * Filter which AdminNotification to delete.
     */
    where: AdminNotificationWhereUniqueInput
  }

  /**
   * AdminNotification deleteMany
   */
  export type AdminNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminNotifications to delete
     */
    where?: AdminNotificationWhereInput
    /**
     * Limit how many AdminNotifications to delete.
     */
    limit?: number
  }

  /**
   * AdminNotification without action
   */
  export type AdminNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNotificationInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    privacyConsent: boolean | null
    userCognitoId: string | null
    createdAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    privacyConsent: boolean | null
    userCognitoId: string | null
    createdAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subject: number
    message: number
    privacyConsent: number
    userCognitoId: number
    createdAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    privacyConsent?: true
    userCognitoId?: true
    createdAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    privacyConsent?: true
    userCognitoId?: true
    createdAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    privacyConsent?: true
    userCognitoId?: true
    createdAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    name: string
    email: string
    subject: string | null
    message: string
    privacyConsent: boolean
    userCognitoId: string | null
    createdAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    privacyConsent?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    user?: boolean | Contact$userArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    privacyConsent?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    user?: boolean | Contact$userArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    privacyConsent?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
    user?: boolean | Contact$userArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    privacyConsent?: boolean
    userCognitoId?: boolean
    createdAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "subject" | "message" | "privacyConsent" | "userCognitoId" | "createdAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Contact$userArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Contact$userArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Contact$userArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      subject: string | null
      message: string
      privacyConsent: boolean
      userCognitoId: string | null
      createdAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Contact$userArgs<ExtArgs> = {}>(args?: Subset<T, Contact$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Int'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly subject: FieldRef<"Contact", 'String'>
    readonly message: FieldRef<"Contact", 'String'>
    readonly privacyConsent: FieldRef<"Contact", 'Boolean'>
    readonly userCognitoId: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.user
   */
  export type Contact$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _avg: FavoriteAvgAggregateOutputType | null
    _sum: FavoriteSumAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteAvgAggregateOutputType = {
    id: number | null
    stocksId: number | null
  }

  export type FavoriteSumAggregateOutputType = {
    id: number | null
    stocksId: number | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: number | null
    userCognitoId: string | null
    stocksId: number | null
    createdAt: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: number | null
    userCognitoId: string | null
    stocksId: number | null
    createdAt: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    userCognitoId: number
    stocksId: number
    createdAt: number
    _all: number
  }


  export type FavoriteAvgAggregateInputType = {
    id?: true
    stocksId?: true
  }

  export type FavoriteSumAggregateInputType = {
    id?: true
    stocksId?: true
  }

  export type FavoriteMinAggregateInputType = {
    id?: true
    userCognitoId?: true
    stocksId?: true
    createdAt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    userCognitoId?: true
    stocksId?: true
    createdAt?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    userCognitoId?: true
    stocksId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _avg?: FavoriteAvgAggregateInputType
    _sum?: FavoriteSumAggregateInputType
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: number
    userCognitoId: string
    stocksId: number | null
    createdAt: Date
    _count: FavoriteCountAggregateOutputType | null
    _avg: FavoriteAvgAggregateOutputType | null
    _sum: FavoriteSumAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCognitoId?: boolean
    stocksId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stocks?: boolean | Favorite$stocksArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCognitoId?: boolean
    stocksId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stocks?: boolean | Favorite$stocksArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCognitoId?: boolean
    stocksId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stocks?: boolean | Favorite$stocksArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    userCognitoId?: boolean
    stocksId?: boolean
    createdAt?: boolean
  }

  export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userCognitoId" | "stocksId" | "createdAt", ExtArgs["result"]["favorite"]>
  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stocks?: boolean | Favorite$stocksArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stocks?: boolean | Favorite$stocksArgs<ExtArgs>
  }
  export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stocks?: boolean | Favorite$stocksArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      stocks: Prisma.$StocksPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userCognitoId: string
      stocksId: number | null
      createdAt: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites and returns the data updated in the database.
     * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stocks<T extends Favorite$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Favorite$stocksArgs<ExtArgs>>): Prisma__StocksClient<$Result.GetResult<Prisma.$StocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'Int'>
    readonly userCognitoId: FieldRef<"Favorite", 'String'>
    readonly stocksId: FieldRef<"Favorite", 'Int'>
    readonly createdAt: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorite updateManyAndReturn
   */
  export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorite.stocks
   */
  export type Favorite$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stocks
     */
    select?: StocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stocks
     */
    omit?: StocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StocksInclude<ExtArgs> | null
    where?: StocksWhereInput
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    adminCognitoId: 'adminCognitoId',
    name: 'name',
    email: 'email',
    phoneNumber: 'phoneNumber'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    userCognitoId: 'userCognitoId',
    name: 'name',
    email: 'email',
    role: 'role',
    phoneNumber: 'phoneNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CatalogScalarFieldEnum: {
    id: 'id',
    broker: 'broker',
    lotNo: 'lotNo',
    sellingMark: 'sellingMark',
    grade: 'grade',
    invoiceNo: 'invoiceNo',
    saleCode: 'saleCode',
    category: 'category',
    reprint: 'reprint',
    bags: 'bags',
    netWeight: 'netWeight',
    totalWeight: 'totalWeight',
    askingPrice: 'askingPrice',
    producerCountry: 'producerCountry',
    manufactureDate: 'manufactureDate',
    adminCognitoId: 'adminCognitoId',
    userCognitoId: 'userCognitoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogScalarFieldEnum = (typeof CatalogScalarFieldEnum)[keyof typeof CatalogScalarFieldEnum]


  export const SellingPriceScalarFieldEnum: {
    id: 'id',
    broker: 'broker',
    lotNo: 'lotNo',
    sellingMark: 'sellingMark',
    grade: 'grade',
    invoiceNo: 'invoiceNo',
    saleCode: 'saleCode',
    category: 'category',
    reprint: 'reprint',
    bags: 'bags',
    netWeight: 'netWeight',
    totalWeight: 'totalWeight',
    askingPrice: 'askingPrice',
    purchasePrice: 'purchasePrice',
    producerCountry: 'producerCountry',
    manufactureDate: 'manufactureDate',
    adminCognitoId: 'adminCognitoId',
    userCognitoId: 'userCognitoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellingPriceScalarFieldEnum = (typeof SellingPriceScalarFieldEnum)[keyof typeof SellingPriceScalarFieldEnum]


  export const OutLotsScalarFieldEnum: {
    id: 'id',
    auction: 'auction',
    lotNo: 'lotNo',
    broker: 'broker',
    sellingMark: 'sellingMark',
    grade: 'grade',
    invoiceNo: 'invoiceNo',
    bags: 'bags',
    netWeight: 'netWeight',
    totalWeight: 'totalWeight',
    baselinePrice: 'baselinePrice',
    manufactureDate: 'manufactureDate',
    adminCognitoId: 'adminCognitoId',
    userCognitoId: 'userCognitoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutLotsScalarFieldEnum = (typeof OutLotsScalarFieldEnum)[keyof typeof OutLotsScalarFieldEnum]


  export const StocksScalarFieldEnum: {
    id: 'id',
    saleCode: 'saleCode',
    broker: 'broker',
    lotNo: 'lotNo',
    mark: 'mark',
    grade: 'grade',
    invoiceNo: 'invoiceNo',
    bags: 'bags',
    weight: 'weight',
    purchaseValue: 'purchaseValue',
    totalPurchaseValue: 'totalPurchaseValue',
    agingDays: 'agingDays',
    penalty: 'penalty',
    bgtCommission: 'bgtCommission',
    maerskFee: 'maerskFee',
    commission: 'commission',
    netPrice: 'netPrice',
    total: 'total',
    batchNumber: 'batchNumber',
    lowStockThreshold: 'lowStockThreshold',
    adminCognitoId: 'adminCognitoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StocksScalarFieldEnum = (typeof StocksScalarFieldEnum)[keyof typeof StocksScalarFieldEnum]


  export const StockAssignmentScalarFieldEnum: {
    id: 'id',
    stocksId: 'stocksId',
    userCognitoId: 'userCognitoId',
    assignedWeight: 'assignedWeight',
    assignedAt: 'assignedAt'
  };

  export type StockAssignmentScalarFieldEnum = (typeof StockAssignmentScalarFieldEnum)[keyof typeof StockAssignmentScalarFieldEnum]


  export const ShipmentScalarFieldEnum: {
    id: 'id',
    shipmentDate: 'shipmentDate',
    status: 'status',
    userCognitoId: 'userCognitoId',
    adminCognitoId: 'adminCognitoId',
    consignee: 'consignee',
    vessel: 'vessel',
    shipmark: 'shipmark',
    packagingInstructions: 'packagingInstructions',
    additionalInstructions: 'additionalInstructions',
    createdAt: 'createdAt'
  };

  export type ShipmentScalarFieldEnum = (typeof ShipmentScalarFieldEnum)[keyof typeof ShipmentScalarFieldEnum]


  export const ShipmentItemScalarFieldEnum: {
    id: 'id',
    shipmentId: 'shipmentId',
    stocksId: 'stocksId',
    assignedWeight: 'assignedWeight'
  };

  export type ShipmentItemScalarFieldEnum = (typeof ShipmentItemScalarFieldEnum)[keyof typeof ShipmentItemScalarFieldEnum]


  export const StockHistoryScalarFieldEnum: {
    id: 'id',
    stocksId: 'stocksId',
    action: 'action',
    timestamp: 'timestamp',
    userCognitoId: 'userCognitoId',
    adminCognitoId: 'adminCognitoId',
    details: 'details',
    shipmentId: 'shipmentId'
  };

  export type StockHistoryScalarFieldEnum = (typeof StockHistoryScalarFieldEnum)[keyof typeof StockHistoryScalarFieldEnum]


  export const ShipmentHistoryScalarFieldEnum: {
    id: 'id',
    shipmentId: 'shipmentId',
    action: 'action',
    timestamp: 'timestamp',
    userCognitoId: 'userCognitoId',
    adminCognitoId: 'adminCognitoId',
    details: 'details'
  };

  export type ShipmentHistoryScalarFieldEnum = (typeof ShipmentHistoryScalarFieldEnum)[keyof typeof ShipmentHistoryScalarFieldEnum]


  export const AdminNotificationScalarFieldEnum: {
    id: 'id',
    adminCognitoId: 'adminCognitoId',
    message: 'message',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AdminNotificationScalarFieldEnum = (typeof AdminNotificationScalarFieldEnum)[keyof typeof AdminNotificationScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    privacyConsent: 'privacyConsent',
    userCognitoId: 'userCognitoId',
    createdAt: 'createdAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    userCognitoId: 'userCognitoId',
    stocksId: 'stocksId',
    createdAt: 'createdAt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Broker'
   */
  export type EnumBrokerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Broker'>
    


  /**
   * Reference to a field of type 'Broker[]'
   */
  export type ListEnumBrokerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Broker[]'>
    


  /**
   * Reference to a field of type 'TeaGrade'
   */
  export type EnumTeaGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeaGrade'>
    


  /**
   * Reference to a field of type 'TeaGrade[]'
   */
  export type ListEnumTeaGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeaGrade[]'>
    


  /**
   * Reference to a field of type 'TeaCategory'
   */
  export type EnumTeaCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeaCategory'>
    


  /**
   * Reference to a field of type 'TeaCategory[]'
   */
  export type ListEnumTeaCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeaCategory[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ShipmentStatus'
   */
  export type EnumShipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShipmentStatus'>
    


  /**
   * Reference to a field of type 'ShipmentStatus[]'
   */
  export type ListEnumShipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShipmentStatus[]'>
    


  /**
   * Reference to a field of type 'Vessel'
   */
  export type EnumVesselFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Vessel'>
    


  /**
   * Reference to a field of type 'Vessel[]'
   */
  export type ListEnumVesselFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Vessel[]'>
    


  /**
   * Reference to a field of type 'PackagingInstructions'
   */
  export type EnumPackagingInstructionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackagingInstructions'>
    


  /**
   * Reference to a field of type 'PackagingInstructions[]'
   */
  export type ListEnumPackagingInstructionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackagingInstructions[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    adminCognitoId?: StringFilter<"Admin"> | string
    name?: StringNullableFilter<"Admin"> | string | null
    email?: StringNullableFilter<"Admin"> | string | null
    phoneNumber?: StringNullableFilter<"Admin"> | string | null
    catalogs?: CatalogListRelationFilter
    stocks?: StocksListRelationFilter
    sellingPrices?: SellingPriceListRelationFilter
    outLots?: OutLotsListRelationFilter
    notifications?: AdminNotificationListRelationFilter
    shipments?: ShipmentListRelationFilter
    stockHistory?: StockHistoryListRelationFilter
    shipmentHistory?: ShipmentHistoryListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    catalogs?: CatalogOrderByRelationAggregateInput
    stocks?: StocksOrderByRelationAggregateInput
    sellingPrices?: SellingPriceOrderByRelationAggregateInput
    outLots?: OutLotsOrderByRelationAggregateInput
    notifications?: AdminNotificationOrderByRelationAggregateInput
    shipments?: ShipmentOrderByRelationAggregateInput
    stockHistory?: StockHistoryOrderByRelationAggregateInput
    shipmentHistory?: ShipmentHistoryOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    adminCognitoId?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringNullableFilter<"Admin"> | string | null
    phoneNumber?: StringNullableFilter<"Admin"> | string | null
    catalogs?: CatalogListRelationFilter
    stocks?: StocksListRelationFilter
    sellingPrices?: SellingPriceListRelationFilter
    outLots?: OutLotsListRelationFilter
    notifications?: AdminNotificationListRelationFilter
    shipments?: ShipmentListRelationFilter
    stockHistory?: StockHistoryListRelationFilter
    shipmentHistory?: ShipmentHistoryListRelationFilter
  }, "id" | "adminCognitoId" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    adminCognitoId?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    email?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    userCognitoId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    shipments?: ShipmentListRelationFilter
    stockHistory?: StockHistoryListRelationFilter
    shipmentHistory?: ShipmentHistoryListRelationFilter
    favorites?: FavoriteListRelationFilter
    assignments?: StockAssignmentListRelationFilter
    contacts?: ContactListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shipments?: ShipmentOrderByRelationAggregateInput
    stockHistory?: StockHistoryOrderByRelationAggregateInput
    shipmentHistory?: ShipmentHistoryOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    assignments?: StockAssignmentOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userCognitoId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    shipments?: ShipmentListRelationFilter
    stockHistory?: StockHistoryListRelationFilter
    shipmentHistory?: ShipmentHistoryListRelationFilter
    favorites?: FavoriteListRelationFilter
    assignments?: StockAssignmentListRelationFilter
    contacts?: ContactListRelationFilter
  }, "id" | "userCognitoId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    userCognitoId?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CatalogWhereInput = {
    AND?: CatalogWhereInput | CatalogWhereInput[]
    OR?: CatalogWhereInput[]
    NOT?: CatalogWhereInput | CatalogWhereInput[]
    id?: IntFilter<"Catalog"> | number
    broker?: EnumBrokerFilter<"Catalog"> | $Enums.Broker
    lotNo?: StringFilter<"Catalog"> | string
    sellingMark?: StringFilter<"Catalog"> | string
    grade?: EnumTeaGradeFilter<"Catalog"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"Catalog"> | string
    saleCode?: StringFilter<"Catalog"> | string
    category?: EnumTeaCategoryFilter<"Catalog"> | $Enums.TeaCategory
    reprint?: StringFilter<"Catalog"> | string
    bags?: IntFilter<"Catalog"> | number
    netWeight?: FloatFilter<"Catalog"> | number
    totalWeight?: FloatFilter<"Catalog"> | number
    askingPrice?: FloatFilter<"Catalog"> | number
    producerCountry?: StringNullableFilter<"Catalog"> | string | null
    manufactureDate?: DateTimeFilter<"Catalog"> | Date | string
    adminCognitoId?: StringNullableFilter<"Catalog"> | string | null
    userCognitoId?: StringNullableFilter<"Catalog"> | string | null
    createdAt?: DateTimeFilter<"Catalog"> | Date | string
    updatedAt?: DateTimeFilter<"Catalog"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type CatalogOrderByWithRelationInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    producerCountry?: SortOrderInput | SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type CatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lotNo?: string
    AND?: CatalogWhereInput | CatalogWhereInput[]
    OR?: CatalogWhereInput[]
    NOT?: CatalogWhereInput | CatalogWhereInput[]
    broker?: EnumBrokerFilter<"Catalog"> | $Enums.Broker
    sellingMark?: StringFilter<"Catalog"> | string
    grade?: EnumTeaGradeFilter<"Catalog"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"Catalog"> | string
    saleCode?: StringFilter<"Catalog"> | string
    category?: EnumTeaCategoryFilter<"Catalog"> | $Enums.TeaCategory
    reprint?: StringFilter<"Catalog"> | string
    bags?: IntFilter<"Catalog"> | number
    netWeight?: FloatFilter<"Catalog"> | number
    totalWeight?: FloatFilter<"Catalog"> | number
    askingPrice?: FloatFilter<"Catalog"> | number
    producerCountry?: StringNullableFilter<"Catalog"> | string | null
    manufactureDate?: DateTimeFilter<"Catalog"> | Date | string
    adminCognitoId?: StringNullableFilter<"Catalog"> | string | null
    userCognitoId?: StringNullableFilter<"Catalog"> | string | null
    createdAt?: DateTimeFilter<"Catalog"> | Date | string
    updatedAt?: DateTimeFilter<"Catalog"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id" | "lotNo">

  export type CatalogOrderByWithAggregationInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    producerCountry?: SortOrderInput | SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogCountOrderByAggregateInput
    _avg?: CatalogAvgOrderByAggregateInput
    _max?: CatalogMaxOrderByAggregateInput
    _min?: CatalogMinOrderByAggregateInput
    _sum?: CatalogSumOrderByAggregateInput
  }

  export type CatalogScalarWhereWithAggregatesInput = {
    AND?: CatalogScalarWhereWithAggregatesInput | CatalogScalarWhereWithAggregatesInput[]
    OR?: CatalogScalarWhereWithAggregatesInput[]
    NOT?: CatalogScalarWhereWithAggregatesInput | CatalogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Catalog"> | number
    broker?: EnumBrokerWithAggregatesFilter<"Catalog"> | $Enums.Broker
    lotNo?: StringWithAggregatesFilter<"Catalog"> | string
    sellingMark?: StringWithAggregatesFilter<"Catalog"> | string
    grade?: EnumTeaGradeWithAggregatesFilter<"Catalog"> | $Enums.TeaGrade
    invoiceNo?: StringWithAggregatesFilter<"Catalog"> | string
    saleCode?: StringWithAggregatesFilter<"Catalog"> | string
    category?: EnumTeaCategoryWithAggregatesFilter<"Catalog"> | $Enums.TeaCategory
    reprint?: StringWithAggregatesFilter<"Catalog"> | string
    bags?: IntWithAggregatesFilter<"Catalog"> | number
    netWeight?: FloatWithAggregatesFilter<"Catalog"> | number
    totalWeight?: FloatWithAggregatesFilter<"Catalog"> | number
    askingPrice?: FloatWithAggregatesFilter<"Catalog"> | number
    producerCountry?: StringNullableWithAggregatesFilter<"Catalog"> | string | null
    manufactureDate?: DateTimeWithAggregatesFilter<"Catalog"> | Date | string
    adminCognitoId?: StringNullableWithAggregatesFilter<"Catalog"> | string | null
    userCognitoId?: StringNullableWithAggregatesFilter<"Catalog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Catalog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Catalog"> | Date | string
  }

  export type SellingPriceWhereInput = {
    AND?: SellingPriceWhereInput | SellingPriceWhereInput[]
    OR?: SellingPriceWhereInput[]
    NOT?: SellingPriceWhereInput | SellingPriceWhereInput[]
    id?: IntFilter<"SellingPrice"> | number
    broker?: EnumBrokerFilter<"SellingPrice"> | $Enums.Broker
    lotNo?: StringFilter<"SellingPrice"> | string
    sellingMark?: StringFilter<"SellingPrice"> | string
    grade?: EnumTeaGradeFilter<"SellingPrice"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"SellingPrice"> | string
    saleCode?: StringFilter<"SellingPrice"> | string
    category?: EnumTeaCategoryFilter<"SellingPrice"> | $Enums.TeaCategory
    reprint?: StringFilter<"SellingPrice"> | string
    bags?: IntFilter<"SellingPrice"> | number
    netWeight?: FloatFilter<"SellingPrice"> | number
    totalWeight?: FloatFilter<"SellingPrice"> | number
    askingPrice?: FloatFilter<"SellingPrice"> | number
    purchasePrice?: FloatFilter<"SellingPrice"> | number
    producerCountry?: StringNullableFilter<"SellingPrice"> | string | null
    manufactureDate?: DateTimeFilter<"SellingPrice"> | Date | string
    adminCognitoId?: StringNullableFilter<"SellingPrice"> | string | null
    userCognitoId?: StringNullableFilter<"SellingPrice"> | string | null
    createdAt?: DateTimeFilter<"SellingPrice"> | Date | string
    updatedAt?: DateTimeFilter<"SellingPrice"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type SellingPriceOrderByWithRelationInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    purchasePrice?: SortOrder
    producerCountry?: SortOrderInput | SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type SellingPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lotNo?: string
    AND?: SellingPriceWhereInput | SellingPriceWhereInput[]
    OR?: SellingPriceWhereInput[]
    NOT?: SellingPriceWhereInput | SellingPriceWhereInput[]
    broker?: EnumBrokerFilter<"SellingPrice"> | $Enums.Broker
    sellingMark?: StringFilter<"SellingPrice"> | string
    grade?: EnumTeaGradeFilter<"SellingPrice"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"SellingPrice"> | string
    saleCode?: StringFilter<"SellingPrice"> | string
    category?: EnumTeaCategoryFilter<"SellingPrice"> | $Enums.TeaCategory
    reprint?: StringFilter<"SellingPrice"> | string
    bags?: IntFilter<"SellingPrice"> | number
    netWeight?: FloatFilter<"SellingPrice"> | number
    totalWeight?: FloatFilter<"SellingPrice"> | number
    askingPrice?: FloatFilter<"SellingPrice"> | number
    purchasePrice?: FloatFilter<"SellingPrice"> | number
    producerCountry?: StringNullableFilter<"SellingPrice"> | string | null
    manufactureDate?: DateTimeFilter<"SellingPrice"> | Date | string
    adminCognitoId?: StringNullableFilter<"SellingPrice"> | string | null
    userCognitoId?: StringNullableFilter<"SellingPrice"> | string | null
    createdAt?: DateTimeFilter<"SellingPrice"> | Date | string
    updatedAt?: DateTimeFilter<"SellingPrice"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id" | "lotNo">

  export type SellingPriceOrderByWithAggregationInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    purchasePrice?: SortOrder
    producerCountry?: SortOrderInput | SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellingPriceCountOrderByAggregateInput
    _avg?: SellingPriceAvgOrderByAggregateInput
    _max?: SellingPriceMaxOrderByAggregateInput
    _min?: SellingPriceMinOrderByAggregateInput
    _sum?: SellingPriceSumOrderByAggregateInput
  }

  export type SellingPriceScalarWhereWithAggregatesInput = {
    AND?: SellingPriceScalarWhereWithAggregatesInput | SellingPriceScalarWhereWithAggregatesInput[]
    OR?: SellingPriceScalarWhereWithAggregatesInput[]
    NOT?: SellingPriceScalarWhereWithAggregatesInput | SellingPriceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SellingPrice"> | number
    broker?: EnumBrokerWithAggregatesFilter<"SellingPrice"> | $Enums.Broker
    lotNo?: StringWithAggregatesFilter<"SellingPrice"> | string
    sellingMark?: StringWithAggregatesFilter<"SellingPrice"> | string
    grade?: EnumTeaGradeWithAggregatesFilter<"SellingPrice"> | $Enums.TeaGrade
    invoiceNo?: StringWithAggregatesFilter<"SellingPrice"> | string
    saleCode?: StringWithAggregatesFilter<"SellingPrice"> | string
    category?: EnumTeaCategoryWithAggregatesFilter<"SellingPrice"> | $Enums.TeaCategory
    reprint?: StringWithAggregatesFilter<"SellingPrice"> | string
    bags?: IntWithAggregatesFilter<"SellingPrice"> | number
    netWeight?: FloatWithAggregatesFilter<"SellingPrice"> | number
    totalWeight?: FloatWithAggregatesFilter<"SellingPrice"> | number
    askingPrice?: FloatWithAggregatesFilter<"SellingPrice"> | number
    purchasePrice?: FloatWithAggregatesFilter<"SellingPrice"> | number
    producerCountry?: StringNullableWithAggregatesFilter<"SellingPrice"> | string | null
    manufactureDate?: DateTimeWithAggregatesFilter<"SellingPrice"> | Date | string
    adminCognitoId?: StringNullableWithAggregatesFilter<"SellingPrice"> | string | null
    userCognitoId?: StringNullableWithAggregatesFilter<"SellingPrice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SellingPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellingPrice"> | Date | string
  }

  export type OutLotsWhereInput = {
    AND?: OutLotsWhereInput | OutLotsWhereInput[]
    OR?: OutLotsWhereInput[]
    NOT?: OutLotsWhereInput | OutLotsWhereInput[]
    id?: IntFilter<"OutLots"> | number
    auction?: StringFilter<"OutLots"> | string
    lotNo?: StringFilter<"OutLots"> | string
    broker?: EnumBrokerFilter<"OutLots"> | $Enums.Broker
    sellingMark?: StringFilter<"OutLots"> | string
    grade?: EnumTeaGradeFilter<"OutLots"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"OutLots"> | string
    bags?: IntFilter<"OutLots"> | number
    netWeight?: FloatFilter<"OutLots"> | number
    totalWeight?: FloatFilter<"OutLots"> | number
    baselinePrice?: FloatFilter<"OutLots"> | number
    manufactureDate?: DateTimeFilter<"OutLots"> | Date | string
    adminCognitoId?: StringNullableFilter<"OutLots"> | string | null
    userCognitoId?: StringNullableFilter<"OutLots"> | string | null
    createdAt?: DateTimeFilter<"OutLots"> | Date | string
    updatedAt?: DateTimeFilter<"OutLots"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type OutLotsOrderByWithRelationInput = {
    id?: SortOrder
    auction?: SortOrder
    lotNo?: SortOrder
    broker?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    baselinePrice?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type OutLotsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lotNo?: string
    AND?: OutLotsWhereInput | OutLotsWhereInput[]
    OR?: OutLotsWhereInput[]
    NOT?: OutLotsWhereInput | OutLotsWhereInput[]
    auction?: StringFilter<"OutLots"> | string
    broker?: EnumBrokerFilter<"OutLots"> | $Enums.Broker
    sellingMark?: StringFilter<"OutLots"> | string
    grade?: EnumTeaGradeFilter<"OutLots"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"OutLots"> | string
    bags?: IntFilter<"OutLots"> | number
    netWeight?: FloatFilter<"OutLots"> | number
    totalWeight?: FloatFilter<"OutLots"> | number
    baselinePrice?: FloatFilter<"OutLots"> | number
    manufactureDate?: DateTimeFilter<"OutLots"> | Date | string
    adminCognitoId?: StringNullableFilter<"OutLots"> | string | null
    userCognitoId?: StringNullableFilter<"OutLots"> | string | null
    createdAt?: DateTimeFilter<"OutLots"> | Date | string
    updatedAt?: DateTimeFilter<"OutLots"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id" | "lotNo">

  export type OutLotsOrderByWithAggregationInput = {
    id?: SortOrder
    auction?: SortOrder
    lotNo?: SortOrder
    broker?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    baselinePrice?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutLotsCountOrderByAggregateInput
    _avg?: OutLotsAvgOrderByAggregateInput
    _max?: OutLotsMaxOrderByAggregateInput
    _min?: OutLotsMinOrderByAggregateInput
    _sum?: OutLotsSumOrderByAggregateInput
  }

  export type OutLotsScalarWhereWithAggregatesInput = {
    AND?: OutLotsScalarWhereWithAggregatesInput | OutLotsScalarWhereWithAggregatesInput[]
    OR?: OutLotsScalarWhereWithAggregatesInput[]
    NOT?: OutLotsScalarWhereWithAggregatesInput | OutLotsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OutLots"> | number
    auction?: StringWithAggregatesFilter<"OutLots"> | string
    lotNo?: StringWithAggregatesFilter<"OutLots"> | string
    broker?: EnumBrokerWithAggregatesFilter<"OutLots"> | $Enums.Broker
    sellingMark?: StringWithAggregatesFilter<"OutLots"> | string
    grade?: EnumTeaGradeWithAggregatesFilter<"OutLots"> | $Enums.TeaGrade
    invoiceNo?: StringWithAggregatesFilter<"OutLots"> | string
    bags?: IntWithAggregatesFilter<"OutLots"> | number
    netWeight?: FloatWithAggregatesFilter<"OutLots"> | number
    totalWeight?: FloatWithAggregatesFilter<"OutLots"> | number
    baselinePrice?: FloatWithAggregatesFilter<"OutLots"> | number
    manufactureDate?: DateTimeWithAggregatesFilter<"OutLots"> | Date | string
    adminCognitoId?: StringNullableWithAggregatesFilter<"OutLots"> | string | null
    userCognitoId?: StringNullableWithAggregatesFilter<"OutLots"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OutLots"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutLots"> | Date | string
  }

  export type StocksWhereInput = {
    AND?: StocksWhereInput | StocksWhereInput[]
    OR?: StocksWhereInput[]
    NOT?: StocksWhereInput | StocksWhereInput[]
    id?: IntFilter<"Stocks"> | number
    saleCode?: StringFilter<"Stocks"> | string
    broker?: EnumBrokerFilter<"Stocks"> | $Enums.Broker
    lotNo?: StringFilter<"Stocks"> | string
    mark?: StringFilter<"Stocks"> | string
    grade?: EnumTeaGradeFilter<"Stocks"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"Stocks"> | string
    bags?: IntFilter<"Stocks"> | number
    weight?: FloatFilter<"Stocks"> | number
    purchaseValue?: FloatFilter<"Stocks"> | number
    totalPurchaseValue?: FloatFilter<"Stocks"> | number
    agingDays?: IntFilter<"Stocks"> | number
    penalty?: FloatFilter<"Stocks"> | number
    bgtCommission?: FloatFilter<"Stocks"> | number
    maerskFee?: FloatFilter<"Stocks"> | number
    commission?: FloatFilter<"Stocks"> | number
    netPrice?: FloatFilter<"Stocks"> | number
    total?: FloatFilter<"Stocks"> | number
    batchNumber?: StringNullableFilter<"Stocks"> | string | null
    lowStockThreshold?: FloatNullableFilter<"Stocks"> | number | null
    adminCognitoId?: StringFilter<"Stocks"> | string
    createdAt?: DateTimeFilter<"Stocks"> | Date | string
    updatedAt?: DateTimeFilter<"Stocks"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    assignments?: StockAssignmentListRelationFilter
    shipmentItems?: ShipmentItemListRelationFilter
    history?: StockHistoryListRelationFilter
    favorites?: FavoriteListRelationFilter
  }

  export type StocksOrderByWithRelationInput = {
    id?: SortOrder
    saleCode?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    mark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    weight?: SortOrder
    purchaseValue?: SortOrder
    totalPurchaseValue?: SortOrder
    agingDays?: SortOrder
    penalty?: SortOrder
    bgtCommission?: SortOrder
    maerskFee?: SortOrder
    commission?: SortOrder
    netPrice?: SortOrder
    total?: SortOrder
    batchNumber?: SortOrderInput | SortOrder
    lowStockThreshold?: SortOrderInput | SortOrder
    adminCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    assignments?: StockAssignmentOrderByRelationAggregateInput
    shipmentItems?: ShipmentItemOrderByRelationAggregateInput
    history?: StockHistoryOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
  }

  export type StocksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lotNo?: string
    AND?: StocksWhereInput | StocksWhereInput[]
    OR?: StocksWhereInput[]
    NOT?: StocksWhereInput | StocksWhereInput[]
    saleCode?: StringFilter<"Stocks"> | string
    broker?: EnumBrokerFilter<"Stocks"> | $Enums.Broker
    mark?: StringFilter<"Stocks"> | string
    grade?: EnumTeaGradeFilter<"Stocks"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"Stocks"> | string
    bags?: IntFilter<"Stocks"> | number
    weight?: FloatFilter<"Stocks"> | number
    purchaseValue?: FloatFilter<"Stocks"> | number
    totalPurchaseValue?: FloatFilter<"Stocks"> | number
    agingDays?: IntFilter<"Stocks"> | number
    penalty?: FloatFilter<"Stocks"> | number
    bgtCommission?: FloatFilter<"Stocks"> | number
    maerskFee?: FloatFilter<"Stocks"> | number
    commission?: FloatFilter<"Stocks"> | number
    netPrice?: FloatFilter<"Stocks"> | number
    total?: FloatFilter<"Stocks"> | number
    batchNumber?: StringNullableFilter<"Stocks"> | string | null
    lowStockThreshold?: FloatNullableFilter<"Stocks"> | number | null
    adminCognitoId?: StringFilter<"Stocks"> | string
    createdAt?: DateTimeFilter<"Stocks"> | Date | string
    updatedAt?: DateTimeFilter<"Stocks"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    assignments?: StockAssignmentListRelationFilter
    shipmentItems?: ShipmentItemListRelationFilter
    history?: StockHistoryListRelationFilter
    favorites?: FavoriteListRelationFilter
  }, "id" | "lotNo">

  export type StocksOrderByWithAggregationInput = {
    id?: SortOrder
    saleCode?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    mark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    weight?: SortOrder
    purchaseValue?: SortOrder
    totalPurchaseValue?: SortOrder
    agingDays?: SortOrder
    penalty?: SortOrder
    bgtCommission?: SortOrder
    maerskFee?: SortOrder
    commission?: SortOrder
    netPrice?: SortOrder
    total?: SortOrder
    batchNumber?: SortOrderInput | SortOrder
    lowStockThreshold?: SortOrderInput | SortOrder
    adminCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StocksCountOrderByAggregateInput
    _avg?: StocksAvgOrderByAggregateInput
    _max?: StocksMaxOrderByAggregateInput
    _min?: StocksMinOrderByAggregateInput
    _sum?: StocksSumOrderByAggregateInput
  }

  export type StocksScalarWhereWithAggregatesInput = {
    AND?: StocksScalarWhereWithAggregatesInput | StocksScalarWhereWithAggregatesInput[]
    OR?: StocksScalarWhereWithAggregatesInput[]
    NOT?: StocksScalarWhereWithAggregatesInput | StocksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stocks"> | number
    saleCode?: StringWithAggregatesFilter<"Stocks"> | string
    broker?: EnumBrokerWithAggregatesFilter<"Stocks"> | $Enums.Broker
    lotNo?: StringWithAggregatesFilter<"Stocks"> | string
    mark?: StringWithAggregatesFilter<"Stocks"> | string
    grade?: EnumTeaGradeWithAggregatesFilter<"Stocks"> | $Enums.TeaGrade
    invoiceNo?: StringWithAggregatesFilter<"Stocks"> | string
    bags?: IntWithAggregatesFilter<"Stocks"> | number
    weight?: FloatWithAggregatesFilter<"Stocks"> | number
    purchaseValue?: FloatWithAggregatesFilter<"Stocks"> | number
    totalPurchaseValue?: FloatWithAggregatesFilter<"Stocks"> | number
    agingDays?: IntWithAggregatesFilter<"Stocks"> | number
    penalty?: FloatWithAggregatesFilter<"Stocks"> | number
    bgtCommission?: FloatWithAggregatesFilter<"Stocks"> | number
    maerskFee?: FloatWithAggregatesFilter<"Stocks"> | number
    commission?: FloatWithAggregatesFilter<"Stocks"> | number
    netPrice?: FloatWithAggregatesFilter<"Stocks"> | number
    total?: FloatWithAggregatesFilter<"Stocks"> | number
    batchNumber?: StringNullableWithAggregatesFilter<"Stocks"> | string | null
    lowStockThreshold?: FloatNullableWithAggregatesFilter<"Stocks"> | number | null
    adminCognitoId?: StringWithAggregatesFilter<"Stocks"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Stocks"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stocks"> | Date | string
  }

  export type StockAssignmentWhereInput = {
    AND?: StockAssignmentWhereInput | StockAssignmentWhereInput[]
    OR?: StockAssignmentWhereInput[]
    NOT?: StockAssignmentWhereInput | StockAssignmentWhereInput[]
    id?: IntFilter<"StockAssignment"> | number
    stocksId?: IntFilter<"StockAssignment"> | number
    userCognitoId?: StringFilter<"StockAssignment"> | string
    assignedWeight?: FloatFilter<"StockAssignment"> | number
    assignedAt?: DateTimeFilter<"StockAssignment"> | Date | string
    stocks?: XOR<StocksScalarRelationFilter, StocksWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StockAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    stocksId?: SortOrder
    userCognitoId?: SortOrder
    assignedWeight?: SortOrder
    assignedAt?: SortOrder
    stocks?: StocksOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StockAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stocksId_userCognitoId?: StockAssignmentStocksIdUserCognitoIdCompoundUniqueInput
    AND?: StockAssignmentWhereInput | StockAssignmentWhereInput[]
    OR?: StockAssignmentWhereInput[]
    NOT?: StockAssignmentWhereInput | StockAssignmentWhereInput[]
    stocksId?: IntFilter<"StockAssignment"> | number
    userCognitoId?: StringFilter<"StockAssignment"> | string
    assignedWeight?: FloatFilter<"StockAssignment"> | number
    assignedAt?: DateTimeFilter<"StockAssignment"> | Date | string
    stocks?: XOR<StocksScalarRelationFilter, StocksWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "stocksId_userCognitoId">

  export type StockAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    stocksId?: SortOrder
    userCognitoId?: SortOrder
    assignedWeight?: SortOrder
    assignedAt?: SortOrder
    _count?: StockAssignmentCountOrderByAggregateInput
    _avg?: StockAssignmentAvgOrderByAggregateInput
    _max?: StockAssignmentMaxOrderByAggregateInput
    _min?: StockAssignmentMinOrderByAggregateInput
    _sum?: StockAssignmentSumOrderByAggregateInput
  }

  export type StockAssignmentScalarWhereWithAggregatesInput = {
    AND?: StockAssignmentScalarWhereWithAggregatesInput | StockAssignmentScalarWhereWithAggregatesInput[]
    OR?: StockAssignmentScalarWhereWithAggregatesInput[]
    NOT?: StockAssignmentScalarWhereWithAggregatesInput | StockAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockAssignment"> | number
    stocksId?: IntWithAggregatesFilter<"StockAssignment"> | number
    userCognitoId?: StringWithAggregatesFilter<"StockAssignment"> | string
    assignedWeight?: FloatWithAggregatesFilter<"StockAssignment"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"StockAssignment"> | Date | string
  }

  export type ShipmentWhereInput = {
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    id?: IntFilter<"Shipment"> | number
    shipmentDate?: DateTimeFilter<"Shipment"> | Date | string
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    userCognitoId?: StringFilter<"Shipment"> | string
    adminCognitoId?: StringNullableFilter<"Shipment"> | string | null
    consignee?: StringFilter<"Shipment"> | string
    vessel?: EnumVesselFilter<"Shipment"> | $Enums.Vessel
    shipmark?: StringFilter<"Shipment"> | string
    packagingInstructions?: EnumPackagingInstructionsFilter<"Shipment"> | $Enums.PackagingInstructions
    additionalInstructions?: StringNullableFilter<"Shipment"> | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    historyEntries?: ShipmentHistoryListRelationFilter
    stockHistory?: StockHistoryListRelationFilter
    stocks?: ShipmentItemListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type ShipmentOrderByWithRelationInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    status?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    consignee?: SortOrder
    vessel?: SortOrder
    shipmark?: SortOrder
    packagingInstructions?: SortOrder
    additionalInstructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    historyEntries?: ShipmentHistoryOrderByRelationAggregateInput
    stockHistory?: StockHistoryOrderByRelationAggregateInput
    stocks?: ShipmentItemOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type ShipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shipmark?: string
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    shipmentDate?: DateTimeFilter<"Shipment"> | Date | string
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    userCognitoId?: StringFilter<"Shipment"> | string
    adminCognitoId?: StringNullableFilter<"Shipment"> | string | null
    consignee?: StringFilter<"Shipment"> | string
    vessel?: EnumVesselFilter<"Shipment"> | $Enums.Vessel
    packagingInstructions?: EnumPackagingInstructionsFilter<"Shipment"> | $Enums.PackagingInstructions
    additionalInstructions?: StringNullableFilter<"Shipment"> | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    historyEntries?: ShipmentHistoryListRelationFilter
    stockHistory?: StockHistoryListRelationFilter
    stocks?: ShipmentItemListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id" | "shipmark">

  export type ShipmentOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    status?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    consignee?: SortOrder
    vessel?: SortOrder
    shipmark?: SortOrder
    packagingInstructions?: SortOrder
    additionalInstructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ShipmentCountOrderByAggregateInput
    _avg?: ShipmentAvgOrderByAggregateInput
    _max?: ShipmentMaxOrderByAggregateInput
    _min?: ShipmentMinOrderByAggregateInput
    _sum?: ShipmentSumOrderByAggregateInput
  }

  export type ShipmentScalarWhereWithAggregatesInput = {
    AND?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    OR?: ShipmentScalarWhereWithAggregatesInput[]
    NOT?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shipment"> | number
    shipmentDate?: DateTimeWithAggregatesFilter<"Shipment"> | Date | string
    status?: EnumShipmentStatusWithAggregatesFilter<"Shipment"> | $Enums.ShipmentStatus
    userCognitoId?: StringWithAggregatesFilter<"Shipment"> | string
    adminCognitoId?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    consignee?: StringWithAggregatesFilter<"Shipment"> | string
    vessel?: EnumVesselWithAggregatesFilter<"Shipment"> | $Enums.Vessel
    shipmark?: StringWithAggregatesFilter<"Shipment"> | string
    packagingInstructions?: EnumPackagingInstructionsWithAggregatesFilter<"Shipment"> | $Enums.PackagingInstructions
    additionalInstructions?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shipment"> | Date | string
  }

  export type ShipmentItemWhereInput = {
    AND?: ShipmentItemWhereInput | ShipmentItemWhereInput[]
    OR?: ShipmentItemWhereInput[]
    NOT?: ShipmentItemWhereInput | ShipmentItemWhereInput[]
    id?: IntFilter<"ShipmentItem"> | number
    shipmentId?: IntFilter<"ShipmentItem"> | number
    stocksId?: IntFilter<"ShipmentItem"> | number
    assignedWeight?: FloatFilter<"ShipmentItem"> | number
    shipment?: XOR<ShipmentScalarRelationFilter, ShipmentWhereInput>
    stocks?: XOR<StocksScalarRelationFilter, StocksWhereInput>
  }

  export type ShipmentItemOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
    shipment?: ShipmentOrderByWithRelationInput
    stocks?: StocksOrderByWithRelationInput
  }

  export type ShipmentItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shipmentId_stocksId?: ShipmentItemShipmentIdStocksIdCompoundUniqueInput
    AND?: ShipmentItemWhereInput | ShipmentItemWhereInput[]
    OR?: ShipmentItemWhereInput[]
    NOT?: ShipmentItemWhereInput | ShipmentItemWhereInput[]
    shipmentId?: IntFilter<"ShipmentItem"> | number
    stocksId?: IntFilter<"ShipmentItem"> | number
    assignedWeight?: FloatFilter<"ShipmentItem"> | number
    shipment?: XOR<ShipmentScalarRelationFilter, ShipmentWhereInput>
    stocks?: XOR<StocksScalarRelationFilter, StocksWhereInput>
  }, "id" | "shipmentId_stocksId">

  export type ShipmentItemOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
    _count?: ShipmentItemCountOrderByAggregateInput
    _avg?: ShipmentItemAvgOrderByAggregateInput
    _max?: ShipmentItemMaxOrderByAggregateInput
    _min?: ShipmentItemMinOrderByAggregateInput
    _sum?: ShipmentItemSumOrderByAggregateInput
  }

  export type ShipmentItemScalarWhereWithAggregatesInput = {
    AND?: ShipmentItemScalarWhereWithAggregatesInput | ShipmentItemScalarWhereWithAggregatesInput[]
    OR?: ShipmentItemScalarWhereWithAggregatesInput[]
    NOT?: ShipmentItemScalarWhereWithAggregatesInput | ShipmentItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShipmentItem"> | number
    shipmentId?: IntWithAggregatesFilter<"ShipmentItem"> | number
    stocksId?: IntWithAggregatesFilter<"ShipmentItem"> | number
    assignedWeight?: FloatWithAggregatesFilter<"ShipmentItem"> | number
  }

  export type StockHistoryWhereInput = {
    AND?: StockHistoryWhereInput | StockHistoryWhereInput[]
    OR?: StockHistoryWhereInput[]
    NOT?: StockHistoryWhereInput | StockHistoryWhereInput[]
    id?: IntFilter<"StockHistory"> | number
    stocksId?: IntFilter<"StockHistory"> | number
    action?: StringFilter<"StockHistory"> | string
    timestamp?: DateTimeFilter<"StockHistory"> | Date | string
    userCognitoId?: StringNullableFilter<"StockHistory"> | string | null
    adminCognitoId?: StringNullableFilter<"StockHistory"> | string | null
    details?: JsonNullableFilter<"StockHistory">
    shipmentId?: IntNullableFilter<"StockHistory"> | number | null
    stocks?: XOR<StocksScalarRelationFilter, StocksWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    shipment?: XOR<ShipmentNullableScalarRelationFilter, ShipmentWhereInput> | null
  }

  export type StockHistoryOrderByWithRelationInput = {
    id?: SortOrder
    stocksId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    shipmentId?: SortOrderInput | SortOrder
    stocks?: StocksOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
  }

  export type StockHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StockHistoryWhereInput | StockHistoryWhereInput[]
    OR?: StockHistoryWhereInput[]
    NOT?: StockHistoryWhereInput | StockHistoryWhereInput[]
    stocksId?: IntFilter<"StockHistory"> | number
    action?: StringFilter<"StockHistory"> | string
    timestamp?: DateTimeFilter<"StockHistory"> | Date | string
    userCognitoId?: StringNullableFilter<"StockHistory"> | string | null
    adminCognitoId?: StringNullableFilter<"StockHistory"> | string | null
    details?: JsonNullableFilter<"StockHistory">
    shipmentId?: IntNullableFilter<"StockHistory"> | number | null
    stocks?: XOR<StocksScalarRelationFilter, StocksWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    shipment?: XOR<ShipmentNullableScalarRelationFilter, ShipmentWhereInput> | null
  }, "id">

  export type StockHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    stocksId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    shipmentId?: SortOrderInput | SortOrder
    _count?: StockHistoryCountOrderByAggregateInput
    _avg?: StockHistoryAvgOrderByAggregateInput
    _max?: StockHistoryMaxOrderByAggregateInput
    _min?: StockHistoryMinOrderByAggregateInput
    _sum?: StockHistorySumOrderByAggregateInput
  }

  export type StockHistoryScalarWhereWithAggregatesInput = {
    AND?: StockHistoryScalarWhereWithAggregatesInput | StockHistoryScalarWhereWithAggregatesInput[]
    OR?: StockHistoryScalarWhereWithAggregatesInput[]
    NOT?: StockHistoryScalarWhereWithAggregatesInput | StockHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockHistory"> | number
    stocksId?: IntWithAggregatesFilter<"StockHistory"> | number
    action?: StringWithAggregatesFilter<"StockHistory"> | string
    timestamp?: DateTimeWithAggregatesFilter<"StockHistory"> | Date | string
    userCognitoId?: StringNullableWithAggregatesFilter<"StockHistory"> | string | null
    adminCognitoId?: StringNullableWithAggregatesFilter<"StockHistory"> | string | null
    details?: JsonNullableWithAggregatesFilter<"StockHistory">
    shipmentId?: IntNullableWithAggregatesFilter<"StockHistory"> | number | null
  }

  export type ShipmentHistoryWhereInput = {
    AND?: ShipmentHistoryWhereInput | ShipmentHistoryWhereInput[]
    OR?: ShipmentHistoryWhereInput[]
    NOT?: ShipmentHistoryWhereInput | ShipmentHistoryWhereInput[]
    id?: IntFilter<"ShipmentHistory"> | number
    shipmentId?: IntFilter<"ShipmentHistory"> | number
    action?: StringFilter<"ShipmentHistory"> | string
    timestamp?: DateTimeFilter<"ShipmentHistory"> | Date | string
    userCognitoId?: StringNullableFilter<"ShipmentHistory"> | string | null
    adminCognitoId?: StringNullableFilter<"ShipmentHistory"> | string | null
    details?: JsonNullableFilter<"ShipmentHistory">
    shipment?: XOR<ShipmentScalarRelationFilter, ShipmentWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type ShipmentHistoryOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    shipment?: ShipmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type ShipmentHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShipmentHistoryWhereInput | ShipmentHistoryWhereInput[]
    OR?: ShipmentHistoryWhereInput[]
    NOT?: ShipmentHistoryWhereInput | ShipmentHistoryWhereInput[]
    shipmentId?: IntFilter<"ShipmentHistory"> | number
    action?: StringFilter<"ShipmentHistory"> | string
    timestamp?: DateTimeFilter<"ShipmentHistory"> | Date | string
    userCognitoId?: StringNullableFilter<"ShipmentHistory"> | string | null
    adminCognitoId?: StringNullableFilter<"ShipmentHistory"> | string | null
    details?: JsonNullableFilter<"ShipmentHistory">
    shipment?: XOR<ShipmentScalarRelationFilter, ShipmentWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id">

  export type ShipmentHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    adminCognitoId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    _count?: ShipmentHistoryCountOrderByAggregateInput
    _avg?: ShipmentHistoryAvgOrderByAggregateInput
    _max?: ShipmentHistoryMaxOrderByAggregateInput
    _min?: ShipmentHistoryMinOrderByAggregateInput
    _sum?: ShipmentHistorySumOrderByAggregateInput
  }

  export type ShipmentHistoryScalarWhereWithAggregatesInput = {
    AND?: ShipmentHistoryScalarWhereWithAggregatesInput | ShipmentHistoryScalarWhereWithAggregatesInput[]
    OR?: ShipmentHistoryScalarWhereWithAggregatesInput[]
    NOT?: ShipmentHistoryScalarWhereWithAggregatesInput | ShipmentHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShipmentHistory"> | number
    shipmentId?: IntWithAggregatesFilter<"ShipmentHistory"> | number
    action?: StringWithAggregatesFilter<"ShipmentHistory"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ShipmentHistory"> | Date | string
    userCognitoId?: StringNullableWithAggregatesFilter<"ShipmentHistory"> | string | null
    adminCognitoId?: StringNullableWithAggregatesFilter<"ShipmentHistory"> | string | null
    details?: JsonNullableWithAggregatesFilter<"ShipmentHistory">
  }

  export type AdminNotificationWhereInput = {
    AND?: AdminNotificationWhereInput | AdminNotificationWhereInput[]
    OR?: AdminNotificationWhereInput[]
    NOT?: AdminNotificationWhereInput | AdminNotificationWhereInput[]
    id?: IntFilter<"AdminNotification"> | number
    adminCognitoId?: StringFilter<"AdminNotification"> | string
    message?: StringFilter<"AdminNotification"> | string
    details?: JsonFilter<"AdminNotification">
    createdAt?: DateTimeFilter<"AdminNotification"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminNotificationOrderByWithRelationInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    message?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type AdminNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminNotificationWhereInput | AdminNotificationWhereInput[]
    OR?: AdminNotificationWhereInput[]
    NOT?: AdminNotificationWhereInput | AdminNotificationWhereInput[]
    adminCognitoId?: StringFilter<"AdminNotification"> | string
    message?: StringFilter<"AdminNotification"> | string
    details?: JsonFilter<"AdminNotification">
    createdAt?: DateTimeFilter<"AdminNotification"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    message?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    _count?: AdminNotificationCountOrderByAggregateInput
    _avg?: AdminNotificationAvgOrderByAggregateInput
    _max?: AdminNotificationMaxOrderByAggregateInput
    _min?: AdminNotificationMinOrderByAggregateInput
    _sum?: AdminNotificationSumOrderByAggregateInput
  }

  export type AdminNotificationScalarWhereWithAggregatesInput = {
    AND?: AdminNotificationScalarWhereWithAggregatesInput | AdminNotificationScalarWhereWithAggregatesInput[]
    OR?: AdminNotificationScalarWhereWithAggregatesInput[]
    NOT?: AdminNotificationScalarWhereWithAggregatesInput | AdminNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminNotification"> | number
    adminCognitoId?: StringWithAggregatesFilter<"AdminNotification"> | string
    message?: StringWithAggregatesFilter<"AdminNotification"> | string
    details?: JsonWithAggregatesFilter<"AdminNotification">
    createdAt?: DateTimeWithAggregatesFilter<"AdminNotification"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: IntFilter<"Contact"> | number
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    subject?: StringNullableFilter<"Contact"> | string | null
    message?: StringFilter<"Contact"> | string
    privacyConsent?: BoolFilter<"Contact"> | boolean
    userCognitoId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    privacyConsent?: SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    subject?: StringNullableFilter<"Contact"> | string | null
    message?: StringFilter<"Contact"> | string
    privacyConsent?: BoolFilter<"Contact"> | boolean
    userCognitoId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    privacyConsent?: SortOrder
    userCognitoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact"> | number
    name?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    subject?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    message?: StringWithAggregatesFilter<"Contact"> | string
    privacyConsent?: BoolWithAggregatesFilter<"Contact"> | boolean
    userCognitoId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: IntFilter<"Favorite"> | number
    userCognitoId?: StringFilter<"Favorite"> | string
    stocksId?: IntNullableFilter<"Favorite"> | number | null
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    stocks?: XOR<StocksNullableScalarRelationFilter, StocksWhereInput> | null
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    stocksId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    stocks?: StocksOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_stocks_favorite?: FavoriteUser_stocks_favoriteCompoundUniqueInput
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userCognitoId?: StringFilter<"Favorite"> | string
    stocksId?: IntNullableFilter<"Favorite"> | number | null
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    stocks?: XOR<StocksNullableScalarRelationFilter, StocksWhereInput> | null
  }, "id" | "user_stocks_favorite">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    stocksId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _avg?: FavoriteAvgOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
    _sum?: FavoriteSumOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Favorite"> | number
    userCognitoId?: StringWithAggregatesFilter<"Favorite"> | string
    stocksId?: IntNullableWithAggregatesFilter<"Favorite"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type AdminCreateInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogCreateNestedManyWithoutAdminInput
    stocks?: StocksCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceCreateNestedManyWithoutAdminInput
    outLots?: OutLotsCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationCreateNestedManyWithoutAdminInput
    shipments?: ShipmentCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogUncheckedCreateNestedManyWithoutAdminInput
    stocks?: StocksUncheckedCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceUncheckedCreateNestedManyWithoutAdminInput
    outLots?: OutLotsUncheckedCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationUncheckedCreateNestedManyWithoutAdminInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUpdateManyWithoutAdminNestedInput
    stocks?: StocksUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUncheckedUpdateManyWithoutAdminNestedInput
    stocks?: StocksUncheckedUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUncheckedUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUncheckedUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
  }

  export type AdminUpdateManyMutationInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCreateInput = {
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutCatalogsInput
  }

  export type CatalogUncheckedCreateInput = {
    id?: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    adminCognitoId?: string | null
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogUpdateInput = {
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutCatalogsNestedInput
  }

  export type CatalogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCreateManyInput = {
    id?: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    adminCognitoId?: string | null
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogUpdateManyMutationInput = {
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPriceCreateInput = {
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    purchasePrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutSellingPricesInput
  }

  export type SellingPriceUncheckedCreateInput = {
    id?: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    purchasePrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    adminCognitoId?: string | null
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingPriceUpdateInput = {
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutSellingPricesNestedInput
  }

  export type SellingPriceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPriceCreateManyInput = {
    id?: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    purchasePrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    adminCognitoId?: string | null
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingPriceUpdateManyMutationInput = {
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPriceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutLotsCreateInput = {
    auction: string
    lotNo: string
    broker: $Enums.Broker
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    netWeight: number
    totalWeight: number
    baselinePrice: number
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutOutLotsInput
  }

  export type OutLotsUncheckedCreateInput = {
    id?: number
    auction: string
    lotNo: string
    broker: $Enums.Broker
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    netWeight: number
    totalWeight: number
    baselinePrice: number
    manufactureDate: Date | string
    adminCognitoId?: string | null
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutLotsUpdateInput = {
    auction?: StringFieldUpdateOperationsInput | string
    lotNo?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    baselinePrice?: FloatFieldUpdateOperationsInput | number
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutOutLotsNestedInput
  }

  export type OutLotsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    auction?: StringFieldUpdateOperationsInput | string
    lotNo?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    baselinePrice?: FloatFieldUpdateOperationsInput | number
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutLotsCreateManyInput = {
    id?: number
    auction: string
    lotNo: string
    broker: $Enums.Broker
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    netWeight: number
    totalWeight: number
    baselinePrice: number
    manufactureDate: Date | string
    adminCognitoId?: string | null
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutLotsUpdateManyMutationInput = {
    auction?: StringFieldUpdateOperationsInput | string
    lotNo?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    baselinePrice?: FloatFieldUpdateOperationsInput | number
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutLotsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    auction?: StringFieldUpdateOperationsInput | string
    lotNo?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    baselinePrice?: FloatFieldUpdateOperationsInput | number
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StocksCreateInput = {
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutStocksInput
    assignments?: StockAssignmentCreateNestedManyWithoutStocksInput
    shipmentItems?: ShipmentItemCreateNestedManyWithoutStocksInput
    history?: StockHistoryCreateNestedManyWithoutStocksInput
    favorites?: FavoriteCreateNestedManyWithoutStocksInput
  }

  export type StocksUncheckedCreateInput = {
    id?: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    adminCognitoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutStocksInput
    shipmentItems?: ShipmentItemUncheckedCreateNestedManyWithoutStocksInput
    history?: StockHistoryUncheckedCreateNestedManyWithoutStocksInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutStocksInput
  }

  export type StocksUpdateInput = {
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutStocksNestedInput
    assignments?: StockAssignmentUpdateManyWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUpdateManyWithoutStocksNestedInput
  }

  export type StocksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: StockAssignmentUncheckedUpdateManyWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUncheckedUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUncheckedUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutStocksNestedInput
  }

  export type StocksCreateManyInput = {
    id?: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    adminCognitoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StocksUpdateManyMutationInput = {
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StocksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAssignmentCreateInput = {
    assignedWeight: number
    assignedAt?: Date | string
    stocks: StocksCreateNestedOneWithoutAssignmentsInput
    user: UserCreateNestedOneWithoutAssignmentsInput
  }

  export type StockAssignmentUncheckedCreateInput = {
    id?: number
    stocksId: number
    userCognitoId: string
    assignedWeight: number
    assignedAt?: Date | string
  }

  export type StockAssignmentUpdateInput = {
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StocksUpdateOneRequiredWithoutAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type StockAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAssignmentCreateManyInput = {
    id?: number
    stocksId: number
    userCognitoId: string
    assignedWeight: number
    assignedAt?: Date | string
  }

  export type StockAssignmentUpdateManyMutationInput = {
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentCreateInput = {
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryCreateNestedManyWithoutShipmentInput
    stockHistory?: StockHistoryCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemCreateNestedManyWithoutShipmentInput
    user: UserCreateNestedOneWithoutShipmentsInput
    admin?: AdminCreateNestedOneWithoutShipmentsInput
  }

  export type ShipmentUncheckedCreateInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    userCognitoId: string
    adminCognitoId?: string | null
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUpdateInput = {
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUpdateManyWithoutShipmentNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUpdateManyWithoutShipmentNestedInput
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    admin?: AdminUpdateOneWithoutShipmentsNestedInput
  }

  export type ShipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    userCognitoId?: StringFieldUpdateOperationsInput | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentCreateManyInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    userCognitoId: string
    adminCognitoId?: string | null
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
  }

  export type ShipmentUpdateManyMutationInput = {
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    userCognitoId?: StringFieldUpdateOperationsInput | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentItemCreateInput = {
    assignedWeight: number
    shipment: ShipmentCreateNestedOneWithoutStocksInput
    stocks: StocksCreateNestedOneWithoutShipmentItemsInput
  }

  export type ShipmentItemUncheckedCreateInput = {
    id?: number
    shipmentId: number
    stocksId: number
    assignedWeight: number
  }

  export type ShipmentItemUpdateInput = {
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    shipment?: ShipmentUpdateOneRequiredWithoutStocksNestedInput
    stocks?: StocksUpdateOneRequiredWithoutShipmentItemsNestedInput
  }

  export type ShipmentItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    assignedWeight?: FloatFieldUpdateOperationsInput | number
  }

  export type ShipmentItemCreateManyInput = {
    id?: number
    shipmentId: number
    stocksId: number
    assignedWeight: number
  }

  export type ShipmentItemUpdateManyMutationInput = {
    assignedWeight?: FloatFieldUpdateOperationsInput | number
  }

  export type ShipmentItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    assignedWeight?: FloatFieldUpdateOperationsInput | number
  }

  export type StockHistoryCreateInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    stocks: StocksCreateNestedOneWithoutHistoryInput
    user?: UserCreateNestedOneWithoutStockHistoryInput
    admin?: AdminCreateNestedOneWithoutStockHistoryInput
    shipment?: ShipmentCreateNestedOneWithoutStockHistoryInput
  }

  export type StockHistoryUncheckedCreateInput = {
    id?: number
    stocksId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: number | null
  }

  export type StockHistoryUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    stocks?: StocksUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneWithoutStockHistoryNestedInput
    admin?: AdminUpdateOneWithoutStockHistoryNestedInput
    shipment?: ShipmentUpdateOneWithoutStockHistoryNestedInput
  }

  export type StockHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockHistoryCreateManyInput = {
    id?: number
    stocksId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: number | null
  }

  export type StockHistoryUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StockHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ShipmentHistoryCreateInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    shipment: ShipmentCreateNestedOneWithoutHistoryEntriesInput
    user?: UserCreateNestedOneWithoutShipmentHistoryInput
    admin?: AdminCreateNestedOneWithoutShipmentHistoryInput
  }

  export type ShipmentHistoryUncheckedCreateInput = {
    id?: number
    shipmentId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    shipment?: ShipmentUpdateOneRequiredWithoutHistoryEntriesNestedInput
    user?: UserUpdateOneWithoutShipmentHistoryNestedInput
    admin?: AdminUpdateOneWithoutShipmentHistoryNestedInput
  }

  export type ShipmentHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryCreateManyInput = {
    id?: number
    shipmentId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AdminNotificationCreateInput = {
    message: string
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    admin: AdminCreateNestedOneWithoutNotificationsInput
  }

  export type AdminNotificationUncheckedCreateInput = {
    id?: number
    adminCognitoId: string
    message: string
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminNotificationUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type AdminNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNotificationCreateManyInput = {
    id?: number
    adminCognitoId: string
    message: string
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminNotificationUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    name: string
    email: string
    subject?: string | null
    message: string
    privacyConsent: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    subject?: string | null
    message: string
    privacyConsent: boolean
    userCognitoId?: string | null
    createdAt?: Date | string
  }

  export type ContactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    privacyConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    privacyConsent?: BoolFieldUpdateOperationsInput | boolean
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyInput = {
    id?: number
    name: string
    email: string
    subject?: string | null
    message: string
    privacyConsent: boolean
    userCognitoId?: string | null
    createdAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    privacyConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    privacyConsent?: BoolFieldUpdateOperationsInput | boolean
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
    stocks?: StocksCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: number
    userCognitoId: string
    stocksId?: number | null
    createdAt?: Date | string
  }

  export type FavoriteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    stocks?: StocksUpdateOneWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    stocksId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    id?: number
    userCognitoId: string
    stocksId?: number | null
    createdAt?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    stocksId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CatalogListRelationFilter = {
    every?: CatalogWhereInput
    some?: CatalogWhereInput
    none?: CatalogWhereInput
  }

  export type StocksListRelationFilter = {
    every?: StocksWhereInput
    some?: StocksWhereInput
    none?: StocksWhereInput
  }

  export type SellingPriceListRelationFilter = {
    every?: SellingPriceWhereInput
    some?: SellingPriceWhereInput
    none?: SellingPriceWhereInput
  }

  export type OutLotsListRelationFilter = {
    every?: OutLotsWhereInput
    some?: OutLotsWhereInput
    none?: OutLotsWhereInput
  }

  export type AdminNotificationListRelationFilter = {
    every?: AdminNotificationWhereInput
    some?: AdminNotificationWhereInput
    none?: AdminNotificationWhereInput
  }

  export type ShipmentListRelationFilter = {
    every?: ShipmentWhereInput
    some?: ShipmentWhereInput
    none?: ShipmentWhereInput
  }

  export type StockHistoryListRelationFilter = {
    every?: StockHistoryWhereInput
    some?: StockHistoryWhereInput
    none?: StockHistoryWhereInput
  }

  export type ShipmentHistoryListRelationFilter = {
    every?: ShipmentHistoryWhereInput
    some?: ShipmentHistoryWhereInput
    none?: ShipmentHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CatalogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StocksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellingPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutLotsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShipmentHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type StockAssignmentListRelationFilter = {
    every?: StockAssignmentWhereInput
    some?: StockAssignmentWhereInput
    none?: StockAssignmentWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumBrokerFilter<$PrismaModel = never> = {
    equals?: $Enums.Broker | EnumBrokerFieldRefInput<$PrismaModel>
    in?: $Enums.Broker[] | ListEnumBrokerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Broker[] | ListEnumBrokerFieldRefInput<$PrismaModel>
    not?: NestedEnumBrokerFilter<$PrismaModel> | $Enums.Broker
  }

  export type EnumTeaGradeFilter<$PrismaModel = never> = {
    equals?: $Enums.TeaGrade | EnumTeaGradeFieldRefInput<$PrismaModel>
    in?: $Enums.TeaGrade[] | ListEnumTeaGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeaGrade[] | ListEnumTeaGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumTeaGradeFilter<$PrismaModel> | $Enums.TeaGrade
  }

  export type EnumTeaCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TeaCategory | EnumTeaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TeaCategory[] | ListEnumTeaCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeaCategory[] | ListEnumTeaCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTeaCategoryFilter<$PrismaModel> | $Enums.TeaCategory
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type CatalogCountOrderByAggregateInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    producerCountry?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogAvgOrderByAggregateInput = {
    id?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
  }

  export type CatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    producerCountry?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogMinOrderByAggregateInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    producerCountry?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogSumOrderByAggregateInput = {
    id?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
  }

  export type EnumBrokerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Broker | EnumBrokerFieldRefInput<$PrismaModel>
    in?: $Enums.Broker[] | ListEnumBrokerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Broker[] | ListEnumBrokerFieldRefInput<$PrismaModel>
    not?: NestedEnumBrokerWithAggregatesFilter<$PrismaModel> | $Enums.Broker
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBrokerFilter<$PrismaModel>
    _max?: NestedEnumBrokerFilter<$PrismaModel>
  }

  export type EnumTeaGradeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeaGrade | EnumTeaGradeFieldRefInput<$PrismaModel>
    in?: $Enums.TeaGrade[] | ListEnumTeaGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeaGrade[] | ListEnumTeaGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumTeaGradeWithAggregatesFilter<$PrismaModel> | $Enums.TeaGrade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeaGradeFilter<$PrismaModel>
    _max?: NestedEnumTeaGradeFilter<$PrismaModel>
  }

  export type EnumTeaCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeaCategory | EnumTeaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TeaCategory[] | ListEnumTeaCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeaCategory[] | ListEnumTeaCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTeaCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TeaCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeaCategoryFilter<$PrismaModel>
    _max?: NestedEnumTeaCategoryFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SellingPriceCountOrderByAggregateInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    purchasePrice?: SortOrder
    producerCountry?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellingPriceAvgOrderByAggregateInput = {
    id?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    purchasePrice?: SortOrder
  }

  export type SellingPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    purchasePrice?: SortOrder
    producerCountry?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellingPriceMinOrderByAggregateInput = {
    id?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    saleCode?: SortOrder
    category?: SortOrder
    reprint?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    purchasePrice?: SortOrder
    producerCountry?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellingPriceSumOrderByAggregateInput = {
    id?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    askingPrice?: SortOrder
    purchasePrice?: SortOrder
  }

  export type OutLotsCountOrderByAggregateInput = {
    id?: SortOrder
    auction?: SortOrder
    lotNo?: SortOrder
    broker?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    baselinePrice?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutLotsAvgOrderByAggregateInput = {
    id?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    baselinePrice?: SortOrder
  }

  export type OutLotsMaxOrderByAggregateInput = {
    id?: SortOrder
    auction?: SortOrder
    lotNo?: SortOrder
    broker?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    baselinePrice?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutLotsMinOrderByAggregateInput = {
    id?: SortOrder
    auction?: SortOrder
    lotNo?: SortOrder
    broker?: SortOrder
    sellingMark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    baselinePrice?: SortOrder
    manufactureDate?: SortOrder
    adminCognitoId?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutLotsSumOrderByAggregateInput = {
    id?: SortOrder
    bags?: SortOrder
    netWeight?: SortOrder
    totalWeight?: SortOrder
    baselinePrice?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type ShipmentItemListRelationFilter = {
    every?: ShipmentItemWhereInput
    some?: ShipmentItemWhereInput
    none?: ShipmentItemWhereInput
  }

  export type ShipmentItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StocksCountOrderByAggregateInput = {
    id?: SortOrder
    saleCode?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    mark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    weight?: SortOrder
    purchaseValue?: SortOrder
    totalPurchaseValue?: SortOrder
    agingDays?: SortOrder
    penalty?: SortOrder
    bgtCommission?: SortOrder
    maerskFee?: SortOrder
    commission?: SortOrder
    netPrice?: SortOrder
    total?: SortOrder
    batchNumber?: SortOrder
    lowStockThreshold?: SortOrder
    adminCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StocksAvgOrderByAggregateInput = {
    id?: SortOrder
    bags?: SortOrder
    weight?: SortOrder
    purchaseValue?: SortOrder
    totalPurchaseValue?: SortOrder
    agingDays?: SortOrder
    penalty?: SortOrder
    bgtCommission?: SortOrder
    maerskFee?: SortOrder
    commission?: SortOrder
    netPrice?: SortOrder
    total?: SortOrder
    lowStockThreshold?: SortOrder
  }

  export type StocksMaxOrderByAggregateInput = {
    id?: SortOrder
    saleCode?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    mark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    weight?: SortOrder
    purchaseValue?: SortOrder
    totalPurchaseValue?: SortOrder
    agingDays?: SortOrder
    penalty?: SortOrder
    bgtCommission?: SortOrder
    maerskFee?: SortOrder
    commission?: SortOrder
    netPrice?: SortOrder
    total?: SortOrder
    batchNumber?: SortOrder
    lowStockThreshold?: SortOrder
    adminCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StocksMinOrderByAggregateInput = {
    id?: SortOrder
    saleCode?: SortOrder
    broker?: SortOrder
    lotNo?: SortOrder
    mark?: SortOrder
    grade?: SortOrder
    invoiceNo?: SortOrder
    bags?: SortOrder
    weight?: SortOrder
    purchaseValue?: SortOrder
    totalPurchaseValue?: SortOrder
    agingDays?: SortOrder
    penalty?: SortOrder
    bgtCommission?: SortOrder
    maerskFee?: SortOrder
    commission?: SortOrder
    netPrice?: SortOrder
    total?: SortOrder
    batchNumber?: SortOrder
    lowStockThreshold?: SortOrder
    adminCognitoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StocksSumOrderByAggregateInput = {
    id?: SortOrder
    bags?: SortOrder
    weight?: SortOrder
    purchaseValue?: SortOrder
    totalPurchaseValue?: SortOrder
    agingDays?: SortOrder
    penalty?: SortOrder
    bgtCommission?: SortOrder
    maerskFee?: SortOrder
    commission?: SortOrder
    netPrice?: SortOrder
    total?: SortOrder
    lowStockThreshold?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StocksScalarRelationFilter = {
    is?: StocksWhereInput
    isNot?: StocksWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type StockAssignmentStocksIdUserCognitoIdCompoundUniqueInput = {
    stocksId: number
    userCognitoId: string
  }

  export type StockAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    userCognitoId?: SortOrder
    assignedWeight?: SortOrder
    assignedAt?: SortOrder
  }

  export type StockAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
  }

  export type StockAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    userCognitoId?: SortOrder
    assignedWeight?: SortOrder
    assignedAt?: SortOrder
  }

  export type StockAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    userCognitoId?: SortOrder
    assignedWeight?: SortOrder
    assignedAt?: SortOrder
  }

  export type StockAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
  }

  export type EnumShipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusFilter<$PrismaModel> | $Enums.ShipmentStatus
  }

  export type EnumVesselFilter<$PrismaModel = never> = {
    equals?: $Enums.Vessel | EnumVesselFieldRefInput<$PrismaModel>
    in?: $Enums.Vessel[] | ListEnumVesselFieldRefInput<$PrismaModel>
    notIn?: $Enums.Vessel[] | ListEnumVesselFieldRefInput<$PrismaModel>
    not?: NestedEnumVesselFilter<$PrismaModel> | $Enums.Vessel
  }

  export type EnumPackagingInstructionsFilter<$PrismaModel = never> = {
    equals?: $Enums.PackagingInstructions | EnumPackagingInstructionsFieldRefInput<$PrismaModel>
    in?: $Enums.PackagingInstructions[] | ListEnumPackagingInstructionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackagingInstructions[] | ListEnumPackagingInstructionsFieldRefInput<$PrismaModel>
    not?: NestedEnumPackagingInstructionsFilter<$PrismaModel> | $Enums.PackagingInstructions
  }

  export type ShipmentCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    status?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
    consignee?: SortOrder
    vessel?: SortOrder
    shipmark?: SortOrder
    packagingInstructions?: SortOrder
    additionalInstructions?: SortOrder
    createdAt?: SortOrder
  }

  export type ShipmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ShipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    status?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
    consignee?: SortOrder
    vessel?: SortOrder
    shipmark?: SortOrder
    packagingInstructions?: SortOrder
    additionalInstructions?: SortOrder
    createdAt?: SortOrder
  }

  export type ShipmentMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    status?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
    consignee?: SortOrder
    vessel?: SortOrder
    shipmark?: SortOrder
    packagingInstructions?: SortOrder
    additionalInstructions?: SortOrder
    createdAt?: SortOrder
  }

  export type ShipmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumShipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumShipmentStatusFilter<$PrismaModel>
  }

  export type EnumVesselWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Vessel | EnumVesselFieldRefInput<$PrismaModel>
    in?: $Enums.Vessel[] | ListEnumVesselFieldRefInput<$PrismaModel>
    notIn?: $Enums.Vessel[] | ListEnumVesselFieldRefInput<$PrismaModel>
    not?: NestedEnumVesselWithAggregatesFilter<$PrismaModel> | $Enums.Vessel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVesselFilter<$PrismaModel>
    _max?: NestedEnumVesselFilter<$PrismaModel>
  }

  export type EnumPackagingInstructionsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackagingInstructions | EnumPackagingInstructionsFieldRefInput<$PrismaModel>
    in?: $Enums.PackagingInstructions[] | ListEnumPackagingInstructionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackagingInstructions[] | ListEnumPackagingInstructionsFieldRefInput<$PrismaModel>
    not?: NestedEnumPackagingInstructionsWithAggregatesFilter<$PrismaModel> | $Enums.PackagingInstructions
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPackagingInstructionsFilter<$PrismaModel>
    _max?: NestedEnumPackagingInstructionsFilter<$PrismaModel>
  }

  export type ShipmentScalarRelationFilter = {
    is?: ShipmentWhereInput
    isNot?: ShipmentWhereInput
  }

  export type ShipmentItemShipmentIdStocksIdCompoundUniqueInput = {
    shipmentId: number
    stocksId: number
  }

  export type ShipmentItemCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
  }

  export type ShipmentItemAvgOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
  }

  export type ShipmentItemMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
  }

  export type ShipmentItemMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
  }

  export type ShipmentItemSumOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    stocksId?: SortOrder
    assignedWeight?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ShipmentNullableScalarRelationFilter = {
    is?: ShipmentWhereInput | null
    isNot?: ShipmentWhereInput | null
  }

  export type StockHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
    details?: SortOrder
    shipmentId?: SortOrder
  }

  export type StockHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    shipmentId?: SortOrder
  }

  export type StockHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
    shipmentId?: SortOrder
  }

  export type StockHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
    shipmentId?: SortOrder
  }

  export type StockHistorySumOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
    shipmentId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ShipmentHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
    details?: SortOrder
  }

  export type ShipmentHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
  }

  export type ShipmentHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
  }

  export type ShipmentHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    userCognitoId?: SortOrder
    adminCognitoId?: SortOrder
  }

  export type ShipmentHistorySumOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdminNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    message?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    adminCognitoId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminNotificationSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    privacyConsent?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    privacyConsent?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    privacyConsent?: SortOrder
    userCognitoId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StocksNullableScalarRelationFilter = {
    is?: StocksWhereInput | null
    isNot?: StocksWhereInput | null
  }

  export type FavoriteUser_stocks_favoriteCompoundUniqueInput = {
    userCognitoId: string
    stocksId: number
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    stocksId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteAvgOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    stocksId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userCognitoId?: SortOrder
    stocksId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteSumOrderByAggregateInput = {
    id?: SortOrder
    stocksId?: SortOrder
  }

  export type CatalogCreateNestedManyWithoutAdminInput = {
    create?: XOR<CatalogCreateWithoutAdminInput, CatalogUncheckedCreateWithoutAdminInput> | CatalogCreateWithoutAdminInput[] | CatalogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CatalogCreateOrConnectWithoutAdminInput | CatalogCreateOrConnectWithoutAdminInput[]
    createMany?: CatalogCreateManyAdminInputEnvelope
    connect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
  }

  export type StocksCreateNestedManyWithoutAdminInput = {
    create?: XOR<StocksCreateWithoutAdminInput, StocksUncheckedCreateWithoutAdminInput> | StocksCreateWithoutAdminInput[] | StocksUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StocksCreateOrConnectWithoutAdminInput | StocksCreateOrConnectWithoutAdminInput[]
    createMany?: StocksCreateManyAdminInputEnvelope
    connect?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
  }

  export type SellingPriceCreateNestedManyWithoutAdminInput = {
    create?: XOR<SellingPriceCreateWithoutAdminInput, SellingPriceUncheckedCreateWithoutAdminInput> | SellingPriceCreateWithoutAdminInput[] | SellingPriceUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SellingPriceCreateOrConnectWithoutAdminInput | SellingPriceCreateOrConnectWithoutAdminInput[]
    createMany?: SellingPriceCreateManyAdminInputEnvelope
    connect?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
  }

  export type OutLotsCreateNestedManyWithoutAdminInput = {
    create?: XOR<OutLotsCreateWithoutAdminInput, OutLotsUncheckedCreateWithoutAdminInput> | OutLotsCreateWithoutAdminInput[] | OutLotsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: OutLotsCreateOrConnectWithoutAdminInput | OutLotsCreateOrConnectWithoutAdminInput[]
    createMany?: OutLotsCreateManyAdminInputEnvelope
    connect?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
  }

  export type AdminNotificationCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminNotificationCreateWithoutAdminInput, AdminNotificationUncheckedCreateWithoutAdminInput> | AdminNotificationCreateWithoutAdminInput[] | AdminNotificationUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminNotificationCreateOrConnectWithoutAdminInput | AdminNotificationCreateOrConnectWithoutAdminInput[]
    createMany?: AdminNotificationCreateManyAdminInputEnvelope
    connect?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
  }

  export type ShipmentCreateNestedManyWithoutAdminInput = {
    create?: XOR<ShipmentCreateWithoutAdminInput, ShipmentUncheckedCreateWithoutAdminInput> | ShipmentCreateWithoutAdminInput[] | ShipmentUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutAdminInput | ShipmentCreateOrConnectWithoutAdminInput[]
    createMany?: ShipmentCreateManyAdminInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type StockHistoryCreateNestedManyWithoutAdminInput = {
    create?: XOR<StockHistoryCreateWithoutAdminInput, StockHistoryUncheckedCreateWithoutAdminInput> | StockHistoryCreateWithoutAdminInput[] | StockHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutAdminInput | StockHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: StockHistoryCreateManyAdminInputEnvelope
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
  }

  export type ShipmentHistoryCreateNestedManyWithoutAdminInput = {
    create?: XOR<ShipmentHistoryCreateWithoutAdminInput, ShipmentHistoryUncheckedCreateWithoutAdminInput> | ShipmentHistoryCreateWithoutAdminInput[] | ShipmentHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutAdminInput | ShipmentHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: ShipmentHistoryCreateManyAdminInputEnvelope
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
  }

  export type CatalogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<CatalogCreateWithoutAdminInput, CatalogUncheckedCreateWithoutAdminInput> | CatalogCreateWithoutAdminInput[] | CatalogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CatalogCreateOrConnectWithoutAdminInput | CatalogCreateOrConnectWithoutAdminInput[]
    createMany?: CatalogCreateManyAdminInputEnvelope
    connect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
  }

  export type StocksUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<StocksCreateWithoutAdminInput, StocksUncheckedCreateWithoutAdminInput> | StocksCreateWithoutAdminInput[] | StocksUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StocksCreateOrConnectWithoutAdminInput | StocksCreateOrConnectWithoutAdminInput[]
    createMany?: StocksCreateManyAdminInputEnvelope
    connect?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
  }

  export type SellingPriceUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<SellingPriceCreateWithoutAdminInput, SellingPriceUncheckedCreateWithoutAdminInput> | SellingPriceCreateWithoutAdminInput[] | SellingPriceUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SellingPriceCreateOrConnectWithoutAdminInput | SellingPriceCreateOrConnectWithoutAdminInput[]
    createMany?: SellingPriceCreateManyAdminInputEnvelope
    connect?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
  }

  export type OutLotsUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<OutLotsCreateWithoutAdminInput, OutLotsUncheckedCreateWithoutAdminInput> | OutLotsCreateWithoutAdminInput[] | OutLotsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: OutLotsCreateOrConnectWithoutAdminInput | OutLotsCreateOrConnectWithoutAdminInput[]
    createMany?: OutLotsCreateManyAdminInputEnvelope
    connect?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
  }

  export type AdminNotificationUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminNotificationCreateWithoutAdminInput, AdminNotificationUncheckedCreateWithoutAdminInput> | AdminNotificationCreateWithoutAdminInput[] | AdminNotificationUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminNotificationCreateOrConnectWithoutAdminInput | AdminNotificationCreateOrConnectWithoutAdminInput[]
    createMany?: AdminNotificationCreateManyAdminInputEnvelope
    connect?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<ShipmentCreateWithoutAdminInput, ShipmentUncheckedCreateWithoutAdminInput> | ShipmentCreateWithoutAdminInput[] | ShipmentUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutAdminInput | ShipmentCreateOrConnectWithoutAdminInput[]
    createMany?: ShipmentCreateManyAdminInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type StockHistoryUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<StockHistoryCreateWithoutAdminInput, StockHistoryUncheckedCreateWithoutAdminInput> | StockHistoryCreateWithoutAdminInput[] | StockHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutAdminInput | StockHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: StockHistoryCreateManyAdminInputEnvelope
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
  }

  export type ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<ShipmentHistoryCreateWithoutAdminInput, ShipmentHistoryUncheckedCreateWithoutAdminInput> | ShipmentHistoryCreateWithoutAdminInput[] | ShipmentHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutAdminInput | ShipmentHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: ShipmentHistoryCreateManyAdminInputEnvelope
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CatalogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<CatalogCreateWithoutAdminInput, CatalogUncheckedCreateWithoutAdminInput> | CatalogCreateWithoutAdminInput[] | CatalogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CatalogCreateOrConnectWithoutAdminInput | CatalogCreateOrConnectWithoutAdminInput[]
    upsert?: CatalogUpsertWithWhereUniqueWithoutAdminInput | CatalogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: CatalogCreateManyAdminInputEnvelope
    set?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    disconnect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    delete?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    connect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    update?: CatalogUpdateWithWhereUniqueWithoutAdminInput | CatalogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: CatalogUpdateManyWithWhereWithoutAdminInput | CatalogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: CatalogScalarWhereInput | CatalogScalarWhereInput[]
  }

  export type StocksUpdateManyWithoutAdminNestedInput = {
    create?: XOR<StocksCreateWithoutAdminInput, StocksUncheckedCreateWithoutAdminInput> | StocksCreateWithoutAdminInput[] | StocksUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StocksCreateOrConnectWithoutAdminInput | StocksCreateOrConnectWithoutAdminInput[]
    upsert?: StocksUpsertWithWhereUniqueWithoutAdminInput | StocksUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: StocksCreateManyAdminInputEnvelope
    set?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
    disconnect?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
    delete?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
    connect?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
    update?: StocksUpdateWithWhereUniqueWithoutAdminInput | StocksUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: StocksUpdateManyWithWhereWithoutAdminInput | StocksUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: StocksScalarWhereInput | StocksScalarWhereInput[]
  }

  export type SellingPriceUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SellingPriceCreateWithoutAdminInput, SellingPriceUncheckedCreateWithoutAdminInput> | SellingPriceCreateWithoutAdminInput[] | SellingPriceUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SellingPriceCreateOrConnectWithoutAdminInput | SellingPriceCreateOrConnectWithoutAdminInput[]
    upsert?: SellingPriceUpsertWithWhereUniqueWithoutAdminInput | SellingPriceUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SellingPriceCreateManyAdminInputEnvelope
    set?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
    disconnect?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
    delete?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
    connect?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
    update?: SellingPriceUpdateWithWhereUniqueWithoutAdminInput | SellingPriceUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SellingPriceUpdateManyWithWhereWithoutAdminInput | SellingPriceUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SellingPriceScalarWhereInput | SellingPriceScalarWhereInput[]
  }

  export type OutLotsUpdateManyWithoutAdminNestedInput = {
    create?: XOR<OutLotsCreateWithoutAdminInput, OutLotsUncheckedCreateWithoutAdminInput> | OutLotsCreateWithoutAdminInput[] | OutLotsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: OutLotsCreateOrConnectWithoutAdminInput | OutLotsCreateOrConnectWithoutAdminInput[]
    upsert?: OutLotsUpsertWithWhereUniqueWithoutAdminInput | OutLotsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: OutLotsCreateManyAdminInputEnvelope
    set?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
    disconnect?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
    delete?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
    connect?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
    update?: OutLotsUpdateWithWhereUniqueWithoutAdminInput | OutLotsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: OutLotsUpdateManyWithWhereWithoutAdminInput | OutLotsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: OutLotsScalarWhereInput | OutLotsScalarWhereInput[]
  }

  export type AdminNotificationUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminNotificationCreateWithoutAdminInput, AdminNotificationUncheckedCreateWithoutAdminInput> | AdminNotificationCreateWithoutAdminInput[] | AdminNotificationUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminNotificationCreateOrConnectWithoutAdminInput | AdminNotificationCreateOrConnectWithoutAdminInput[]
    upsert?: AdminNotificationUpsertWithWhereUniqueWithoutAdminInput | AdminNotificationUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminNotificationCreateManyAdminInputEnvelope
    set?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
    disconnect?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
    delete?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
    connect?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
    update?: AdminNotificationUpdateWithWhereUniqueWithoutAdminInput | AdminNotificationUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminNotificationUpdateManyWithWhereWithoutAdminInput | AdminNotificationUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminNotificationScalarWhereInput | AdminNotificationScalarWhereInput[]
  }

  export type ShipmentUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ShipmentCreateWithoutAdminInput, ShipmentUncheckedCreateWithoutAdminInput> | ShipmentCreateWithoutAdminInput[] | ShipmentUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutAdminInput | ShipmentCreateOrConnectWithoutAdminInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutAdminInput | ShipmentUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ShipmentCreateManyAdminInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutAdminInput | ShipmentUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutAdminInput | ShipmentUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type StockHistoryUpdateManyWithoutAdminNestedInput = {
    create?: XOR<StockHistoryCreateWithoutAdminInput, StockHistoryUncheckedCreateWithoutAdminInput> | StockHistoryCreateWithoutAdminInput[] | StockHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutAdminInput | StockHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: StockHistoryUpsertWithWhereUniqueWithoutAdminInput | StockHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: StockHistoryCreateManyAdminInputEnvelope
    set?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    disconnect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    delete?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    update?: StockHistoryUpdateWithWhereUniqueWithoutAdminInput | StockHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: StockHistoryUpdateManyWithWhereWithoutAdminInput | StockHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
  }

  export type ShipmentHistoryUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ShipmentHistoryCreateWithoutAdminInput, ShipmentHistoryUncheckedCreateWithoutAdminInput> | ShipmentHistoryCreateWithoutAdminInput[] | ShipmentHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutAdminInput | ShipmentHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: ShipmentHistoryUpsertWithWhereUniqueWithoutAdminInput | ShipmentHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ShipmentHistoryCreateManyAdminInputEnvelope
    set?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    disconnect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    delete?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    update?: ShipmentHistoryUpdateWithWhereUniqueWithoutAdminInput | ShipmentHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ShipmentHistoryUpdateManyWithWhereWithoutAdminInput | ShipmentHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ShipmentHistoryScalarWhereInput | ShipmentHistoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CatalogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<CatalogCreateWithoutAdminInput, CatalogUncheckedCreateWithoutAdminInput> | CatalogCreateWithoutAdminInput[] | CatalogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CatalogCreateOrConnectWithoutAdminInput | CatalogCreateOrConnectWithoutAdminInput[]
    upsert?: CatalogUpsertWithWhereUniqueWithoutAdminInput | CatalogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: CatalogCreateManyAdminInputEnvelope
    set?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    disconnect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    delete?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    connect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    update?: CatalogUpdateWithWhereUniqueWithoutAdminInput | CatalogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: CatalogUpdateManyWithWhereWithoutAdminInput | CatalogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: CatalogScalarWhereInput | CatalogScalarWhereInput[]
  }

  export type StocksUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<StocksCreateWithoutAdminInput, StocksUncheckedCreateWithoutAdminInput> | StocksCreateWithoutAdminInput[] | StocksUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StocksCreateOrConnectWithoutAdminInput | StocksCreateOrConnectWithoutAdminInput[]
    upsert?: StocksUpsertWithWhereUniqueWithoutAdminInput | StocksUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: StocksCreateManyAdminInputEnvelope
    set?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
    disconnect?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
    delete?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
    connect?: StocksWhereUniqueInput | StocksWhereUniqueInput[]
    update?: StocksUpdateWithWhereUniqueWithoutAdminInput | StocksUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: StocksUpdateManyWithWhereWithoutAdminInput | StocksUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: StocksScalarWhereInput | StocksScalarWhereInput[]
  }

  export type SellingPriceUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SellingPriceCreateWithoutAdminInput, SellingPriceUncheckedCreateWithoutAdminInput> | SellingPriceCreateWithoutAdminInput[] | SellingPriceUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SellingPriceCreateOrConnectWithoutAdminInput | SellingPriceCreateOrConnectWithoutAdminInput[]
    upsert?: SellingPriceUpsertWithWhereUniqueWithoutAdminInput | SellingPriceUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SellingPriceCreateManyAdminInputEnvelope
    set?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
    disconnect?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
    delete?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
    connect?: SellingPriceWhereUniqueInput | SellingPriceWhereUniqueInput[]
    update?: SellingPriceUpdateWithWhereUniqueWithoutAdminInput | SellingPriceUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SellingPriceUpdateManyWithWhereWithoutAdminInput | SellingPriceUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SellingPriceScalarWhereInput | SellingPriceScalarWhereInput[]
  }

  export type OutLotsUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<OutLotsCreateWithoutAdminInput, OutLotsUncheckedCreateWithoutAdminInput> | OutLotsCreateWithoutAdminInput[] | OutLotsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: OutLotsCreateOrConnectWithoutAdminInput | OutLotsCreateOrConnectWithoutAdminInput[]
    upsert?: OutLotsUpsertWithWhereUniqueWithoutAdminInput | OutLotsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: OutLotsCreateManyAdminInputEnvelope
    set?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
    disconnect?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
    delete?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
    connect?: OutLotsWhereUniqueInput | OutLotsWhereUniqueInput[]
    update?: OutLotsUpdateWithWhereUniqueWithoutAdminInput | OutLotsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: OutLotsUpdateManyWithWhereWithoutAdminInput | OutLotsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: OutLotsScalarWhereInput | OutLotsScalarWhereInput[]
  }

  export type AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminNotificationCreateWithoutAdminInput, AdminNotificationUncheckedCreateWithoutAdminInput> | AdminNotificationCreateWithoutAdminInput[] | AdminNotificationUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminNotificationCreateOrConnectWithoutAdminInput | AdminNotificationCreateOrConnectWithoutAdminInput[]
    upsert?: AdminNotificationUpsertWithWhereUniqueWithoutAdminInput | AdminNotificationUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminNotificationCreateManyAdminInputEnvelope
    set?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
    disconnect?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
    delete?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
    connect?: AdminNotificationWhereUniqueInput | AdminNotificationWhereUniqueInput[]
    update?: AdminNotificationUpdateWithWhereUniqueWithoutAdminInput | AdminNotificationUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminNotificationUpdateManyWithWhereWithoutAdminInput | AdminNotificationUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminNotificationScalarWhereInput | AdminNotificationScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ShipmentCreateWithoutAdminInput, ShipmentUncheckedCreateWithoutAdminInput> | ShipmentCreateWithoutAdminInput[] | ShipmentUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutAdminInput | ShipmentCreateOrConnectWithoutAdminInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutAdminInput | ShipmentUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ShipmentCreateManyAdminInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutAdminInput | ShipmentUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutAdminInput | ShipmentUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type StockHistoryUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<StockHistoryCreateWithoutAdminInput, StockHistoryUncheckedCreateWithoutAdminInput> | StockHistoryCreateWithoutAdminInput[] | StockHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutAdminInput | StockHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: StockHistoryUpsertWithWhereUniqueWithoutAdminInput | StockHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: StockHistoryCreateManyAdminInputEnvelope
    set?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    disconnect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    delete?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    update?: StockHistoryUpdateWithWhereUniqueWithoutAdminInput | StockHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: StockHistoryUpdateManyWithWhereWithoutAdminInput | StockHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
  }

  export type ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ShipmentHistoryCreateWithoutAdminInput, ShipmentHistoryUncheckedCreateWithoutAdminInput> | ShipmentHistoryCreateWithoutAdminInput[] | ShipmentHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutAdminInput | ShipmentHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: ShipmentHistoryUpsertWithWhereUniqueWithoutAdminInput | ShipmentHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ShipmentHistoryCreateManyAdminInputEnvelope
    set?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    disconnect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    delete?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    update?: ShipmentHistoryUpdateWithWhereUniqueWithoutAdminInput | ShipmentHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ShipmentHistoryUpdateManyWithWhereWithoutAdminInput | ShipmentHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ShipmentHistoryScalarWhereInput | ShipmentHistoryScalarWhereInput[]
  }

  export type ShipmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput> | ShipmentCreateWithoutUserInput[] | ShipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUserInput | ShipmentCreateOrConnectWithoutUserInput[]
    createMany?: ShipmentCreateManyUserInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type StockHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<StockHistoryCreateWithoutUserInput, StockHistoryUncheckedCreateWithoutUserInput> | StockHistoryCreateWithoutUserInput[] | StockHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutUserInput | StockHistoryCreateOrConnectWithoutUserInput[]
    createMany?: StockHistoryCreateManyUserInputEnvelope
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
  }

  export type ShipmentHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ShipmentHistoryCreateWithoutUserInput, ShipmentHistoryUncheckedCreateWithoutUserInput> | ShipmentHistoryCreateWithoutUserInput[] | ShipmentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutUserInput | ShipmentHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ShipmentHistoryCreateManyUserInputEnvelope
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type StockAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<StockAssignmentCreateWithoutUserInput, StockAssignmentUncheckedCreateWithoutUserInput> | StockAssignmentCreateWithoutUserInput[] | StockAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockAssignmentCreateOrConnectWithoutUserInput | StockAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: StockAssignmentCreateManyUserInputEnvelope
    connect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput> | ShipmentCreateWithoutUserInput[] | ShipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUserInput | ShipmentCreateOrConnectWithoutUserInput[]
    createMany?: ShipmentCreateManyUserInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type StockHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StockHistoryCreateWithoutUserInput, StockHistoryUncheckedCreateWithoutUserInput> | StockHistoryCreateWithoutUserInput[] | StockHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutUserInput | StockHistoryCreateOrConnectWithoutUserInput[]
    createMany?: StockHistoryCreateManyUserInputEnvelope
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
  }

  export type ShipmentHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShipmentHistoryCreateWithoutUserInput, ShipmentHistoryUncheckedCreateWithoutUserInput> | ShipmentHistoryCreateWithoutUserInput[] | ShipmentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutUserInput | ShipmentHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ShipmentHistoryCreateManyUserInputEnvelope
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type StockAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StockAssignmentCreateWithoutUserInput, StockAssignmentUncheckedCreateWithoutUserInput> | StockAssignmentCreateWithoutUserInput[] | StockAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockAssignmentCreateOrConnectWithoutUserInput | StockAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: StockAssignmentCreateManyUserInputEnvelope
    connect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ShipmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput> | ShipmentCreateWithoutUserInput[] | ShipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUserInput | ShipmentCreateOrConnectWithoutUserInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutUserInput | ShipmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShipmentCreateManyUserInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutUserInput | ShipmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutUserInput | ShipmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type StockHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<StockHistoryCreateWithoutUserInput, StockHistoryUncheckedCreateWithoutUserInput> | StockHistoryCreateWithoutUserInput[] | StockHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutUserInput | StockHistoryCreateOrConnectWithoutUserInput[]
    upsert?: StockHistoryUpsertWithWhereUniqueWithoutUserInput | StockHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StockHistoryCreateManyUserInputEnvelope
    set?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    disconnect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    delete?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    update?: StockHistoryUpdateWithWhereUniqueWithoutUserInput | StockHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StockHistoryUpdateManyWithWhereWithoutUserInput | StockHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
  }

  export type ShipmentHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShipmentHistoryCreateWithoutUserInput, ShipmentHistoryUncheckedCreateWithoutUserInput> | ShipmentHistoryCreateWithoutUserInput[] | ShipmentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutUserInput | ShipmentHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ShipmentHistoryUpsertWithWhereUniqueWithoutUserInput | ShipmentHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShipmentHistoryCreateManyUserInputEnvelope
    set?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    disconnect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    delete?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    update?: ShipmentHistoryUpdateWithWhereUniqueWithoutUserInput | ShipmentHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShipmentHistoryUpdateManyWithWhereWithoutUserInput | ShipmentHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShipmentHistoryScalarWhereInput | ShipmentHistoryScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type StockAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<StockAssignmentCreateWithoutUserInput, StockAssignmentUncheckedCreateWithoutUserInput> | StockAssignmentCreateWithoutUserInput[] | StockAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockAssignmentCreateOrConnectWithoutUserInput | StockAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: StockAssignmentUpsertWithWhereUniqueWithoutUserInput | StockAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StockAssignmentCreateManyUserInputEnvelope
    set?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    disconnect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    delete?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    connect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    update?: StockAssignmentUpdateWithWhereUniqueWithoutUserInput | StockAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StockAssignmentUpdateManyWithWhereWithoutUserInput | StockAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StockAssignmentScalarWhereInput | StockAssignmentScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput> | ShipmentCreateWithoutUserInput[] | ShipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUserInput | ShipmentCreateOrConnectWithoutUserInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutUserInput | ShipmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShipmentCreateManyUserInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutUserInput | ShipmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutUserInput | ShipmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type StockHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StockHistoryCreateWithoutUserInput, StockHistoryUncheckedCreateWithoutUserInput> | StockHistoryCreateWithoutUserInput[] | StockHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutUserInput | StockHistoryCreateOrConnectWithoutUserInput[]
    upsert?: StockHistoryUpsertWithWhereUniqueWithoutUserInput | StockHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StockHistoryCreateManyUserInputEnvelope
    set?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    disconnect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    delete?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    update?: StockHistoryUpdateWithWhereUniqueWithoutUserInput | StockHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StockHistoryUpdateManyWithWhereWithoutUserInput | StockHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
  }

  export type ShipmentHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShipmentHistoryCreateWithoutUserInput, ShipmentHistoryUncheckedCreateWithoutUserInput> | ShipmentHistoryCreateWithoutUserInput[] | ShipmentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutUserInput | ShipmentHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ShipmentHistoryUpsertWithWhereUniqueWithoutUserInput | ShipmentHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShipmentHistoryCreateManyUserInputEnvelope
    set?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    disconnect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    delete?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    update?: ShipmentHistoryUpdateWithWhereUniqueWithoutUserInput | ShipmentHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShipmentHistoryUpdateManyWithWhereWithoutUserInput | ShipmentHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShipmentHistoryScalarWhereInput | ShipmentHistoryScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type StockAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StockAssignmentCreateWithoutUserInput, StockAssignmentUncheckedCreateWithoutUserInput> | StockAssignmentCreateWithoutUserInput[] | StockAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockAssignmentCreateOrConnectWithoutUserInput | StockAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: StockAssignmentUpsertWithWhereUniqueWithoutUserInput | StockAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StockAssignmentCreateManyUserInputEnvelope
    set?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    disconnect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    delete?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    connect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    update?: StockAssignmentUpdateWithWhereUniqueWithoutUserInput | StockAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StockAssignmentUpdateManyWithWhereWithoutUserInput | StockAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StockAssignmentScalarWhereInput | StockAssignmentScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutCatalogsInput = {
    create?: XOR<AdminCreateWithoutCatalogsInput, AdminUncheckedCreateWithoutCatalogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCatalogsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumBrokerFieldUpdateOperationsInput = {
    set?: $Enums.Broker
  }

  export type EnumTeaGradeFieldUpdateOperationsInput = {
    set?: $Enums.TeaGrade
  }

  export type EnumTeaCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TeaCategory
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUpdateOneWithoutCatalogsNestedInput = {
    create?: XOR<AdminCreateWithoutCatalogsInput, AdminUncheckedCreateWithoutCatalogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCatalogsInput
    upsert?: AdminUpsertWithoutCatalogsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCatalogsInput, AdminUpdateWithoutCatalogsInput>, AdminUncheckedUpdateWithoutCatalogsInput>
  }

  export type AdminCreateNestedOneWithoutSellingPricesInput = {
    create?: XOR<AdminCreateWithoutSellingPricesInput, AdminUncheckedCreateWithoutSellingPricesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSellingPricesInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneWithoutSellingPricesNestedInput = {
    create?: XOR<AdminCreateWithoutSellingPricesInput, AdminUncheckedCreateWithoutSellingPricesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSellingPricesInput
    upsert?: AdminUpsertWithoutSellingPricesInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutSellingPricesInput, AdminUpdateWithoutSellingPricesInput>, AdminUncheckedUpdateWithoutSellingPricesInput>
  }

  export type AdminCreateNestedOneWithoutOutLotsInput = {
    create?: XOR<AdminCreateWithoutOutLotsInput, AdminUncheckedCreateWithoutOutLotsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOutLotsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneWithoutOutLotsNestedInput = {
    create?: XOR<AdminCreateWithoutOutLotsInput, AdminUncheckedCreateWithoutOutLotsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOutLotsInput
    upsert?: AdminUpsertWithoutOutLotsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutOutLotsInput, AdminUpdateWithoutOutLotsInput>, AdminUncheckedUpdateWithoutOutLotsInput>
  }

  export type AdminCreateNestedOneWithoutStocksInput = {
    create?: XOR<AdminCreateWithoutStocksInput, AdminUncheckedCreateWithoutStocksInput>
    connectOrCreate?: AdminCreateOrConnectWithoutStocksInput
    connect?: AdminWhereUniqueInput
  }

  export type StockAssignmentCreateNestedManyWithoutStocksInput = {
    create?: XOR<StockAssignmentCreateWithoutStocksInput, StockAssignmentUncheckedCreateWithoutStocksInput> | StockAssignmentCreateWithoutStocksInput[] | StockAssignmentUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: StockAssignmentCreateOrConnectWithoutStocksInput | StockAssignmentCreateOrConnectWithoutStocksInput[]
    createMany?: StockAssignmentCreateManyStocksInputEnvelope
    connect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
  }

  export type ShipmentItemCreateNestedManyWithoutStocksInput = {
    create?: XOR<ShipmentItemCreateWithoutStocksInput, ShipmentItemUncheckedCreateWithoutStocksInput> | ShipmentItemCreateWithoutStocksInput[] | ShipmentItemUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: ShipmentItemCreateOrConnectWithoutStocksInput | ShipmentItemCreateOrConnectWithoutStocksInput[]
    createMany?: ShipmentItemCreateManyStocksInputEnvelope
    connect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
  }

  export type StockHistoryCreateNestedManyWithoutStocksInput = {
    create?: XOR<StockHistoryCreateWithoutStocksInput, StockHistoryUncheckedCreateWithoutStocksInput> | StockHistoryCreateWithoutStocksInput[] | StockHistoryUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutStocksInput | StockHistoryCreateOrConnectWithoutStocksInput[]
    createMany?: StockHistoryCreateManyStocksInputEnvelope
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutStocksInput = {
    create?: XOR<FavoriteCreateWithoutStocksInput, FavoriteUncheckedCreateWithoutStocksInput> | FavoriteCreateWithoutStocksInput[] | FavoriteUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutStocksInput | FavoriteCreateOrConnectWithoutStocksInput[]
    createMany?: FavoriteCreateManyStocksInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type StockAssignmentUncheckedCreateNestedManyWithoutStocksInput = {
    create?: XOR<StockAssignmentCreateWithoutStocksInput, StockAssignmentUncheckedCreateWithoutStocksInput> | StockAssignmentCreateWithoutStocksInput[] | StockAssignmentUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: StockAssignmentCreateOrConnectWithoutStocksInput | StockAssignmentCreateOrConnectWithoutStocksInput[]
    createMany?: StockAssignmentCreateManyStocksInputEnvelope
    connect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
  }

  export type ShipmentItemUncheckedCreateNestedManyWithoutStocksInput = {
    create?: XOR<ShipmentItemCreateWithoutStocksInput, ShipmentItemUncheckedCreateWithoutStocksInput> | ShipmentItemCreateWithoutStocksInput[] | ShipmentItemUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: ShipmentItemCreateOrConnectWithoutStocksInput | ShipmentItemCreateOrConnectWithoutStocksInput[]
    createMany?: ShipmentItemCreateManyStocksInputEnvelope
    connect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
  }

  export type StockHistoryUncheckedCreateNestedManyWithoutStocksInput = {
    create?: XOR<StockHistoryCreateWithoutStocksInput, StockHistoryUncheckedCreateWithoutStocksInput> | StockHistoryCreateWithoutStocksInput[] | StockHistoryUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutStocksInput | StockHistoryCreateOrConnectWithoutStocksInput[]
    createMany?: StockHistoryCreateManyStocksInputEnvelope
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutStocksInput = {
    create?: XOR<FavoriteCreateWithoutStocksInput, FavoriteUncheckedCreateWithoutStocksInput> | FavoriteCreateWithoutStocksInput[] | FavoriteUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutStocksInput | FavoriteCreateOrConnectWithoutStocksInput[]
    createMany?: FavoriteCreateManyStocksInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUpdateOneRequiredWithoutStocksNestedInput = {
    create?: XOR<AdminCreateWithoutStocksInput, AdminUncheckedCreateWithoutStocksInput>
    connectOrCreate?: AdminCreateOrConnectWithoutStocksInput
    upsert?: AdminUpsertWithoutStocksInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutStocksInput, AdminUpdateWithoutStocksInput>, AdminUncheckedUpdateWithoutStocksInput>
  }

  export type StockAssignmentUpdateManyWithoutStocksNestedInput = {
    create?: XOR<StockAssignmentCreateWithoutStocksInput, StockAssignmentUncheckedCreateWithoutStocksInput> | StockAssignmentCreateWithoutStocksInput[] | StockAssignmentUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: StockAssignmentCreateOrConnectWithoutStocksInput | StockAssignmentCreateOrConnectWithoutStocksInput[]
    upsert?: StockAssignmentUpsertWithWhereUniqueWithoutStocksInput | StockAssignmentUpsertWithWhereUniqueWithoutStocksInput[]
    createMany?: StockAssignmentCreateManyStocksInputEnvelope
    set?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    disconnect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    delete?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    connect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    update?: StockAssignmentUpdateWithWhereUniqueWithoutStocksInput | StockAssignmentUpdateWithWhereUniqueWithoutStocksInput[]
    updateMany?: StockAssignmentUpdateManyWithWhereWithoutStocksInput | StockAssignmentUpdateManyWithWhereWithoutStocksInput[]
    deleteMany?: StockAssignmentScalarWhereInput | StockAssignmentScalarWhereInput[]
  }

  export type ShipmentItemUpdateManyWithoutStocksNestedInput = {
    create?: XOR<ShipmentItemCreateWithoutStocksInput, ShipmentItemUncheckedCreateWithoutStocksInput> | ShipmentItemCreateWithoutStocksInput[] | ShipmentItemUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: ShipmentItemCreateOrConnectWithoutStocksInput | ShipmentItemCreateOrConnectWithoutStocksInput[]
    upsert?: ShipmentItemUpsertWithWhereUniqueWithoutStocksInput | ShipmentItemUpsertWithWhereUniqueWithoutStocksInput[]
    createMany?: ShipmentItemCreateManyStocksInputEnvelope
    set?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    disconnect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    delete?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    connect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    update?: ShipmentItemUpdateWithWhereUniqueWithoutStocksInput | ShipmentItemUpdateWithWhereUniqueWithoutStocksInput[]
    updateMany?: ShipmentItemUpdateManyWithWhereWithoutStocksInput | ShipmentItemUpdateManyWithWhereWithoutStocksInput[]
    deleteMany?: ShipmentItemScalarWhereInput | ShipmentItemScalarWhereInput[]
  }

  export type StockHistoryUpdateManyWithoutStocksNestedInput = {
    create?: XOR<StockHistoryCreateWithoutStocksInput, StockHistoryUncheckedCreateWithoutStocksInput> | StockHistoryCreateWithoutStocksInput[] | StockHistoryUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutStocksInput | StockHistoryCreateOrConnectWithoutStocksInput[]
    upsert?: StockHistoryUpsertWithWhereUniqueWithoutStocksInput | StockHistoryUpsertWithWhereUniqueWithoutStocksInput[]
    createMany?: StockHistoryCreateManyStocksInputEnvelope
    set?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    disconnect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    delete?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    update?: StockHistoryUpdateWithWhereUniqueWithoutStocksInput | StockHistoryUpdateWithWhereUniqueWithoutStocksInput[]
    updateMany?: StockHistoryUpdateManyWithWhereWithoutStocksInput | StockHistoryUpdateManyWithWhereWithoutStocksInput[]
    deleteMany?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutStocksNestedInput = {
    create?: XOR<FavoriteCreateWithoutStocksInput, FavoriteUncheckedCreateWithoutStocksInput> | FavoriteCreateWithoutStocksInput[] | FavoriteUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutStocksInput | FavoriteCreateOrConnectWithoutStocksInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutStocksInput | FavoriteUpsertWithWhereUniqueWithoutStocksInput[]
    createMany?: FavoriteCreateManyStocksInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutStocksInput | FavoriteUpdateWithWhereUniqueWithoutStocksInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutStocksInput | FavoriteUpdateManyWithWhereWithoutStocksInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type StockAssignmentUncheckedUpdateManyWithoutStocksNestedInput = {
    create?: XOR<StockAssignmentCreateWithoutStocksInput, StockAssignmentUncheckedCreateWithoutStocksInput> | StockAssignmentCreateWithoutStocksInput[] | StockAssignmentUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: StockAssignmentCreateOrConnectWithoutStocksInput | StockAssignmentCreateOrConnectWithoutStocksInput[]
    upsert?: StockAssignmentUpsertWithWhereUniqueWithoutStocksInput | StockAssignmentUpsertWithWhereUniqueWithoutStocksInput[]
    createMany?: StockAssignmentCreateManyStocksInputEnvelope
    set?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    disconnect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    delete?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    connect?: StockAssignmentWhereUniqueInput | StockAssignmentWhereUniqueInput[]
    update?: StockAssignmentUpdateWithWhereUniqueWithoutStocksInput | StockAssignmentUpdateWithWhereUniqueWithoutStocksInput[]
    updateMany?: StockAssignmentUpdateManyWithWhereWithoutStocksInput | StockAssignmentUpdateManyWithWhereWithoutStocksInput[]
    deleteMany?: StockAssignmentScalarWhereInput | StockAssignmentScalarWhereInput[]
  }

  export type ShipmentItemUncheckedUpdateManyWithoutStocksNestedInput = {
    create?: XOR<ShipmentItemCreateWithoutStocksInput, ShipmentItemUncheckedCreateWithoutStocksInput> | ShipmentItemCreateWithoutStocksInput[] | ShipmentItemUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: ShipmentItemCreateOrConnectWithoutStocksInput | ShipmentItemCreateOrConnectWithoutStocksInput[]
    upsert?: ShipmentItemUpsertWithWhereUniqueWithoutStocksInput | ShipmentItemUpsertWithWhereUniqueWithoutStocksInput[]
    createMany?: ShipmentItemCreateManyStocksInputEnvelope
    set?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    disconnect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    delete?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    connect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    update?: ShipmentItemUpdateWithWhereUniqueWithoutStocksInput | ShipmentItemUpdateWithWhereUniqueWithoutStocksInput[]
    updateMany?: ShipmentItemUpdateManyWithWhereWithoutStocksInput | ShipmentItemUpdateManyWithWhereWithoutStocksInput[]
    deleteMany?: ShipmentItemScalarWhereInput | ShipmentItemScalarWhereInput[]
  }

  export type StockHistoryUncheckedUpdateManyWithoutStocksNestedInput = {
    create?: XOR<StockHistoryCreateWithoutStocksInput, StockHistoryUncheckedCreateWithoutStocksInput> | StockHistoryCreateWithoutStocksInput[] | StockHistoryUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutStocksInput | StockHistoryCreateOrConnectWithoutStocksInput[]
    upsert?: StockHistoryUpsertWithWhereUniqueWithoutStocksInput | StockHistoryUpsertWithWhereUniqueWithoutStocksInput[]
    createMany?: StockHistoryCreateManyStocksInputEnvelope
    set?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    disconnect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    delete?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    update?: StockHistoryUpdateWithWhereUniqueWithoutStocksInput | StockHistoryUpdateWithWhereUniqueWithoutStocksInput[]
    updateMany?: StockHistoryUpdateManyWithWhereWithoutStocksInput | StockHistoryUpdateManyWithWhereWithoutStocksInput[]
    deleteMany?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutStocksNestedInput = {
    create?: XOR<FavoriteCreateWithoutStocksInput, FavoriteUncheckedCreateWithoutStocksInput> | FavoriteCreateWithoutStocksInput[] | FavoriteUncheckedCreateWithoutStocksInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutStocksInput | FavoriteCreateOrConnectWithoutStocksInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutStocksInput | FavoriteUpsertWithWhereUniqueWithoutStocksInput[]
    createMany?: FavoriteCreateManyStocksInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutStocksInput | FavoriteUpdateWithWhereUniqueWithoutStocksInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutStocksInput | FavoriteUpdateManyWithWhereWithoutStocksInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type StocksCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<StocksCreateWithoutAssignmentsInput, StocksUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: StocksCreateOrConnectWithoutAssignmentsInput
    connect?: StocksWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<UserCreateWithoutAssignmentsInput, UserUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type StocksUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<StocksCreateWithoutAssignmentsInput, StocksUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: StocksCreateOrConnectWithoutAssignmentsInput
    upsert?: StocksUpsertWithoutAssignmentsInput
    connect?: StocksWhereUniqueInput
    update?: XOR<XOR<StocksUpdateToOneWithWhereWithoutAssignmentsInput, StocksUpdateWithoutAssignmentsInput>, StocksUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutAssignmentsInput, UserUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentsInput
    upsert?: UserUpsertWithoutAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignmentsInput, UserUpdateWithoutAssignmentsInput>, UserUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ShipmentHistoryCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ShipmentHistoryCreateWithoutShipmentInput, ShipmentHistoryUncheckedCreateWithoutShipmentInput> | ShipmentHistoryCreateWithoutShipmentInput[] | ShipmentHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutShipmentInput | ShipmentHistoryCreateOrConnectWithoutShipmentInput[]
    createMany?: ShipmentHistoryCreateManyShipmentInputEnvelope
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
  }

  export type StockHistoryCreateNestedManyWithoutShipmentInput = {
    create?: XOR<StockHistoryCreateWithoutShipmentInput, StockHistoryUncheckedCreateWithoutShipmentInput> | StockHistoryCreateWithoutShipmentInput[] | StockHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutShipmentInput | StockHistoryCreateOrConnectWithoutShipmentInput[]
    createMany?: StockHistoryCreateManyShipmentInputEnvelope
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
  }

  export type ShipmentItemCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ShipmentItemCreateWithoutShipmentInput, ShipmentItemUncheckedCreateWithoutShipmentInput> | ShipmentItemCreateWithoutShipmentInput[] | ShipmentItemUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentItemCreateOrConnectWithoutShipmentInput | ShipmentItemCreateOrConnectWithoutShipmentInput[]
    createMany?: ShipmentItemCreateManyShipmentInputEnvelope
    connect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutShipmentsInput = {
    create?: XOR<UserCreateWithoutShipmentsInput, UserUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShipmentsInput
    connect?: UserWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutShipmentsInput = {
    create?: XOR<AdminCreateWithoutShipmentsInput, AdminUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutShipmentsInput
    connect?: AdminWhereUniqueInput
  }

  export type ShipmentHistoryUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ShipmentHistoryCreateWithoutShipmentInput, ShipmentHistoryUncheckedCreateWithoutShipmentInput> | ShipmentHistoryCreateWithoutShipmentInput[] | ShipmentHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutShipmentInput | ShipmentHistoryCreateOrConnectWithoutShipmentInput[]
    createMany?: ShipmentHistoryCreateManyShipmentInputEnvelope
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
  }

  export type StockHistoryUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<StockHistoryCreateWithoutShipmentInput, StockHistoryUncheckedCreateWithoutShipmentInput> | StockHistoryCreateWithoutShipmentInput[] | StockHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutShipmentInput | StockHistoryCreateOrConnectWithoutShipmentInput[]
    createMany?: StockHistoryCreateManyShipmentInputEnvelope
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
  }

  export type ShipmentItemUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ShipmentItemCreateWithoutShipmentInput, ShipmentItemUncheckedCreateWithoutShipmentInput> | ShipmentItemCreateWithoutShipmentInput[] | ShipmentItemUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentItemCreateOrConnectWithoutShipmentInput | ShipmentItemCreateOrConnectWithoutShipmentInput[]
    createMany?: ShipmentItemCreateManyShipmentInputEnvelope
    connect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
  }

  export type EnumShipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShipmentStatus
  }

  export type EnumVesselFieldUpdateOperationsInput = {
    set?: $Enums.Vessel
  }

  export type EnumPackagingInstructionsFieldUpdateOperationsInput = {
    set?: $Enums.PackagingInstructions
  }

  export type ShipmentHistoryUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ShipmentHistoryCreateWithoutShipmentInput, ShipmentHistoryUncheckedCreateWithoutShipmentInput> | ShipmentHistoryCreateWithoutShipmentInput[] | ShipmentHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutShipmentInput | ShipmentHistoryCreateOrConnectWithoutShipmentInput[]
    upsert?: ShipmentHistoryUpsertWithWhereUniqueWithoutShipmentInput | ShipmentHistoryUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ShipmentHistoryCreateManyShipmentInputEnvelope
    set?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    disconnect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    delete?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    update?: ShipmentHistoryUpdateWithWhereUniqueWithoutShipmentInput | ShipmentHistoryUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ShipmentHistoryUpdateManyWithWhereWithoutShipmentInput | ShipmentHistoryUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ShipmentHistoryScalarWhereInput | ShipmentHistoryScalarWhereInput[]
  }

  export type StockHistoryUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<StockHistoryCreateWithoutShipmentInput, StockHistoryUncheckedCreateWithoutShipmentInput> | StockHistoryCreateWithoutShipmentInput[] | StockHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutShipmentInput | StockHistoryCreateOrConnectWithoutShipmentInput[]
    upsert?: StockHistoryUpsertWithWhereUniqueWithoutShipmentInput | StockHistoryUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: StockHistoryCreateManyShipmentInputEnvelope
    set?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    disconnect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    delete?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    update?: StockHistoryUpdateWithWhereUniqueWithoutShipmentInput | StockHistoryUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: StockHistoryUpdateManyWithWhereWithoutShipmentInput | StockHistoryUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
  }

  export type ShipmentItemUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ShipmentItemCreateWithoutShipmentInput, ShipmentItemUncheckedCreateWithoutShipmentInput> | ShipmentItemCreateWithoutShipmentInput[] | ShipmentItemUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentItemCreateOrConnectWithoutShipmentInput | ShipmentItemCreateOrConnectWithoutShipmentInput[]
    upsert?: ShipmentItemUpsertWithWhereUniqueWithoutShipmentInput | ShipmentItemUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ShipmentItemCreateManyShipmentInputEnvelope
    set?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    disconnect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    delete?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    connect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    update?: ShipmentItemUpdateWithWhereUniqueWithoutShipmentInput | ShipmentItemUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ShipmentItemUpdateManyWithWhereWithoutShipmentInput | ShipmentItemUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ShipmentItemScalarWhereInput | ShipmentItemScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutShipmentsNestedInput = {
    create?: XOR<UserCreateWithoutShipmentsInput, UserUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShipmentsInput
    upsert?: UserUpsertWithoutShipmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShipmentsInput, UserUpdateWithoutShipmentsInput>, UserUncheckedUpdateWithoutShipmentsInput>
  }

  export type AdminUpdateOneWithoutShipmentsNestedInput = {
    create?: XOR<AdminCreateWithoutShipmentsInput, AdminUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutShipmentsInput
    upsert?: AdminUpsertWithoutShipmentsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutShipmentsInput, AdminUpdateWithoutShipmentsInput>, AdminUncheckedUpdateWithoutShipmentsInput>
  }

  export type ShipmentHistoryUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ShipmentHistoryCreateWithoutShipmentInput, ShipmentHistoryUncheckedCreateWithoutShipmentInput> | ShipmentHistoryCreateWithoutShipmentInput[] | ShipmentHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentHistoryCreateOrConnectWithoutShipmentInput | ShipmentHistoryCreateOrConnectWithoutShipmentInput[]
    upsert?: ShipmentHistoryUpsertWithWhereUniqueWithoutShipmentInput | ShipmentHistoryUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ShipmentHistoryCreateManyShipmentInputEnvelope
    set?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    disconnect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    delete?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    connect?: ShipmentHistoryWhereUniqueInput | ShipmentHistoryWhereUniqueInput[]
    update?: ShipmentHistoryUpdateWithWhereUniqueWithoutShipmentInput | ShipmentHistoryUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ShipmentHistoryUpdateManyWithWhereWithoutShipmentInput | ShipmentHistoryUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ShipmentHistoryScalarWhereInput | ShipmentHistoryScalarWhereInput[]
  }

  export type StockHistoryUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<StockHistoryCreateWithoutShipmentInput, StockHistoryUncheckedCreateWithoutShipmentInput> | StockHistoryCreateWithoutShipmentInput[] | StockHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: StockHistoryCreateOrConnectWithoutShipmentInput | StockHistoryCreateOrConnectWithoutShipmentInput[]
    upsert?: StockHistoryUpsertWithWhereUniqueWithoutShipmentInput | StockHistoryUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: StockHistoryCreateManyShipmentInputEnvelope
    set?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    disconnect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    delete?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    connect?: StockHistoryWhereUniqueInput | StockHistoryWhereUniqueInput[]
    update?: StockHistoryUpdateWithWhereUniqueWithoutShipmentInput | StockHistoryUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: StockHistoryUpdateManyWithWhereWithoutShipmentInput | StockHistoryUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
  }

  export type ShipmentItemUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ShipmentItemCreateWithoutShipmentInput, ShipmentItemUncheckedCreateWithoutShipmentInput> | ShipmentItemCreateWithoutShipmentInput[] | ShipmentItemUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentItemCreateOrConnectWithoutShipmentInput | ShipmentItemCreateOrConnectWithoutShipmentInput[]
    upsert?: ShipmentItemUpsertWithWhereUniqueWithoutShipmentInput | ShipmentItemUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ShipmentItemCreateManyShipmentInputEnvelope
    set?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    disconnect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    delete?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    connect?: ShipmentItemWhereUniqueInput | ShipmentItemWhereUniqueInput[]
    update?: ShipmentItemUpdateWithWhereUniqueWithoutShipmentInput | ShipmentItemUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ShipmentItemUpdateManyWithWhereWithoutShipmentInput | ShipmentItemUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ShipmentItemScalarWhereInput | ShipmentItemScalarWhereInput[]
  }

  export type ShipmentCreateNestedOneWithoutStocksInput = {
    create?: XOR<ShipmentCreateWithoutStocksInput, ShipmentUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutStocksInput
    connect?: ShipmentWhereUniqueInput
  }

  export type StocksCreateNestedOneWithoutShipmentItemsInput = {
    create?: XOR<StocksCreateWithoutShipmentItemsInput, StocksUncheckedCreateWithoutShipmentItemsInput>
    connectOrCreate?: StocksCreateOrConnectWithoutShipmentItemsInput
    connect?: StocksWhereUniqueInput
  }

  export type ShipmentUpdateOneRequiredWithoutStocksNestedInput = {
    create?: XOR<ShipmentCreateWithoutStocksInput, ShipmentUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutStocksInput
    upsert?: ShipmentUpsertWithoutStocksInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutStocksInput, ShipmentUpdateWithoutStocksInput>, ShipmentUncheckedUpdateWithoutStocksInput>
  }

  export type StocksUpdateOneRequiredWithoutShipmentItemsNestedInput = {
    create?: XOR<StocksCreateWithoutShipmentItemsInput, StocksUncheckedCreateWithoutShipmentItemsInput>
    connectOrCreate?: StocksCreateOrConnectWithoutShipmentItemsInput
    upsert?: StocksUpsertWithoutShipmentItemsInput
    connect?: StocksWhereUniqueInput
    update?: XOR<XOR<StocksUpdateToOneWithWhereWithoutShipmentItemsInput, StocksUpdateWithoutShipmentItemsInput>, StocksUncheckedUpdateWithoutShipmentItemsInput>
  }

  export type StocksCreateNestedOneWithoutHistoryInput = {
    create?: XOR<StocksCreateWithoutHistoryInput, StocksUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: StocksCreateOrConnectWithoutHistoryInput
    connect?: StocksWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStockHistoryInput = {
    create?: XOR<UserCreateWithoutStockHistoryInput, UserUncheckedCreateWithoutStockHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutStockHistoryInput = {
    create?: XOR<AdminCreateWithoutStockHistoryInput, AdminUncheckedCreateWithoutStockHistoryInput>
    connectOrCreate?: AdminCreateOrConnectWithoutStockHistoryInput
    connect?: AdminWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutStockHistoryInput = {
    create?: XOR<ShipmentCreateWithoutStockHistoryInput, ShipmentUncheckedCreateWithoutStockHistoryInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutStockHistoryInput
    connect?: ShipmentWhereUniqueInput
  }

  export type StocksUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<StocksCreateWithoutHistoryInput, StocksUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: StocksCreateOrConnectWithoutHistoryInput
    upsert?: StocksUpsertWithoutHistoryInput
    connect?: StocksWhereUniqueInput
    update?: XOR<XOR<StocksUpdateToOneWithWhereWithoutHistoryInput, StocksUpdateWithoutHistoryInput>, StocksUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneWithoutStockHistoryNestedInput = {
    create?: XOR<UserCreateWithoutStockHistoryInput, UserUncheckedCreateWithoutStockHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockHistoryInput
    upsert?: UserUpsertWithoutStockHistoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStockHistoryInput, UserUpdateWithoutStockHistoryInput>, UserUncheckedUpdateWithoutStockHistoryInput>
  }

  export type AdminUpdateOneWithoutStockHistoryNestedInput = {
    create?: XOR<AdminCreateWithoutStockHistoryInput, AdminUncheckedCreateWithoutStockHistoryInput>
    connectOrCreate?: AdminCreateOrConnectWithoutStockHistoryInput
    upsert?: AdminUpsertWithoutStockHistoryInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutStockHistoryInput, AdminUpdateWithoutStockHistoryInput>, AdminUncheckedUpdateWithoutStockHistoryInput>
  }

  export type ShipmentUpdateOneWithoutStockHistoryNestedInput = {
    create?: XOR<ShipmentCreateWithoutStockHistoryInput, ShipmentUncheckedCreateWithoutStockHistoryInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutStockHistoryInput
    upsert?: ShipmentUpsertWithoutStockHistoryInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutStockHistoryInput, ShipmentUpdateWithoutStockHistoryInput>, ShipmentUncheckedUpdateWithoutStockHistoryInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ShipmentCreateNestedOneWithoutHistoryEntriesInput = {
    create?: XOR<ShipmentCreateWithoutHistoryEntriesInput, ShipmentUncheckedCreateWithoutHistoryEntriesInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutHistoryEntriesInput
    connect?: ShipmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutShipmentHistoryInput = {
    create?: XOR<UserCreateWithoutShipmentHistoryInput, UserUncheckedCreateWithoutShipmentHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutShipmentHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutShipmentHistoryInput = {
    create?: XOR<AdminCreateWithoutShipmentHistoryInput, AdminUncheckedCreateWithoutShipmentHistoryInput>
    connectOrCreate?: AdminCreateOrConnectWithoutShipmentHistoryInput
    connect?: AdminWhereUniqueInput
  }

  export type ShipmentUpdateOneRequiredWithoutHistoryEntriesNestedInput = {
    create?: XOR<ShipmentCreateWithoutHistoryEntriesInput, ShipmentUncheckedCreateWithoutHistoryEntriesInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutHistoryEntriesInput
    upsert?: ShipmentUpsertWithoutHistoryEntriesInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutHistoryEntriesInput, ShipmentUpdateWithoutHistoryEntriesInput>, ShipmentUncheckedUpdateWithoutHistoryEntriesInput>
  }

  export type UserUpdateOneWithoutShipmentHistoryNestedInput = {
    create?: XOR<UserCreateWithoutShipmentHistoryInput, UserUncheckedCreateWithoutShipmentHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutShipmentHistoryInput
    upsert?: UserUpsertWithoutShipmentHistoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShipmentHistoryInput, UserUpdateWithoutShipmentHistoryInput>, UserUncheckedUpdateWithoutShipmentHistoryInput>
  }

  export type AdminUpdateOneWithoutShipmentHistoryNestedInput = {
    create?: XOR<AdminCreateWithoutShipmentHistoryInput, AdminUncheckedCreateWithoutShipmentHistoryInput>
    connectOrCreate?: AdminCreateOrConnectWithoutShipmentHistoryInput
    upsert?: AdminUpsertWithoutShipmentHistoryInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutShipmentHistoryInput, AdminUpdateWithoutShipmentHistoryInput>, AdminUncheckedUpdateWithoutShipmentHistoryInput>
  }

  export type AdminCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AdminCreateWithoutNotificationsInput, AdminUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutNotificationsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<AdminCreateWithoutNotificationsInput, AdminUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutNotificationsInput
    upsert?: AdminUpsertWithoutNotificationsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutNotificationsInput, AdminUpdateWithoutNotificationsInput>, AdminUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactsInput, UserUpdateWithoutContactsInput>, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type StocksCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<StocksCreateWithoutFavoritesInput, StocksUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: StocksCreateOrConnectWithoutFavoritesInput
    connect?: StocksWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type StocksUpdateOneWithoutFavoritesNestedInput = {
    create?: XOR<StocksCreateWithoutFavoritesInput, StocksUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: StocksCreateOrConnectWithoutFavoritesInput
    upsert?: StocksUpsertWithoutFavoritesInput
    disconnect?: StocksWhereInput | boolean
    delete?: StocksWhereInput | boolean
    connect?: StocksWhereUniqueInput
    update?: XOR<XOR<StocksUpdateToOneWithWhereWithoutFavoritesInput, StocksUpdateWithoutFavoritesInput>, StocksUncheckedUpdateWithoutFavoritesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumBrokerFilter<$PrismaModel = never> = {
    equals?: $Enums.Broker | EnumBrokerFieldRefInput<$PrismaModel>
    in?: $Enums.Broker[] | ListEnumBrokerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Broker[] | ListEnumBrokerFieldRefInput<$PrismaModel>
    not?: NestedEnumBrokerFilter<$PrismaModel> | $Enums.Broker
  }

  export type NestedEnumTeaGradeFilter<$PrismaModel = never> = {
    equals?: $Enums.TeaGrade | EnumTeaGradeFieldRefInput<$PrismaModel>
    in?: $Enums.TeaGrade[] | ListEnumTeaGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeaGrade[] | ListEnumTeaGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumTeaGradeFilter<$PrismaModel> | $Enums.TeaGrade
  }

  export type NestedEnumTeaCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TeaCategory | EnumTeaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TeaCategory[] | ListEnumTeaCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeaCategory[] | ListEnumTeaCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTeaCategoryFilter<$PrismaModel> | $Enums.TeaCategory
  }

  export type NestedEnumBrokerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Broker | EnumBrokerFieldRefInput<$PrismaModel>
    in?: $Enums.Broker[] | ListEnumBrokerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Broker[] | ListEnumBrokerFieldRefInput<$PrismaModel>
    not?: NestedEnumBrokerWithAggregatesFilter<$PrismaModel> | $Enums.Broker
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBrokerFilter<$PrismaModel>
    _max?: NestedEnumBrokerFilter<$PrismaModel>
  }

  export type NestedEnumTeaGradeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeaGrade | EnumTeaGradeFieldRefInput<$PrismaModel>
    in?: $Enums.TeaGrade[] | ListEnumTeaGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeaGrade[] | ListEnumTeaGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumTeaGradeWithAggregatesFilter<$PrismaModel> | $Enums.TeaGrade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeaGradeFilter<$PrismaModel>
    _max?: NestedEnumTeaGradeFilter<$PrismaModel>
  }

  export type NestedEnumTeaCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeaCategory | EnumTeaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TeaCategory[] | ListEnumTeaCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeaCategory[] | ListEnumTeaCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTeaCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TeaCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeaCategoryFilter<$PrismaModel>
    _max?: NestedEnumTeaCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumShipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusFilter<$PrismaModel> | $Enums.ShipmentStatus
  }

  export type NestedEnumVesselFilter<$PrismaModel = never> = {
    equals?: $Enums.Vessel | EnumVesselFieldRefInput<$PrismaModel>
    in?: $Enums.Vessel[] | ListEnumVesselFieldRefInput<$PrismaModel>
    notIn?: $Enums.Vessel[] | ListEnumVesselFieldRefInput<$PrismaModel>
    not?: NestedEnumVesselFilter<$PrismaModel> | $Enums.Vessel
  }

  export type NestedEnumPackagingInstructionsFilter<$PrismaModel = never> = {
    equals?: $Enums.PackagingInstructions | EnumPackagingInstructionsFieldRefInput<$PrismaModel>
    in?: $Enums.PackagingInstructions[] | ListEnumPackagingInstructionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackagingInstructions[] | ListEnumPackagingInstructionsFieldRefInput<$PrismaModel>
    not?: NestedEnumPackagingInstructionsFilter<$PrismaModel> | $Enums.PackagingInstructions
  }

  export type NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumShipmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumVesselWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Vessel | EnumVesselFieldRefInput<$PrismaModel>
    in?: $Enums.Vessel[] | ListEnumVesselFieldRefInput<$PrismaModel>
    notIn?: $Enums.Vessel[] | ListEnumVesselFieldRefInput<$PrismaModel>
    not?: NestedEnumVesselWithAggregatesFilter<$PrismaModel> | $Enums.Vessel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVesselFilter<$PrismaModel>
    _max?: NestedEnumVesselFilter<$PrismaModel>
  }

  export type NestedEnumPackagingInstructionsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackagingInstructions | EnumPackagingInstructionsFieldRefInput<$PrismaModel>
    in?: $Enums.PackagingInstructions[] | ListEnumPackagingInstructionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackagingInstructions[] | ListEnumPackagingInstructionsFieldRefInput<$PrismaModel>
    not?: NestedEnumPackagingInstructionsWithAggregatesFilter<$PrismaModel> | $Enums.PackagingInstructions
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPackagingInstructionsFilter<$PrismaModel>
    _max?: NestedEnumPackagingInstructionsFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CatalogCreateWithoutAdminInput = {
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogUncheckedCreateWithoutAdminInput = {
    id?: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCreateOrConnectWithoutAdminInput = {
    where: CatalogWhereUniqueInput
    create: XOR<CatalogCreateWithoutAdminInput, CatalogUncheckedCreateWithoutAdminInput>
  }

  export type CatalogCreateManyAdminInputEnvelope = {
    data: CatalogCreateManyAdminInput | CatalogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type StocksCreateWithoutAdminInput = {
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: StockAssignmentCreateNestedManyWithoutStocksInput
    shipmentItems?: ShipmentItemCreateNestedManyWithoutStocksInput
    history?: StockHistoryCreateNestedManyWithoutStocksInput
    favorites?: FavoriteCreateNestedManyWithoutStocksInput
  }

  export type StocksUncheckedCreateWithoutAdminInput = {
    id?: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutStocksInput
    shipmentItems?: ShipmentItemUncheckedCreateNestedManyWithoutStocksInput
    history?: StockHistoryUncheckedCreateNestedManyWithoutStocksInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutStocksInput
  }

  export type StocksCreateOrConnectWithoutAdminInput = {
    where: StocksWhereUniqueInput
    create: XOR<StocksCreateWithoutAdminInput, StocksUncheckedCreateWithoutAdminInput>
  }

  export type StocksCreateManyAdminInputEnvelope = {
    data: StocksCreateManyAdminInput | StocksCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type SellingPriceCreateWithoutAdminInput = {
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    purchasePrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingPriceUncheckedCreateWithoutAdminInput = {
    id?: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    purchasePrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingPriceCreateOrConnectWithoutAdminInput = {
    where: SellingPriceWhereUniqueInput
    create: XOR<SellingPriceCreateWithoutAdminInput, SellingPriceUncheckedCreateWithoutAdminInput>
  }

  export type SellingPriceCreateManyAdminInputEnvelope = {
    data: SellingPriceCreateManyAdminInput | SellingPriceCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type OutLotsCreateWithoutAdminInput = {
    auction: string
    lotNo: string
    broker: $Enums.Broker
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    netWeight: number
    totalWeight: number
    baselinePrice: number
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutLotsUncheckedCreateWithoutAdminInput = {
    id?: number
    auction: string
    lotNo: string
    broker: $Enums.Broker
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    netWeight: number
    totalWeight: number
    baselinePrice: number
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutLotsCreateOrConnectWithoutAdminInput = {
    where: OutLotsWhereUniqueInput
    create: XOR<OutLotsCreateWithoutAdminInput, OutLotsUncheckedCreateWithoutAdminInput>
  }

  export type OutLotsCreateManyAdminInputEnvelope = {
    data: OutLotsCreateManyAdminInput | OutLotsCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminNotificationCreateWithoutAdminInput = {
    message: string
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminNotificationUncheckedCreateWithoutAdminInput = {
    id?: number
    message: string
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminNotificationCreateOrConnectWithoutAdminInput = {
    where: AdminNotificationWhereUniqueInput
    create: XOR<AdminNotificationCreateWithoutAdminInput, AdminNotificationUncheckedCreateWithoutAdminInput>
  }

  export type AdminNotificationCreateManyAdminInputEnvelope = {
    data: AdminNotificationCreateManyAdminInput | AdminNotificationCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentCreateWithoutAdminInput = {
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryCreateNestedManyWithoutShipmentInput
    stockHistory?: StockHistoryCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemCreateNestedManyWithoutShipmentInput
    user: UserCreateNestedOneWithoutShipmentsInput
  }

  export type ShipmentUncheckedCreateWithoutAdminInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    userCognitoId: string
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutAdminInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutAdminInput, ShipmentUncheckedCreateWithoutAdminInput>
  }

  export type ShipmentCreateManyAdminInputEnvelope = {
    data: ShipmentCreateManyAdminInput | ShipmentCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type StockHistoryCreateWithoutAdminInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    stocks: StocksCreateNestedOneWithoutHistoryInput
    user?: UserCreateNestedOneWithoutStockHistoryInput
    shipment?: ShipmentCreateNestedOneWithoutStockHistoryInput
  }

  export type StockHistoryUncheckedCreateWithoutAdminInput = {
    id?: number
    stocksId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: number | null
  }

  export type StockHistoryCreateOrConnectWithoutAdminInput = {
    where: StockHistoryWhereUniqueInput
    create: XOR<StockHistoryCreateWithoutAdminInput, StockHistoryUncheckedCreateWithoutAdminInput>
  }

  export type StockHistoryCreateManyAdminInputEnvelope = {
    data: StockHistoryCreateManyAdminInput | StockHistoryCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentHistoryCreateWithoutAdminInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    shipment: ShipmentCreateNestedOneWithoutHistoryEntriesInput
    user?: UserCreateNestedOneWithoutShipmentHistoryInput
  }

  export type ShipmentHistoryUncheckedCreateWithoutAdminInput = {
    id?: number
    shipmentId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryCreateOrConnectWithoutAdminInput = {
    where: ShipmentHistoryWhereUniqueInput
    create: XOR<ShipmentHistoryCreateWithoutAdminInput, ShipmentHistoryUncheckedCreateWithoutAdminInput>
  }

  export type ShipmentHistoryCreateManyAdminInputEnvelope = {
    data: ShipmentHistoryCreateManyAdminInput | ShipmentHistoryCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type CatalogUpsertWithWhereUniqueWithoutAdminInput = {
    where: CatalogWhereUniqueInput
    update: XOR<CatalogUpdateWithoutAdminInput, CatalogUncheckedUpdateWithoutAdminInput>
    create: XOR<CatalogCreateWithoutAdminInput, CatalogUncheckedCreateWithoutAdminInput>
  }

  export type CatalogUpdateWithWhereUniqueWithoutAdminInput = {
    where: CatalogWhereUniqueInput
    data: XOR<CatalogUpdateWithoutAdminInput, CatalogUncheckedUpdateWithoutAdminInput>
  }

  export type CatalogUpdateManyWithWhereWithoutAdminInput = {
    where: CatalogScalarWhereInput
    data: XOR<CatalogUpdateManyMutationInput, CatalogUncheckedUpdateManyWithoutAdminInput>
  }

  export type CatalogScalarWhereInput = {
    AND?: CatalogScalarWhereInput | CatalogScalarWhereInput[]
    OR?: CatalogScalarWhereInput[]
    NOT?: CatalogScalarWhereInput | CatalogScalarWhereInput[]
    id?: IntFilter<"Catalog"> | number
    broker?: EnumBrokerFilter<"Catalog"> | $Enums.Broker
    lotNo?: StringFilter<"Catalog"> | string
    sellingMark?: StringFilter<"Catalog"> | string
    grade?: EnumTeaGradeFilter<"Catalog"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"Catalog"> | string
    saleCode?: StringFilter<"Catalog"> | string
    category?: EnumTeaCategoryFilter<"Catalog"> | $Enums.TeaCategory
    reprint?: StringFilter<"Catalog"> | string
    bags?: IntFilter<"Catalog"> | number
    netWeight?: FloatFilter<"Catalog"> | number
    totalWeight?: FloatFilter<"Catalog"> | number
    askingPrice?: FloatFilter<"Catalog"> | number
    producerCountry?: StringNullableFilter<"Catalog"> | string | null
    manufactureDate?: DateTimeFilter<"Catalog"> | Date | string
    adminCognitoId?: StringNullableFilter<"Catalog"> | string | null
    userCognitoId?: StringNullableFilter<"Catalog"> | string | null
    createdAt?: DateTimeFilter<"Catalog"> | Date | string
    updatedAt?: DateTimeFilter<"Catalog"> | Date | string
  }

  export type StocksUpsertWithWhereUniqueWithoutAdminInput = {
    where: StocksWhereUniqueInput
    update: XOR<StocksUpdateWithoutAdminInput, StocksUncheckedUpdateWithoutAdminInput>
    create: XOR<StocksCreateWithoutAdminInput, StocksUncheckedCreateWithoutAdminInput>
  }

  export type StocksUpdateWithWhereUniqueWithoutAdminInput = {
    where: StocksWhereUniqueInput
    data: XOR<StocksUpdateWithoutAdminInput, StocksUncheckedUpdateWithoutAdminInput>
  }

  export type StocksUpdateManyWithWhereWithoutAdminInput = {
    where: StocksScalarWhereInput
    data: XOR<StocksUpdateManyMutationInput, StocksUncheckedUpdateManyWithoutAdminInput>
  }

  export type StocksScalarWhereInput = {
    AND?: StocksScalarWhereInput | StocksScalarWhereInput[]
    OR?: StocksScalarWhereInput[]
    NOT?: StocksScalarWhereInput | StocksScalarWhereInput[]
    id?: IntFilter<"Stocks"> | number
    saleCode?: StringFilter<"Stocks"> | string
    broker?: EnumBrokerFilter<"Stocks"> | $Enums.Broker
    lotNo?: StringFilter<"Stocks"> | string
    mark?: StringFilter<"Stocks"> | string
    grade?: EnumTeaGradeFilter<"Stocks"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"Stocks"> | string
    bags?: IntFilter<"Stocks"> | number
    weight?: FloatFilter<"Stocks"> | number
    purchaseValue?: FloatFilter<"Stocks"> | number
    totalPurchaseValue?: FloatFilter<"Stocks"> | number
    agingDays?: IntFilter<"Stocks"> | number
    penalty?: FloatFilter<"Stocks"> | number
    bgtCommission?: FloatFilter<"Stocks"> | number
    maerskFee?: FloatFilter<"Stocks"> | number
    commission?: FloatFilter<"Stocks"> | number
    netPrice?: FloatFilter<"Stocks"> | number
    total?: FloatFilter<"Stocks"> | number
    batchNumber?: StringNullableFilter<"Stocks"> | string | null
    lowStockThreshold?: FloatNullableFilter<"Stocks"> | number | null
    adminCognitoId?: StringFilter<"Stocks"> | string
    createdAt?: DateTimeFilter<"Stocks"> | Date | string
    updatedAt?: DateTimeFilter<"Stocks"> | Date | string
  }

  export type SellingPriceUpsertWithWhereUniqueWithoutAdminInput = {
    where: SellingPriceWhereUniqueInput
    update: XOR<SellingPriceUpdateWithoutAdminInput, SellingPriceUncheckedUpdateWithoutAdminInput>
    create: XOR<SellingPriceCreateWithoutAdminInput, SellingPriceUncheckedCreateWithoutAdminInput>
  }

  export type SellingPriceUpdateWithWhereUniqueWithoutAdminInput = {
    where: SellingPriceWhereUniqueInput
    data: XOR<SellingPriceUpdateWithoutAdminInput, SellingPriceUncheckedUpdateWithoutAdminInput>
  }

  export type SellingPriceUpdateManyWithWhereWithoutAdminInput = {
    where: SellingPriceScalarWhereInput
    data: XOR<SellingPriceUpdateManyMutationInput, SellingPriceUncheckedUpdateManyWithoutAdminInput>
  }

  export type SellingPriceScalarWhereInput = {
    AND?: SellingPriceScalarWhereInput | SellingPriceScalarWhereInput[]
    OR?: SellingPriceScalarWhereInput[]
    NOT?: SellingPriceScalarWhereInput | SellingPriceScalarWhereInput[]
    id?: IntFilter<"SellingPrice"> | number
    broker?: EnumBrokerFilter<"SellingPrice"> | $Enums.Broker
    lotNo?: StringFilter<"SellingPrice"> | string
    sellingMark?: StringFilter<"SellingPrice"> | string
    grade?: EnumTeaGradeFilter<"SellingPrice"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"SellingPrice"> | string
    saleCode?: StringFilter<"SellingPrice"> | string
    category?: EnumTeaCategoryFilter<"SellingPrice"> | $Enums.TeaCategory
    reprint?: StringFilter<"SellingPrice"> | string
    bags?: IntFilter<"SellingPrice"> | number
    netWeight?: FloatFilter<"SellingPrice"> | number
    totalWeight?: FloatFilter<"SellingPrice"> | number
    askingPrice?: FloatFilter<"SellingPrice"> | number
    purchasePrice?: FloatFilter<"SellingPrice"> | number
    producerCountry?: StringNullableFilter<"SellingPrice"> | string | null
    manufactureDate?: DateTimeFilter<"SellingPrice"> | Date | string
    adminCognitoId?: StringNullableFilter<"SellingPrice"> | string | null
    userCognitoId?: StringNullableFilter<"SellingPrice"> | string | null
    createdAt?: DateTimeFilter<"SellingPrice"> | Date | string
    updatedAt?: DateTimeFilter<"SellingPrice"> | Date | string
  }

  export type OutLotsUpsertWithWhereUniqueWithoutAdminInput = {
    where: OutLotsWhereUniqueInput
    update: XOR<OutLotsUpdateWithoutAdminInput, OutLotsUncheckedUpdateWithoutAdminInput>
    create: XOR<OutLotsCreateWithoutAdminInput, OutLotsUncheckedCreateWithoutAdminInput>
  }

  export type OutLotsUpdateWithWhereUniqueWithoutAdminInput = {
    where: OutLotsWhereUniqueInput
    data: XOR<OutLotsUpdateWithoutAdminInput, OutLotsUncheckedUpdateWithoutAdminInput>
  }

  export type OutLotsUpdateManyWithWhereWithoutAdminInput = {
    where: OutLotsScalarWhereInput
    data: XOR<OutLotsUpdateManyMutationInput, OutLotsUncheckedUpdateManyWithoutAdminInput>
  }

  export type OutLotsScalarWhereInput = {
    AND?: OutLotsScalarWhereInput | OutLotsScalarWhereInput[]
    OR?: OutLotsScalarWhereInput[]
    NOT?: OutLotsScalarWhereInput | OutLotsScalarWhereInput[]
    id?: IntFilter<"OutLots"> | number
    auction?: StringFilter<"OutLots"> | string
    lotNo?: StringFilter<"OutLots"> | string
    broker?: EnumBrokerFilter<"OutLots"> | $Enums.Broker
    sellingMark?: StringFilter<"OutLots"> | string
    grade?: EnumTeaGradeFilter<"OutLots"> | $Enums.TeaGrade
    invoiceNo?: StringFilter<"OutLots"> | string
    bags?: IntFilter<"OutLots"> | number
    netWeight?: FloatFilter<"OutLots"> | number
    totalWeight?: FloatFilter<"OutLots"> | number
    baselinePrice?: FloatFilter<"OutLots"> | number
    manufactureDate?: DateTimeFilter<"OutLots"> | Date | string
    adminCognitoId?: StringNullableFilter<"OutLots"> | string | null
    userCognitoId?: StringNullableFilter<"OutLots"> | string | null
    createdAt?: DateTimeFilter<"OutLots"> | Date | string
    updatedAt?: DateTimeFilter<"OutLots"> | Date | string
  }

  export type AdminNotificationUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminNotificationWhereUniqueInput
    update: XOR<AdminNotificationUpdateWithoutAdminInput, AdminNotificationUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminNotificationCreateWithoutAdminInput, AdminNotificationUncheckedCreateWithoutAdminInput>
  }

  export type AdminNotificationUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminNotificationWhereUniqueInput
    data: XOR<AdminNotificationUpdateWithoutAdminInput, AdminNotificationUncheckedUpdateWithoutAdminInput>
  }

  export type AdminNotificationUpdateManyWithWhereWithoutAdminInput = {
    where: AdminNotificationScalarWhereInput
    data: XOR<AdminNotificationUpdateManyMutationInput, AdminNotificationUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminNotificationScalarWhereInput = {
    AND?: AdminNotificationScalarWhereInput | AdminNotificationScalarWhereInput[]
    OR?: AdminNotificationScalarWhereInput[]
    NOT?: AdminNotificationScalarWhereInput | AdminNotificationScalarWhereInput[]
    id?: IntFilter<"AdminNotification"> | number
    adminCognitoId?: StringFilter<"AdminNotification"> | string
    message?: StringFilter<"AdminNotification"> | string
    details?: JsonFilter<"AdminNotification">
    createdAt?: DateTimeFilter<"AdminNotification"> | Date | string
  }

  export type ShipmentUpsertWithWhereUniqueWithoutAdminInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutAdminInput, ShipmentUncheckedUpdateWithoutAdminInput>
    create: XOR<ShipmentCreateWithoutAdminInput, ShipmentUncheckedCreateWithoutAdminInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutAdminInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutAdminInput, ShipmentUncheckedUpdateWithoutAdminInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutAdminInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutAdminInput>
  }

  export type ShipmentScalarWhereInput = {
    AND?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
    OR?: ShipmentScalarWhereInput[]
    NOT?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
    id?: IntFilter<"Shipment"> | number
    shipmentDate?: DateTimeFilter<"Shipment"> | Date | string
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    userCognitoId?: StringFilter<"Shipment"> | string
    adminCognitoId?: StringNullableFilter<"Shipment"> | string | null
    consignee?: StringFilter<"Shipment"> | string
    vessel?: EnumVesselFilter<"Shipment"> | $Enums.Vessel
    shipmark?: StringFilter<"Shipment"> | string
    packagingInstructions?: EnumPackagingInstructionsFilter<"Shipment"> | $Enums.PackagingInstructions
    additionalInstructions?: StringNullableFilter<"Shipment"> | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
  }

  export type StockHistoryUpsertWithWhereUniqueWithoutAdminInput = {
    where: StockHistoryWhereUniqueInput
    update: XOR<StockHistoryUpdateWithoutAdminInput, StockHistoryUncheckedUpdateWithoutAdminInput>
    create: XOR<StockHistoryCreateWithoutAdminInput, StockHistoryUncheckedCreateWithoutAdminInput>
  }

  export type StockHistoryUpdateWithWhereUniqueWithoutAdminInput = {
    where: StockHistoryWhereUniqueInput
    data: XOR<StockHistoryUpdateWithoutAdminInput, StockHistoryUncheckedUpdateWithoutAdminInput>
  }

  export type StockHistoryUpdateManyWithWhereWithoutAdminInput = {
    where: StockHistoryScalarWhereInput
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyWithoutAdminInput>
  }

  export type StockHistoryScalarWhereInput = {
    AND?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
    OR?: StockHistoryScalarWhereInput[]
    NOT?: StockHistoryScalarWhereInput | StockHistoryScalarWhereInput[]
    id?: IntFilter<"StockHistory"> | number
    stocksId?: IntFilter<"StockHistory"> | number
    action?: StringFilter<"StockHistory"> | string
    timestamp?: DateTimeFilter<"StockHistory"> | Date | string
    userCognitoId?: StringNullableFilter<"StockHistory"> | string | null
    adminCognitoId?: StringNullableFilter<"StockHistory"> | string | null
    details?: JsonNullableFilter<"StockHistory">
    shipmentId?: IntNullableFilter<"StockHistory"> | number | null
  }

  export type ShipmentHistoryUpsertWithWhereUniqueWithoutAdminInput = {
    where: ShipmentHistoryWhereUniqueInput
    update: XOR<ShipmentHistoryUpdateWithoutAdminInput, ShipmentHistoryUncheckedUpdateWithoutAdminInput>
    create: XOR<ShipmentHistoryCreateWithoutAdminInput, ShipmentHistoryUncheckedCreateWithoutAdminInput>
  }

  export type ShipmentHistoryUpdateWithWhereUniqueWithoutAdminInput = {
    where: ShipmentHistoryWhereUniqueInput
    data: XOR<ShipmentHistoryUpdateWithoutAdminInput, ShipmentHistoryUncheckedUpdateWithoutAdminInput>
  }

  export type ShipmentHistoryUpdateManyWithWhereWithoutAdminInput = {
    where: ShipmentHistoryScalarWhereInput
    data: XOR<ShipmentHistoryUpdateManyMutationInput, ShipmentHistoryUncheckedUpdateManyWithoutAdminInput>
  }

  export type ShipmentHistoryScalarWhereInput = {
    AND?: ShipmentHistoryScalarWhereInput | ShipmentHistoryScalarWhereInput[]
    OR?: ShipmentHistoryScalarWhereInput[]
    NOT?: ShipmentHistoryScalarWhereInput | ShipmentHistoryScalarWhereInput[]
    id?: IntFilter<"ShipmentHistory"> | number
    shipmentId?: IntFilter<"ShipmentHistory"> | number
    action?: StringFilter<"ShipmentHistory"> | string
    timestamp?: DateTimeFilter<"ShipmentHistory"> | Date | string
    userCognitoId?: StringNullableFilter<"ShipmentHistory"> | string | null
    adminCognitoId?: StringNullableFilter<"ShipmentHistory"> | string | null
    details?: JsonNullableFilter<"ShipmentHistory">
  }

  export type ShipmentCreateWithoutUserInput = {
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryCreateNestedManyWithoutShipmentInput
    stockHistory?: StockHistoryCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemCreateNestedManyWithoutShipmentInput
    admin?: AdminCreateNestedOneWithoutShipmentsInput
  }

  export type ShipmentUncheckedCreateWithoutUserInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    adminCognitoId?: string | null
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutUserInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput>
  }

  export type ShipmentCreateManyUserInputEnvelope = {
    data: ShipmentCreateManyUserInput | ShipmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StockHistoryCreateWithoutUserInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    stocks: StocksCreateNestedOneWithoutHistoryInput
    admin?: AdminCreateNestedOneWithoutStockHistoryInput
    shipment?: ShipmentCreateNestedOneWithoutStockHistoryInput
  }

  export type StockHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    stocksId: number
    action: string
    timestamp?: Date | string
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: number | null
  }

  export type StockHistoryCreateOrConnectWithoutUserInput = {
    where: StockHistoryWhereUniqueInput
    create: XOR<StockHistoryCreateWithoutUserInput, StockHistoryUncheckedCreateWithoutUserInput>
  }

  export type StockHistoryCreateManyUserInputEnvelope = {
    data: StockHistoryCreateManyUserInput | StockHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentHistoryCreateWithoutUserInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    shipment: ShipmentCreateNestedOneWithoutHistoryEntriesInput
    admin?: AdminCreateNestedOneWithoutShipmentHistoryInput
  }

  export type ShipmentHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    shipmentId: number
    action: string
    timestamp?: Date | string
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryCreateOrConnectWithoutUserInput = {
    where: ShipmentHistoryWhereUniqueInput
    create: XOR<ShipmentHistoryCreateWithoutUserInput, ShipmentHistoryUncheckedCreateWithoutUserInput>
  }

  export type ShipmentHistoryCreateManyUserInputEnvelope = {
    data: ShipmentHistoryCreateManyUserInput | ShipmentHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutUserInput = {
    createdAt?: Date | string
    stocks?: StocksCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    id?: number
    stocksId?: number | null
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StockAssignmentCreateWithoutUserInput = {
    assignedWeight: number
    assignedAt?: Date | string
    stocks: StocksCreateNestedOneWithoutAssignmentsInput
  }

  export type StockAssignmentUncheckedCreateWithoutUserInput = {
    id?: number
    stocksId: number
    assignedWeight: number
    assignedAt?: Date | string
  }

  export type StockAssignmentCreateOrConnectWithoutUserInput = {
    where: StockAssignmentWhereUniqueInput
    create: XOR<StockAssignmentCreateWithoutUserInput, StockAssignmentUncheckedCreateWithoutUserInput>
  }

  export type StockAssignmentCreateManyUserInputEnvelope = {
    data: StockAssignmentCreateManyUserInput | StockAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutUserInput = {
    name: string
    email: string
    subject?: string | null
    message: string
    privacyConsent: boolean
    createdAt?: Date | string
  }

  export type ContactUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email: string
    subject?: string | null
    message: string
    privacyConsent: boolean
    createdAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutUserInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactCreateManyUserInputEnvelope = {
    data: ContactCreateManyUserInput | ContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutUserInput, ShipmentUncheckedUpdateWithoutUserInput>
    create: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutUserInput, ShipmentUncheckedUpdateWithoutUserInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutUserInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutUserInput>
  }

  export type StockHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: StockHistoryWhereUniqueInput
    update: XOR<StockHistoryUpdateWithoutUserInput, StockHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<StockHistoryCreateWithoutUserInput, StockHistoryUncheckedCreateWithoutUserInput>
  }

  export type StockHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: StockHistoryWhereUniqueInput
    data: XOR<StockHistoryUpdateWithoutUserInput, StockHistoryUncheckedUpdateWithoutUserInput>
  }

  export type StockHistoryUpdateManyWithWhereWithoutUserInput = {
    where: StockHistoryScalarWhereInput
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ShipmentHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ShipmentHistoryWhereUniqueInput
    update: XOR<ShipmentHistoryUpdateWithoutUserInput, ShipmentHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ShipmentHistoryCreateWithoutUserInput, ShipmentHistoryUncheckedCreateWithoutUserInput>
  }

  export type ShipmentHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ShipmentHistoryWhereUniqueInput
    data: XOR<ShipmentHistoryUpdateWithoutUserInput, ShipmentHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ShipmentHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ShipmentHistoryScalarWhereInput
    data: XOR<ShipmentHistoryUpdateManyMutationInput, ShipmentHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: IntFilter<"Favorite"> | number
    userCognitoId?: StringFilter<"Favorite"> | string
    stocksId?: IntNullableFilter<"Favorite"> | number | null
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type StockAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: StockAssignmentWhereUniqueInput
    update: XOR<StockAssignmentUpdateWithoutUserInput, StockAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<StockAssignmentCreateWithoutUserInput, StockAssignmentUncheckedCreateWithoutUserInput>
  }

  export type StockAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: StockAssignmentWhereUniqueInput
    data: XOR<StockAssignmentUpdateWithoutUserInput, StockAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type StockAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: StockAssignmentScalarWhereInput
    data: XOR<StockAssignmentUpdateManyMutationInput, StockAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type StockAssignmentScalarWhereInput = {
    AND?: StockAssignmentScalarWhereInput | StockAssignmentScalarWhereInput[]
    OR?: StockAssignmentScalarWhereInput[]
    NOT?: StockAssignmentScalarWhereInput | StockAssignmentScalarWhereInput[]
    id?: IntFilter<"StockAssignment"> | number
    stocksId?: IntFilter<"StockAssignment"> | number
    userCognitoId?: StringFilter<"StockAssignment"> | string
    assignedWeight?: FloatFilter<"StockAssignment"> | number
    assignedAt?: DateTimeFilter<"StockAssignment"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
  }

  export type ContactUpdateManyWithWhereWithoutUserInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: IntFilter<"Contact"> | number
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    subject?: StringNullableFilter<"Contact"> | string | null
    message?: StringFilter<"Contact"> | string
    privacyConsent?: BoolFilter<"Contact"> | boolean
    userCognitoId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type AdminCreateWithoutCatalogsInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    stocks?: StocksCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceCreateNestedManyWithoutAdminInput
    outLots?: OutLotsCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationCreateNestedManyWithoutAdminInput
    shipments?: ShipmentCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCatalogsInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    stocks?: StocksUncheckedCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceUncheckedCreateNestedManyWithoutAdminInput
    outLots?: OutLotsUncheckedCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationUncheckedCreateNestedManyWithoutAdminInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCatalogsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCatalogsInput, AdminUncheckedCreateWithoutCatalogsInput>
  }

  export type AdminUpsertWithoutCatalogsInput = {
    update: XOR<AdminUpdateWithoutCatalogsInput, AdminUncheckedUpdateWithoutCatalogsInput>
    create: XOR<AdminCreateWithoutCatalogsInput, AdminUncheckedCreateWithoutCatalogsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCatalogsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCatalogsInput, AdminUncheckedUpdateWithoutCatalogsInput>
  }

  export type AdminUpdateWithoutCatalogsInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stocks?: StocksUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCatalogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stocks?: StocksUncheckedUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUncheckedUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUncheckedUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutSellingPricesInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogCreateNestedManyWithoutAdminInput
    stocks?: StocksCreateNestedManyWithoutAdminInput
    outLots?: OutLotsCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationCreateNestedManyWithoutAdminInput
    shipments?: ShipmentCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutSellingPricesInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogUncheckedCreateNestedManyWithoutAdminInput
    stocks?: StocksUncheckedCreateNestedManyWithoutAdminInput
    outLots?: OutLotsUncheckedCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationUncheckedCreateNestedManyWithoutAdminInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutSellingPricesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSellingPricesInput, AdminUncheckedCreateWithoutSellingPricesInput>
  }

  export type AdminUpsertWithoutSellingPricesInput = {
    update: XOR<AdminUpdateWithoutSellingPricesInput, AdminUncheckedUpdateWithoutSellingPricesInput>
    create: XOR<AdminCreateWithoutSellingPricesInput, AdminUncheckedCreateWithoutSellingPricesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutSellingPricesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutSellingPricesInput, AdminUncheckedUpdateWithoutSellingPricesInput>
  }

  export type AdminUpdateWithoutSellingPricesInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUpdateManyWithoutAdminNestedInput
    stocks?: StocksUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutSellingPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUncheckedUpdateManyWithoutAdminNestedInput
    stocks?: StocksUncheckedUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUncheckedUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutOutLotsInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogCreateNestedManyWithoutAdminInput
    stocks?: StocksCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationCreateNestedManyWithoutAdminInput
    shipments?: ShipmentCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutOutLotsInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogUncheckedCreateNestedManyWithoutAdminInput
    stocks?: StocksUncheckedCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceUncheckedCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationUncheckedCreateNestedManyWithoutAdminInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutOutLotsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutOutLotsInput, AdminUncheckedCreateWithoutOutLotsInput>
  }

  export type AdminUpsertWithoutOutLotsInput = {
    update: XOR<AdminUpdateWithoutOutLotsInput, AdminUncheckedUpdateWithoutOutLotsInput>
    create: XOR<AdminCreateWithoutOutLotsInput, AdminUncheckedCreateWithoutOutLotsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutOutLotsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutOutLotsInput, AdminUncheckedUpdateWithoutOutLotsInput>
  }

  export type AdminUpdateWithoutOutLotsInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUpdateManyWithoutAdminNestedInput
    stocks?: StocksUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutOutLotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUncheckedUpdateManyWithoutAdminNestedInput
    stocks?: StocksUncheckedUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUncheckedUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutStocksInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceCreateNestedManyWithoutAdminInput
    outLots?: OutLotsCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationCreateNestedManyWithoutAdminInput
    shipments?: ShipmentCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutStocksInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogUncheckedCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceUncheckedCreateNestedManyWithoutAdminInput
    outLots?: OutLotsUncheckedCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationUncheckedCreateNestedManyWithoutAdminInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutStocksInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutStocksInput, AdminUncheckedCreateWithoutStocksInput>
  }

  export type StockAssignmentCreateWithoutStocksInput = {
    assignedWeight: number
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutAssignmentsInput
  }

  export type StockAssignmentUncheckedCreateWithoutStocksInput = {
    id?: number
    userCognitoId: string
    assignedWeight: number
    assignedAt?: Date | string
  }

  export type StockAssignmentCreateOrConnectWithoutStocksInput = {
    where: StockAssignmentWhereUniqueInput
    create: XOR<StockAssignmentCreateWithoutStocksInput, StockAssignmentUncheckedCreateWithoutStocksInput>
  }

  export type StockAssignmentCreateManyStocksInputEnvelope = {
    data: StockAssignmentCreateManyStocksInput | StockAssignmentCreateManyStocksInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentItemCreateWithoutStocksInput = {
    assignedWeight: number
    shipment: ShipmentCreateNestedOneWithoutStocksInput
  }

  export type ShipmentItemUncheckedCreateWithoutStocksInput = {
    id?: number
    shipmentId: number
    assignedWeight: number
  }

  export type ShipmentItemCreateOrConnectWithoutStocksInput = {
    where: ShipmentItemWhereUniqueInput
    create: XOR<ShipmentItemCreateWithoutStocksInput, ShipmentItemUncheckedCreateWithoutStocksInput>
  }

  export type ShipmentItemCreateManyStocksInputEnvelope = {
    data: ShipmentItemCreateManyStocksInput | ShipmentItemCreateManyStocksInput[]
    skipDuplicates?: boolean
  }

  export type StockHistoryCreateWithoutStocksInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutStockHistoryInput
    admin?: AdminCreateNestedOneWithoutStockHistoryInput
    shipment?: ShipmentCreateNestedOneWithoutStockHistoryInput
  }

  export type StockHistoryUncheckedCreateWithoutStocksInput = {
    id?: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: number | null
  }

  export type StockHistoryCreateOrConnectWithoutStocksInput = {
    where: StockHistoryWhereUniqueInput
    create: XOR<StockHistoryCreateWithoutStocksInput, StockHistoryUncheckedCreateWithoutStocksInput>
  }

  export type StockHistoryCreateManyStocksInputEnvelope = {
    data: StockHistoryCreateManyStocksInput | StockHistoryCreateManyStocksInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutStocksInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutStocksInput = {
    id?: number
    userCognitoId: string
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutStocksInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutStocksInput, FavoriteUncheckedCreateWithoutStocksInput>
  }

  export type FavoriteCreateManyStocksInputEnvelope = {
    data: FavoriteCreateManyStocksInput | FavoriteCreateManyStocksInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutStocksInput = {
    update: XOR<AdminUpdateWithoutStocksInput, AdminUncheckedUpdateWithoutStocksInput>
    create: XOR<AdminCreateWithoutStocksInput, AdminUncheckedCreateWithoutStocksInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutStocksInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutStocksInput, AdminUncheckedUpdateWithoutStocksInput>
  }

  export type AdminUpdateWithoutStocksInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUncheckedUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUncheckedUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUncheckedUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type StockAssignmentUpsertWithWhereUniqueWithoutStocksInput = {
    where: StockAssignmentWhereUniqueInput
    update: XOR<StockAssignmentUpdateWithoutStocksInput, StockAssignmentUncheckedUpdateWithoutStocksInput>
    create: XOR<StockAssignmentCreateWithoutStocksInput, StockAssignmentUncheckedCreateWithoutStocksInput>
  }

  export type StockAssignmentUpdateWithWhereUniqueWithoutStocksInput = {
    where: StockAssignmentWhereUniqueInput
    data: XOR<StockAssignmentUpdateWithoutStocksInput, StockAssignmentUncheckedUpdateWithoutStocksInput>
  }

  export type StockAssignmentUpdateManyWithWhereWithoutStocksInput = {
    where: StockAssignmentScalarWhereInput
    data: XOR<StockAssignmentUpdateManyMutationInput, StockAssignmentUncheckedUpdateManyWithoutStocksInput>
  }

  export type ShipmentItemUpsertWithWhereUniqueWithoutStocksInput = {
    where: ShipmentItemWhereUniqueInput
    update: XOR<ShipmentItemUpdateWithoutStocksInput, ShipmentItemUncheckedUpdateWithoutStocksInput>
    create: XOR<ShipmentItemCreateWithoutStocksInput, ShipmentItemUncheckedCreateWithoutStocksInput>
  }

  export type ShipmentItemUpdateWithWhereUniqueWithoutStocksInput = {
    where: ShipmentItemWhereUniqueInput
    data: XOR<ShipmentItemUpdateWithoutStocksInput, ShipmentItemUncheckedUpdateWithoutStocksInput>
  }

  export type ShipmentItemUpdateManyWithWhereWithoutStocksInput = {
    where: ShipmentItemScalarWhereInput
    data: XOR<ShipmentItemUpdateManyMutationInput, ShipmentItemUncheckedUpdateManyWithoutStocksInput>
  }

  export type ShipmentItemScalarWhereInput = {
    AND?: ShipmentItemScalarWhereInput | ShipmentItemScalarWhereInput[]
    OR?: ShipmentItemScalarWhereInput[]
    NOT?: ShipmentItemScalarWhereInput | ShipmentItemScalarWhereInput[]
    id?: IntFilter<"ShipmentItem"> | number
    shipmentId?: IntFilter<"ShipmentItem"> | number
    stocksId?: IntFilter<"ShipmentItem"> | number
    assignedWeight?: FloatFilter<"ShipmentItem"> | number
  }

  export type StockHistoryUpsertWithWhereUniqueWithoutStocksInput = {
    where: StockHistoryWhereUniqueInput
    update: XOR<StockHistoryUpdateWithoutStocksInput, StockHistoryUncheckedUpdateWithoutStocksInput>
    create: XOR<StockHistoryCreateWithoutStocksInput, StockHistoryUncheckedCreateWithoutStocksInput>
  }

  export type StockHistoryUpdateWithWhereUniqueWithoutStocksInput = {
    where: StockHistoryWhereUniqueInput
    data: XOR<StockHistoryUpdateWithoutStocksInput, StockHistoryUncheckedUpdateWithoutStocksInput>
  }

  export type StockHistoryUpdateManyWithWhereWithoutStocksInput = {
    where: StockHistoryScalarWhereInput
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyWithoutStocksInput>
  }

  export type FavoriteUpsertWithWhereUniqueWithoutStocksInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutStocksInput, FavoriteUncheckedUpdateWithoutStocksInput>
    create: XOR<FavoriteCreateWithoutStocksInput, FavoriteUncheckedCreateWithoutStocksInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutStocksInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutStocksInput, FavoriteUncheckedUpdateWithoutStocksInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutStocksInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutStocksInput>
  }

  export type StocksCreateWithoutAssignmentsInput = {
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutStocksInput
    shipmentItems?: ShipmentItemCreateNestedManyWithoutStocksInput
    history?: StockHistoryCreateNestedManyWithoutStocksInput
    favorites?: FavoriteCreateNestedManyWithoutStocksInput
  }

  export type StocksUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    adminCognitoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shipmentItems?: ShipmentItemUncheckedCreateNestedManyWithoutStocksInput
    history?: StockHistoryUncheckedCreateNestedManyWithoutStocksInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutStocksInput
  }

  export type StocksCreateOrConnectWithoutAssignmentsInput = {
    where: StocksWhereUniqueInput
    create: XOR<StocksCreateWithoutAssignmentsInput, StocksUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutAssignmentsInput = {
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignmentsInput, UserUncheckedCreateWithoutAssignmentsInput>
  }

  export type StocksUpsertWithoutAssignmentsInput = {
    update: XOR<StocksUpdateWithoutAssignmentsInput, StocksUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<StocksCreateWithoutAssignmentsInput, StocksUncheckedCreateWithoutAssignmentsInput>
    where?: StocksWhereInput
  }

  export type StocksUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: StocksWhereInput
    data: XOR<StocksUpdateWithoutAssignmentsInput, StocksUncheckedUpdateWithoutAssignmentsInput>
  }

  export type StocksUpdateWithoutAssignmentsInput = {
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUpdateManyWithoutStocksNestedInput
  }

  export type StocksUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipmentItems?: ShipmentItemUncheckedUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUncheckedUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutStocksNestedInput
  }

  export type UserUpsertWithoutAssignmentsInput = {
    update: XOR<UserUpdateWithoutAssignmentsInput, UserUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<UserCreateWithoutAssignmentsInput, UserUncheckedCreateWithoutAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignmentsInput, UserUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateWithoutAssignmentsInput = {
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShipmentHistoryCreateWithoutShipmentInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutShipmentHistoryInput
    admin?: AdminCreateNestedOneWithoutShipmentHistoryInput
  }

  export type ShipmentHistoryUncheckedCreateWithoutShipmentInput = {
    id?: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryCreateOrConnectWithoutShipmentInput = {
    where: ShipmentHistoryWhereUniqueInput
    create: XOR<ShipmentHistoryCreateWithoutShipmentInput, ShipmentHistoryUncheckedCreateWithoutShipmentInput>
  }

  export type ShipmentHistoryCreateManyShipmentInputEnvelope = {
    data: ShipmentHistoryCreateManyShipmentInput | ShipmentHistoryCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type StockHistoryCreateWithoutShipmentInput = {
    action: string
    timestamp?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    stocks: StocksCreateNestedOneWithoutHistoryInput
    user?: UserCreateNestedOneWithoutStockHistoryInput
    admin?: AdminCreateNestedOneWithoutStockHistoryInput
  }

  export type StockHistoryUncheckedCreateWithoutShipmentInput = {
    id?: number
    stocksId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StockHistoryCreateOrConnectWithoutShipmentInput = {
    where: StockHistoryWhereUniqueInput
    create: XOR<StockHistoryCreateWithoutShipmentInput, StockHistoryUncheckedCreateWithoutShipmentInput>
  }

  export type StockHistoryCreateManyShipmentInputEnvelope = {
    data: StockHistoryCreateManyShipmentInput | StockHistoryCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentItemCreateWithoutShipmentInput = {
    assignedWeight: number
    stocks: StocksCreateNestedOneWithoutShipmentItemsInput
  }

  export type ShipmentItemUncheckedCreateWithoutShipmentInput = {
    id?: number
    stocksId: number
    assignedWeight: number
  }

  export type ShipmentItemCreateOrConnectWithoutShipmentInput = {
    where: ShipmentItemWhereUniqueInput
    create: XOR<ShipmentItemCreateWithoutShipmentInput, ShipmentItemUncheckedCreateWithoutShipmentInput>
  }

  export type ShipmentItemCreateManyShipmentInputEnvelope = {
    data: ShipmentItemCreateManyShipmentInput | ShipmentItemCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutShipmentsInput = {
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockHistory?: StockHistoryCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShipmentsInput = {
    id?: number
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShipmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShipmentsInput, UserUncheckedCreateWithoutShipmentsInput>
  }

  export type AdminCreateWithoutShipmentsInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogCreateNestedManyWithoutAdminInput
    stocks?: StocksCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceCreateNestedManyWithoutAdminInput
    outLots?: OutLotsCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutShipmentsInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogUncheckedCreateNestedManyWithoutAdminInput
    stocks?: StocksUncheckedCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceUncheckedCreateNestedManyWithoutAdminInput
    outLots?: OutLotsUncheckedCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationUncheckedCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutShipmentsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutShipmentsInput, AdminUncheckedCreateWithoutShipmentsInput>
  }

  export type ShipmentHistoryUpsertWithWhereUniqueWithoutShipmentInput = {
    where: ShipmentHistoryWhereUniqueInput
    update: XOR<ShipmentHistoryUpdateWithoutShipmentInput, ShipmentHistoryUncheckedUpdateWithoutShipmentInput>
    create: XOR<ShipmentHistoryCreateWithoutShipmentInput, ShipmentHistoryUncheckedCreateWithoutShipmentInput>
  }

  export type ShipmentHistoryUpdateWithWhereUniqueWithoutShipmentInput = {
    where: ShipmentHistoryWhereUniqueInput
    data: XOR<ShipmentHistoryUpdateWithoutShipmentInput, ShipmentHistoryUncheckedUpdateWithoutShipmentInput>
  }

  export type ShipmentHistoryUpdateManyWithWhereWithoutShipmentInput = {
    where: ShipmentHistoryScalarWhereInput
    data: XOR<ShipmentHistoryUpdateManyMutationInput, ShipmentHistoryUncheckedUpdateManyWithoutShipmentInput>
  }

  export type StockHistoryUpsertWithWhereUniqueWithoutShipmentInput = {
    where: StockHistoryWhereUniqueInput
    update: XOR<StockHistoryUpdateWithoutShipmentInput, StockHistoryUncheckedUpdateWithoutShipmentInput>
    create: XOR<StockHistoryCreateWithoutShipmentInput, StockHistoryUncheckedCreateWithoutShipmentInput>
  }

  export type StockHistoryUpdateWithWhereUniqueWithoutShipmentInput = {
    where: StockHistoryWhereUniqueInput
    data: XOR<StockHistoryUpdateWithoutShipmentInput, StockHistoryUncheckedUpdateWithoutShipmentInput>
  }

  export type StockHistoryUpdateManyWithWhereWithoutShipmentInput = {
    where: StockHistoryScalarWhereInput
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyWithoutShipmentInput>
  }

  export type ShipmentItemUpsertWithWhereUniqueWithoutShipmentInput = {
    where: ShipmentItemWhereUniqueInput
    update: XOR<ShipmentItemUpdateWithoutShipmentInput, ShipmentItemUncheckedUpdateWithoutShipmentInput>
    create: XOR<ShipmentItemCreateWithoutShipmentInput, ShipmentItemUncheckedCreateWithoutShipmentInput>
  }

  export type ShipmentItemUpdateWithWhereUniqueWithoutShipmentInput = {
    where: ShipmentItemWhereUniqueInput
    data: XOR<ShipmentItemUpdateWithoutShipmentInput, ShipmentItemUncheckedUpdateWithoutShipmentInput>
  }

  export type ShipmentItemUpdateManyWithWhereWithoutShipmentInput = {
    where: ShipmentItemScalarWhereInput
    data: XOR<ShipmentItemUpdateManyMutationInput, ShipmentItemUncheckedUpdateManyWithoutShipmentInput>
  }

  export type UserUpsertWithoutShipmentsInput = {
    update: XOR<UserUpdateWithoutShipmentsInput, UserUncheckedUpdateWithoutShipmentsInput>
    create: XOR<UserCreateWithoutShipmentsInput, UserUncheckedCreateWithoutShipmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShipmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShipmentsInput, UserUncheckedUpdateWithoutShipmentsInput>
  }

  export type UserUpdateWithoutShipmentsInput = {
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockHistory?: StockHistoryUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminUpsertWithoutShipmentsInput = {
    update: XOR<AdminUpdateWithoutShipmentsInput, AdminUncheckedUpdateWithoutShipmentsInput>
    create: XOR<AdminCreateWithoutShipmentsInput, AdminUncheckedCreateWithoutShipmentsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutShipmentsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutShipmentsInput, AdminUncheckedUpdateWithoutShipmentsInput>
  }

  export type AdminUpdateWithoutShipmentsInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUpdateManyWithoutAdminNestedInput
    stocks?: StocksUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutShipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUncheckedUpdateManyWithoutAdminNestedInput
    stocks?: StocksUncheckedUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUncheckedUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUncheckedUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type ShipmentCreateWithoutStocksInput = {
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryCreateNestedManyWithoutShipmentInput
    stockHistory?: StockHistoryCreateNestedManyWithoutShipmentInput
    user: UserCreateNestedOneWithoutShipmentsInput
    admin?: AdminCreateNestedOneWithoutShipmentsInput
  }

  export type ShipmentUncheckedCreateWithoutStocksInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    userCognitoId: string
    adminCognitoId?: string | null
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutStocksInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutStocksInput, ShipmentUncheckedCreateWithoutStocksInput>
  }

  export type StocksCreateWithoutShipmentItemsInput = {
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutStocksInput
    assignments?: StockAssignmentCreateNestedManyWithoutStocksInput
    history?: StockHistoryCreateNestedManyWithoutStocksInput
    favorites?: FavoriteCreateNestedManyWithoutStocksInput
  }

  export type StocksUncheckedCreateWithoutShipmentItemsInput = {
    id?: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    adminCognitoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutStocksInput
    history?: StockHistoryUncheckedCreateNestedManyWithoutStocksInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutStocksInput
  }

  export type StocksCreateOrConnectWithoutShipmentItemsInput = {
    where: StocksWhereUniqueInput
    create: XOR<StocksCreateWithoutShipmentItemsInput, StocksUncheckedCreateWithoutShipmentItemsInput>
  }

  export type ShipmentUpsertWithoutStocksInput = {
    update: XOR<ShipmentUpdateWithoutStocksInput, ShipmentUncheckedUpdateWithoutStocksInput>
    create: XOR<ShipmentCreateWithoutStocksInput, ShipmentUncheckedCreateWithoutStocksInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutStocksInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutStocksInput, ShipmentUncheckedUpdateWithoutStocksInput>
  }

  export type ShipmentUpdateWithoutStocksInput = {
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUpdateManyWithoutShipmentNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutShipmentNestedInput
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    admin?: AdminUpdateOneWithoutShipmentsNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    userCognitoId?: StringFieldUpdateOperationsInput | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type StocksUpsertWithoutShipmentItemsInput = {
    update: XOR<StocksUpdateWithoutShipmentItemsInput, StocksUncheckedUpdateWithoutShipmentItemsInput>
    create: XOR<StocksCreateWithoutShipmentItemsInput, StocksUncheckedCreateWithoutShipmentItemsInput>
    where?: StocksWhereInput
  }

  export type StocksUpdateToOneWithWhereWithoutShipmentItemsInput = {
    where?: StocksWhereInput
    data: XOR<StocksUpdateWithoutShipmentItemsInput, StocksUncheckedUpdateWithoutShipmentItemsInput>
  }

  export type StocksUpdateWithoutShipmentItemsInput = {
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutStocksNestedInput
    assignments?: StockAssignmentUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUpdateManyWithoutStocksNestedInput
  }

  export type StocksUncheckedUpdateWithoutShipmentItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: StockAssignmentUncheckedUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUncheckedUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutStocksNestedInput
  }

  export type StocksCreateWithoutHistoryInput = {
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutStocksInput
    assignments?: StockAssignmentCreateNestedManyWithoutStocksInput
    shipmentItems?: ShipmentItemCreateNestedManyWithoutStocksInput
    favorites?: FavoriteCreateNestedManyWithoutStocksInput
  }

  export type StocksUncheckedCreateWithoutHistoryInput = {
    id?: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    adminCognitoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutStocksInput
    shipmentItems?: ShipmentItemUncheckedCreateNestedManyWithoutStocksInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutStocksInput
  }

  export type StocksCreateOrConnectWithoutHistoryInput = {
    where: StocksWhereUniqueInput
    create: XOR<StocksCreateWithoutHistoryInput, StocksUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutStockHistoryInput = {
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStockHistoryInput = {
    id?: number
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStockHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStockHistoryInput, UserUncheckedCreateWithoutStockHistoryInput>
  }

  export type AdminCreateWithoutStockHistoryInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogCreateNestedManyWithoutAdminInput
    stocks?: StocksCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceCreateNestedManyWithoutAdminInput
    outLots?: OutLotsCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationCreateNestedManyWithoutAdminInput
    shipments?: ShipmentCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutStockHistoryInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogUncheckedCreateNestedManyWithoutAdminInput
    stocks?: StocksUncheckedCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceUncheckedCreateNestedManyWithoutAdminInput
    outLots?: OutLotsUncheckedCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationUncheckedCreateNestedManyWithoutAdminInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutStockHistoryInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutStockHistoryInput, AdminUncheckedCreateWithoutStockHistoryInput>
  }

  export type ShipmentCreateWithoutStockHistoryInput = {
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemCreateNestedManyWithoutShipmentInput
    user: UserCreateNestedOneWithoutShipmentsInput
    admin?: AdminCreateNestedOneWithoutShipmentsInput
  }

  export type ShipmentUncheckedCreateWithoutStockHistoryInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    userCognitoId: string
    adminCognitoId?: string | null
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    historyEntries?: ShipmentHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutStockHistoryInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutStockHistoryInput, ShipmentUncheckedCreateWithoutStockHistoryInput>
  }

  export type StocksUpsertWithoutHistoryInput = {
    update: XOR<StocksUpdateWithoutHistoryInput, StocksUncheckedUpdateWithoutHistoryInput>
    create: XOR<StocksCreateWithoutHistoryInput, StocksUncheckedCreateWithoutHistoryInput>
    where?: StocksWhereInput
  }

  export type StocksUpdateToOneWithWhereWithoutHistoryInput = {
    where?: StocksWhereInput
    data: XOR<StocksUpdateWithoutHistoryInput, StocksUncheckedUpdateWithoutHistoryInput>
  }

  export type StocksUpdateWithoutHistoryInput = {
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutStocksNestedInput
    assignments?: StockAssignmentUpdateManyWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUpdateManyWithoutStocksNestedInput
  }

  export type StocksUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: StockAssignmentUncheckedUpdateManyWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUncheckedUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutStocksNestedInput
  }

  export type UserUpsertWithoutStockHistoryInput = {
    update: XOR<UserUpdateWithoutStockHistoryInput, UserUncheckedUpdateWithoutStockHistoryInput>
    create: XOR<UserCreateWithoutStockHistoryInput, UserUncheckedCreateWithoutStockHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStockHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStockHistoryInput, UserUncheckedUpdateWithoutStockHistoryInput>
  }

  export type UserUpdateWithoutStockHistoryInput = {
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStockHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminUpsertWithoutStockHistoryInput = {
    update: XOR<AdminUpdateWithoutStockHistoryInput, AdminUncheckedUpdateWithoutStockHistoryInput>
    create: XOR<AdminCreateWithoutStockHistoryInput, AdminUncheckedCreateWithoutStockHistoryInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutStockHistoryInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutStockHistoryInput, AdminUncheckedUpdateWithoutStockHistoryInput>
  }

  export type AdminUpdateWithoutStockHistoryInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUpdateManyWithoutAdminNestedInput
    stocks?: StocksUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutStockHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUncheckedUpdateManyWithoutAdminNestedInput
    stocks?: StocksUncheckedUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUncheckedUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUncheckedUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type ShipmentUpsertWithoutStockHistoryInput = {
    update: XOR<ShipmentUpdateWithoutStockHistoryInput, ShipmentUncheckedUpdateWithoutStockHistoryInput>
    create: XOR<ShipmentCreateWithoutStockHistoryInput, ShipmentUncheckedCreateWithoutStockHistoryInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutStockHistoryInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutStockHistoryInput, ShipmentUncheckedUpdateWithoutStockHistoryInput>
  }

  export type ShipmentUpdateWithoutStockHistoryInput = {
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUpdateManyWithoutShipmentNestedInput
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    admin?: AdminUpdateOneWithoutShipmentsNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutStockHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    userCognitoId?: StringFieldUpdateOperationsInput | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentCreateWithoutHistoryEntriesInput = {
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    stockHistory?: StockHistoryCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemCreateNestedManyWithoutShipmentInput
    user: UserCreateNestedOneWithoutShipmentsInput
    admin?: AdminCreateNestedOneWithoutShipmentsInput
  }

  export type ShipmentUncheckedCreateWithoutHistoryEntriesInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    userCognitoId: string
    adminCognitoId?: string | null
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutShipmentInput
    stocks?: ShipmentItemUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutHistoryEntriesInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutHistoryEntriesInput, ShipmentUncheckedCreateWithoutHistoryEntriesInput>
  }

  export type UserCreateWithoutShipmentHistoryInput = {
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShipmentHistoryInput = {
    id?: number
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShipmentHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShipmentHistoryInput, UserUncheckedCreateWithoutShipmentHistoryInput>
  }

  export type AdminCreateWithoutShipmentHistoryInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogCreateNestedManyWithoutAdminInput
    stocks?: StocksCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceCreateNestedManyWithoutAdminInput
    outLots?: OutLotsCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationCreateNestedManyWithoutAdminInput
    shipments?: ShipmentCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutShipmentHistoryInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogUncheckedCreateNestedManyWithoutAdminInput
    stocks?: StocksUncheckedCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceUncheckedCreateNestedManyWithoutAdminInput
    outLots?: OutLotsUncheckedCreateNestedManyWithoutAdminInput
    notifications?: AdminNotificationUncheckedCreateNestedManyWithoutAdminInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutShipmentHistoryInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutShipmentHistoryInput, AdminUncheckedCreateWithoutShipmentHistoryInput>
  }

  export type ShipmentUpsertWithoutHistoryEntriesInput = {
    update: XOR<ShipmentUpdateWithoutHistoryEntriesInput, ShipmentUncheckedUpdateWithoutHistoryEntriesInput>
    create: XOR<ShipmentCreateWithoutHistoryEntriesInput, ShipmentUncheckedCreateWithoutHistoryEntriesInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutHistoryEntriesInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutHistoryEntriesInput, ShipmentUncheckedUpdateWithoutHistoryEntriesInput>
  }

  export type ShipmentUpdateWithoutHistoryEntriesInput = {
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockHistory?: StockHistoryUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUpdateManyWithoutShipmentNestedInput
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    admin?: AdminUpdateOneWithoutShipmentsNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutHistoryEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    userCognitoId?: StringFieldUpdateOperationsInput | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type UserUpsertWithoutShipmentHistoryInput = {
    update: XOR<UserUpdateWithoutShipmentHistoryInput, UserUncheckedUpdateWithoutShipmentHistoryInput>
    create: XOR<UserCreateWithoutShipmentHistoryInput, UserUncheckedCreateWithoutShipmentHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShipmentHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShipmentHistoryInput, UserUncheckedUpdateWithoutShipmentHistoryInput>
  }

  export type UserUpdateWithoutShipmentHistoryInput = {
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShipmentHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminUpsertWithoutShipmentHistoryInput = {
    update: XOR<AdminUpdateWithoutShipmentHistoryInput, AdminUncheckedUpdateWithoutShipmentHistoryInput>
    create: XOR<AdminCreateWithoutShipmentHistoryInput, AdminUncheckedCreateWithoutShipmentHistoryInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutShipmentHistoryInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutShipmentHistoryInput, AdminUncheckedUpdateWithoutShipmentHistoryInput>
  }

  export type AdminUpdateWithoutShipmentHistoryInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUpdateManyWithoutAdminNestedInput
    stocks?: StocksUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutShipmentHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUncheckedUpdateManyWithoutAdminNestedInput
    stocks?: StocksUncheckedUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUncheckedUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUncheckedUpdateManyWithoutAdminNestedInput
    notifications?: AdminNotificationUncheckedUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutNotificationsInput = {
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogCreateNestedManyWithoutAdminInput
    stocks?: StocksCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceCreateNestedManyWithoutAdminInput
    outLots?: OutLotsCreateNestedManyWithoutAdminInput
    shipments?: ShipmentCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutNotificationsInput = {
    id?: number
    adminCognitoId: string
    name?: string | null
    email?: string | null
    phoneNumber?: string | null
    catalogs?: CatalogUncheckedCreateNestedManyWithoutAdminInput
    stocks?: StocksUncheckedCreateNestedManyWithoutAdminInput
    sellingPrices?: SellingPriceUncheckedCreateNestedManyWithoutAdminInput
    outLots?: OutLotsUncheckedCreateNestedManyWithoutAdminInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutAdminInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutAdminInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutNotificationsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutNotificationsInput, AdminUncheckedCreateWithoutNotificationsInput>
  }

  export type AdminUpsertWithoutNotificationsInput = {
    update: XOR<AdminUpdateWithoutNotificationsInput, AdminUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AdminCreateWithoutNotificationsInput, AdminUncheckedCreateWithoutNotificationsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutNotificationsInput, AdminUncheckedUpdateWithoutNotificationsInput>
  }

  export type AdminUpdateWithoutNotificationsInput = {
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUpdateManyWithoutAdminNestedInput
    stocks?: StocksUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    catalogs?: CatalogUncheckedUpdateManyWithoutAdminNestedInput
    stocks?: StocksUncheckedUpdateManyWithoutAdminNestedInput
    sellingPrices?: SellingPriceUncheckedUpdateManyWithoutAdminNestedInput
    outLots?: OutLotsUncheckedUpdateManyWithoutAdminNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutAdminNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutAdminNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type UserCreateWithoutContactsInput = {
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: number
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFavoritesInput = {
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: number
    userCognitoId: string
    name?: string | null
    email?: string | null
    role?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    stockHistory?: StockHistoryUncheckedCreateNestedManyWithoutUserInput
    shipmentHistory?: ShipmentHistoryUncheckedCreateNestedManyWithoutUserInput
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type StocksCreateWithoutFavoritesInput = {
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutStocksInput
    assignments?: StockAssignmentCreateNestedManyWithoutStocksInput
    shipmentItems?: ShipmentItemCreateNestedManyWithoutStocksInput
    history?: StockHistoryCreateNestedManyWithoutStocksInput
  }

  export type StocksUncheckedCreateWithoutFavoritesInput = {
    id?: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    adminCognitoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: StockAssignmentUncheckedCreateNestedManyWithoutStocksInput
    shipmentItems?: ShipmentItemUncheckedCreateNestedManyWithoutStocksInput
    history?: StockHistoryUncheckedCreateNestedManyWithoutStocksInput
  }

  export type StocksCreateOrConnectWithoutFavoritesInput = {
    where: StocksWhereUniqueInput
    create: XOR<StocksCreateWithoutFavoritesInput, StocksUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutUserNestedInput
    shipmentHistory?: ShipmentHistoryUncheckedUpdateManyWithoutUserNestedInput
    assignments?: StockAssignmentUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StocksUpsertWithoutFavoritesInput = {
    update: XOR<StocksUpdateWithoutFavoritesInput, StocksUncheckedUpdateWithoutFavoritesInput>
    create: XOR<StocksCreateWithoutFavoritesInput, StocksUncheckedCreateWithoutFavoritesInput>
    where?: StocksWhereInput
  }

  export type StocksUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: StocksWhereInput
    data: XOR<StocksUpdateWithoutFavoritesInput, StocksUncheckedUpdateWithoutFavoritesInput>
  }

  export type StocksUpdateWithoutFavoritesInput = {
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutStocksNestedInput
    assignments?: StockAssignmentUpdateManyWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUpdateManyWithoutStocksNestedInput
  }

  export type StocksUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    adminCognitoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: StockAssignmentUncheckedUpdateManyWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUncheckedUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUncheckedUpdateManyWithoutStocksNestedInput
  }

  export type CatalogCreateManyAdminInput = {
    id?: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StocksCreateManyAdminInput = {
    id?: number
    saleCode: string
    broker: $Enums.Broker
    lotNo: string
    mark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    weight: number
    purchaseValue: number
    totalPurchaseValue: number
    agingDays: number
    penalty: number
    bgtCommission: number
    maerskFee: number
    commission: number
    netPrice: number
    total: number
    batchNumber?: string | null
    lowStockThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingPriceCreateManyAdminInput = {
    id?: number
    broker: $Enums.Broker
    lotNo: string
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    saleCode: string
    category: $Enums.TeaCategory
    reprint: string
    bags: number
    netWeight: number
    totalWeight: number
    askingPrice: number
    purchasePrice: number
    producerCountry?: string | null
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutLotsCreateManyAdminInput = {
    id?: number
    auction: string
    lotNo: string
    broker: $Enums.Broker
    sellingMark: string
    grade: $Enums.TeaGrade
    invoiceNo: string
    bags: number
    netWeight: number
    totalWeight: number
    baselinePrice: number
    manufactureDate: Date | string
    userCognitoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNotificationCreateManyAdminInput = {
    id?: number
    message: string
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ShipmentCreateManyAdminInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    userCognitoId: string
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
  }

  export type StockHistoryCreateManyAdminInput = {
    id?: number
    stocksId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: number | null
  }

  export type ShipmentHistoryCreateManyAdminInput = {
    id?: number
    shipmentId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CatalogUpdateWithoutAdminInput = {
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StocksUpdateWithoutAdminInput = {
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: StockAssignmentUpdateManyWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUpdateManyWithoutStocksNestedInput
  }

  export type StocksUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: StockAssignmentUncheckedUpdateManyWithoutStocksNestedInput
    shipmentItems?: ShipmentItemUncheckedUpdateManyWithoutStocksNestedInput
    history?: StockHistoryUncheckedUpdateManyWithoutStocksNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutStocksNestedInput
  }

  export type StocksUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleCode?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    mark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: FloatFieldUpdateOperationsInput | number
    totalPurchaseValue?: FloatFieldUpdateOperationsInput | number
    agingDays?: IntFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    bgtCommission?: FloatFieldUpdateOperationsInput | number
    maerskFee?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPriceUpdateWithoutAdminInput = {
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPriceUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPriceUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    lotNo?: StringFieldUpdateOperationsInput | string
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleCode?: StringFieldUpdateOperationsInput | string
    category?: EnumTeaCategoryFieldUpdateOperationsInput | $Enums.TeaCategory
    reprint?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    askingPrice?: FloatFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    producerCountry?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutLotsUpdateWithoutAdminInput = {
    auction?: StringFieldUpdateOperationsInput | string
    lotNo?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    baselinePrice?: FloatFieldUpdateOperationsInput | number
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutLotsUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    auction?: StringFieldUpdateOperationsInput | string
    lotNo?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    baselinePrice?: FloatFieldUpdateOperationsInput | number
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutLotsUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    auction?: StringFieldUpdateOperationsInput | string
    lotNo?: StringFieldUpdateOperationsInput | string
    broker?: EnumBrokerFieldUpdateOperationsInput | $Enums.Broker
    sellingMark?: StringFieldUpdateOperationsInput | string
    grade?: EnumTeaGradeFieldUpdateOperationsInput | $Enums.TeaGrade
    invoiceNo?: StringFieldUpdateOperationsInput | string
    bags?: IntFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    baselinePrice?: FloatFieldUpdateOperationsInput | number
    manufactureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNotificationUpdateWithoutAdminInput = {
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNotificationUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNotificationUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUpdateWithoutAdminInput = {
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUpdateManyWithoutShipmentNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUpdateManyWithoutShipmentNestedInput
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    userCognitoId?: StringFieldUpdateOperationsInput | string
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    userCognitoId?: StringFieldUpdateOperationsInput | string
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUpdateWithoutAdminInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    stocks?: StocksUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneWithoutStockHistoryNestedInput
    shipment?: ShipmentUpdateOneWithoutStockHistoryNestedInput
  }

  export type StockHistoryUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockHistoryUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ShipmentHistoryUpdateWithoutAdminInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    shipment?: ShipmentUpdateOneRequiredWithoutHistoryEntriesNestedInput
    user?: UserUpdateOneWithoutShipmentHistoryNestedInput
  }

  export type ShipmentHistoryUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentCreateManyUserInput = {
    id?: number
    shipmentDate: Date | string
    status: $Enums.ShipmentStatus
    adminCognitoId?: string | null
    consignee: string
    vessel: $Enums.Vessel
    shipmark: string
    packagingInstructions: $Enums.PackagingInstructions
    additionalInstructions?: string | null
    createdAt?: Date | string
  }

  export type StockHistoryCreateManyUserInput = {
    id?: number
    stocksId: number
    action: string
    timestamp?: Date | string
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: number | null
  }

  export type ShipmentHistoryCreateManyUserInput = {
    id?: number
    shipmentId: number
    action: string
    timestamp?: Date | string
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FavoriteCreateManyUserInput = {
    id?: number
    stocksId?: number | null
    createdAt?: Date | string
  }

  export type StockAssignmentCreateManyUserInput = {
    id?: number
    stocksId: number
    assignedWeight: number
    assignedAt?: Date | string
  }

  export type ContactCreateManyUserInput = {
    id?: number
    name: string
    email: string
    subject?: string | null
    message: string
    privacyConsent: boolean
    createdAt?: Date | string
  }

  export type ShipmentUpdateWithoutUserInput = {
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUpdateManyWithoutShipmentNestedInput
    stockHistory?: StockHistoryUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUpdateManyWithoutShipmentNestedInput
    admin?: AdminUpdateOneWithoutShipmentsNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    historyEntries?: ShipmentHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stockHistory?: StockHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    stocks?: ShipmentItemUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: StringFieldUpdateOperationsInput | string
    vessel?: EnumVesselFieldUpdateOperationsInput | $Enums.Vessel
    shipmark?: StringFieldUpdateOperationsInput | string
    packagingInstructions?: EnumPackagingInstructionsFieldUpdateOperationsInput | $Enums.PackagingInstructions
    additionalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    stocks?: StocksUpdateOneRequiredWithoutHistoryNestedInput
    admin?: AdminUpdateOneWithoutStockHistoryNestedInput
    shipment?: ShipmentUpdateOneWithoutStockHistoryNestedInput
  }

  export type StockHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ShipmentHistoryUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    shipment?: ShipmentUpdateOneRequiredWithoutHistoryEntriesNestedInput
    admin?: AdminUpdateOneWithoutShipmentHistoryNestedInput
  }

  export type ShipmentHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FavoriteUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StocksUpdateOneWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAssignmentUpdateWithoutUserInput = {
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StocksUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type StockAssignmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    privacyConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    privacyConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    privacyConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAssignmentCreateManyStocksInput = {
    id?: number
    userCognitoId: string
    assignedWeight: number
    assignedAt?: Date | string
  }

  export type ShipmentItemCreateManyStocksInput = {
    id?: number
    shipmentId: number
    assignedWeight: number
  }

  export type StockHistoryCreateManyStocksInput = {
    id?: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: number | null
  }

  export type FavoriteCreateManyStocksInput = {
    id?: number
    userCognitoId: string
    createdAt?: Date | string
  }

  export type StockAssignmentUpdateWithoutStocksInput = {
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type StockAssignmentUncheckedUpdateWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAssignmentUncheckedUpdateManyWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentItemUpdateWithoutStocksInput = {
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    shipment?: ShipmentUpdateOneRequiredWithoutStocksNestedInput
  }

  export type ShipmentItemUncheckedUpdateWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    assignedWeight?: FloatFieldUpdateOperationsInput | number
  }

  export type ShipmentItemUncheckedUpdateManyWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    assignedWeight?: FloatFieldUpdateOperationsInput | number
  }

  export type StockHistoryUpdateWithoutStocksInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutStockHistoryNestedInput
    admin?: AdminUpdateOneWithoutStockHistoryNestedInput
    shipment?: ShipmentUpdateOneWithoutStockHistoryNestedInput
  }

  export type StockHistoryUncheckedUpdateWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockHistoryUncheckedUpdateManyWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FavoriteUpdateWithoutStocksInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutStocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCognitoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentHistoryCreateManyShipmentInput = {
    id?: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StockHistoryCreateManyShipmentInput = {
    id?: number
    stocksId: number
    action: string
    timestamp?: Date | string
    userCognitoId?: string | null
    adminCognitoId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentItemCreateManyShipmentInput = {
    id?: number
    stocksId: number
    assignedWeight: number
  }

  export type ShipmentHistoryUpdateWithoutShipmentInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutShipmentHistoryNestedInput
    admin?: AdminUpdateOneWithoutShipmentHistoryNestedInput
  }

  export type ShipmentHistoryUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentHistoryUncheckedUpdateManyWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StockHistoryUpdateWithoutShipmentInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    stocks?: StocksUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneWithoutStockHistoryNestedInput
    admin?: AdminUpdateOneWithoutStockHistoryNestedInput
  }

  export type StockHistoryUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StockHistoryUncheckedUpdateManyWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    adminCognitoId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShipmentItemUpdateWithoutShipmentInput = {
    assignedWeight?: FloatFieldUpdateOperationsInput | number
    stocks?: StocksUpdateOneRequiredWithoutShipmentItemsNestedInput
  }

  export type ShipmentItemUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    assignedWeight?: FloatFieldUpdateOperationsInput | number
  }

  export type ShipmentItemUncheckedUpdateManyWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    stocksId?: IntFieldUpdateOperationsInput | number
    assignedWeight?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}